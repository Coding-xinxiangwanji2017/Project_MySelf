/********************************************************************
        Actel smartfusion2 Verilog Library
        NAME: smartfusion2.v
        DATE: December 17, 2014
        TIME: 12:40:20
        NOTE: This file was automatically generated
*********************************************************************/

`timescale 1 ns / 10 ps

//----------------------------------------------------------------------
//---             VERILOG LIBRRAY PRIMITIVE SECTION                     
//----------------------------------------------------------------------

//---------------------------------------------------------------------
// primitibe module (UDP_DFF) state table definition
// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP 
//                     WITH ACTIVE LOW ASYNCHRONOUS LOAD
//                     Q OUTPUT UDP.
//----------------------------------------------------------------------
primitive UDP_DFF (Q, AL, AD, SD, CLK);
  output Q;
  input AL, AD, SD, CLK;
  reg Q;
  table
  //AL    AD   SD   CLK  :  Qn  : Qn+1
     0     0    ?     ?  :  ?   :  0  ;   // Async Data
     0     1    ?     ?  :  ?   :  1  ;
     0     x    ?     ?  :  ?   :  x  ;    
    (?0)   0    ?     ?  :  ?   :  0  ;   // Update output for 
    (?0)   1    ?     ?  :  ?   :  1  ;   // Falling Edge
    (?0)   x    ?     ?  :  ?   :  x  ;
     0    (?0)  ?     ?  :  ?   :  0  ;   // Update output for 
     0    (?1)  ?     ?  :  ?   :  1  ;   // Changes in AD
     0    (?x)  ?     ?  :  ?   :  x  ;
    (?x)   0    ?     ?  :  0   :  0  ;   // Reducing Pessimism due to
    (?x)   1    ?     ?  :  1   :  1  ;   // transitions to X on AL
    (?x)   x    ?     ?  :  ?   :  x  ;                         // I can remove this line
    (?x)   ?    ?     ?  :  x   :  x  ;                         // I can remove this line
    (?x)   0    ?     ?  :  1   :  x  ;                         // I can remove this line
    (?x)   1    ?     ?  :  0   :  x  ;                         // I can remove this line
     x     x    ?     ?  :  ?   :  x  ;                         // I can remove this line
     x     0    ?     ?  :  1   :  x  ;                         // I can remove this line
     x     1    ?     ?  :  0   :  x  ;                         // I can remove this line
     1     ?    0   (01) :  ?   :  0  ;   // Sync Data
     1     ?    1   (01) :  ?   :  1  ;
     1     ?    x   (01) :  ?   :  x  ;
     1     ?    0   (x1) :  0   :  0  ;
     1     ?    1   (x1) :  1   :  1  ;
     1     ?    ?   (x1) :  x   :  x  ;                         // I can remove this line
     1     ?    x   (x1) :  ?   :  x  ;                         // I can remove this line
     1     ?    0   (x1) :  1   :  x  ;                         // I can remove this line
     1     ?    1   (x1) :  0   :  x  ;                         // I can remove this line
     x     1    1   (01) :  ?   :  1  ;
     x     0    0   (01) :  ?   :  0  ;
     x     ?    x   (01) :  ?   :  x  ;
     x     x    ?   (01) :  ?   :  x  ;
     x     1    0   (01) :  ?   :  x  ;
     x     0    1   (01) :  ?   :  x  ;
     x     0    0   (x1) :  0   :  0  ;
     x     1    1   (x1) :  1   :  1  ;
     x     ?    ?   (x1) :  x   :  x  ;
     x     ?    x   (x1) :  ?   :  x  ;
     x     x    ?   (x1) :  ?   :  x  ;
     x     ?    1   (x1) :  0   :  x  ;
    (?1)   ?    ?     ?  :  ?   :  -  ;   // Ignore Rising Edge on AL
     0     ?    ?     *  :  ?   :  -  ;   // Ignore Changes on CLK during Async
     ?     ?    ?   (?0) :  ?   :  -  ;   // Ignore CLK falling edge
     1     *    ?     ?  :  ?   :  -  ;   // Ignore changes on AD during Sync
     ?     ?    *     ?  :  ?   :  -  ;   // Ignore changes on SD during Sync
  endtable
endprimitive

//---------------------------------------------------------------------
// primitibe module (UDP_DL) state table definition
// FUNCTION : POSITIVE EDGE TRIGGERED D LATCH 
//                     WITH ACTIVE LOW ASYNCHRONOUS LOAD
//                     Q OUTPUT UDP.
//----------------------------------------------------------------------
primitive UDP_DL (Q, AL, AD, SD, CLK);
  output Q;
  input AL, AD, SD, CLK;
  reg Q;
  table
  //AL    AD   SD   CLK  :  Qn  : Qn+1
     0     0    ?     ?  :  ?   :  0  ;
     0     1    ?     ?  :  ?   :  1  ;
     0     x    ?     ?  :  ?   :  x  ;
    (?1)   ?    ?     ?  :  ?   :  -  ;
    (?0)   0    ?     ?  :  ?   :  0  ;
    (?0)   1    ?     ?  :  ?   :  1  ;
    (?0)   x    ?     ?  :  ?   :  x  ;
     0    (?0)  ?     ?  :  ?   :  0  ;
     0    (?1)  ?     ?  :  ?   :  1  ;
     0    (?x)  ?     ?  :  ?   :  x  ;
    (?x)   0    ?     ?  :  0   :  0  ;
    (?x)   1    ?     ?  :  1   :  1  ;
    (?x)   x    ?     ?  :  ?   :  x  ;
    (?x)   ?    ?     ?  :  x   :  x  ;
    (?x)   0    ?     ?  :  1   :  x  ;
    (?x)   1    ?     ?  :  0   :  x  ;
     x     0    ?     b  :  0   :  0  ;
     x     1    ?     b  :  1   :  1  ;
     x     x    ?     b  :  ?   :  x  ;
     x     ?    ?     b  :  x   :  x  ;
     x     0    ?     b  :  1   :  x  ;
     x     1    ?     b  :  0   :  x  ;
     1     ?    0     1  :  ?   :  0  ;
     1     ?    1     1  :  ?   :  1  ;
     1     ?    x     1  :  ?   :  x  ;
     1     ?   (?0)   1  :  ?   :  0  ;
     1     ?   (?1)   1  :  ?   :  1  ;
     1     ?   (?x)   1  :  ?   :  x  ;
     1     ?    0  (?1)  :  ?   :  0  ;
     1     ?    1  (?1)  :  ?   :  1  ;
     1     ?    x  (?1)  :  ?   :  x  ;
     1     ?    0  (?x)  :  0   :  0  ;
     1     ?    1  (?x)  :  1   :  1  ;
     1     ?    ?  (?x)  :  x   :  x  ;
     1     ?    x  (?x)  :  ?   :  x  ;
     1     ?    0  (?x)  :  1   :  x  ;
     1     ?    1  (?x)  :  0   :  x  ;
     1     ?    0     x  :  0   :  0  ;
     1     ?    1     x  :  1   :  1  ;
     1     ?    x     x  :  ?   :  x  ;
     1     ?    ?     x  :  x   :  x  ;
     1     ?    1     x  :  0   :  x  ;
     1     ?    0     x  :  1   :  x  ;
     x     1    1     x  :  1   :  1  ;
     x     0    0     x  :  0   :  0  ;
     0     ?    ?     *  :  ?   :  -  ;
     ?     ?    ?  (?0)  :  ?   :  -  ;
     1     *    ?     ?  :  ?   :  -  ;
     0     ?    *     ?  :  ?   :  -  ;
     1     ?    *     0  :  ?   :  -  ;
  endtable
endprimitive

//---------------------------------------------------------------------
// primitibe module (UDP_MUX2) state table definition
// FUNCTION : 2-to-1 MULTIPLEXER
//                     SL = 0  --> Q = A
//                     SL = 1  --> Q = B
//----------------------------------------------------------------------
primitive UDP_MUX2 (Q, A, B, SL);
  output Q;
  input A, B, SL;
  table
    //  A   B   SL  :   Q
    0   0   ?   :   0 ;
    1   1   ?   :   1 ;
    0   ?   0   :   0 ;
    1   ?   0   :   1 ;
    ?   0   1   :   0 ;
    ?   1   1   :   1 ;
    x   ?   0   :   x ;
    ?   x   1   :   x ;
    1   0   x   :   x ;
    0   1   x   :   x ;
  endtable
endprimitive

//---------------------------------------------------------------------
// primitibe module (UDP_GBLAT) state table definition
// FUNCTION : POSITIVE EDGE TRIGGERED D LATCH 
//                     Q OUTPUT UDP.
//----------------------------------------------------------------------
primitive UDP_GBLAT (Q, D, G);
  output Q;
  input D, G;
  reg Q;
  table
  //D    G   :  Qn  : Qn+1
    ?    0   :  ?   :  -  ;
    0    1   :  ?   :  0  ;
    1    1   :  ?   :  1  ;
    x    1   :  ?   :  x  ;
    0    x   :  0   :  0  ;
    1    x   :  1   :  1  ;
    *    0   :  ?   :  -  ;
    0  (01)  :  ?   :  0  ;
    1  (01)  :  ?   :  1  ;
    x  (01)  :  ?   :  x  ;
    ?  (?0)  :  ?   :  -  ;
    0  (?x)  :  0   :  0  ;
    1  (?x)  :  1   :  1  ;
  (?1)   1   :  ?   :  1  ;
  (?0)   1   :  ?   :  0  ;
  (?x)   1   :  ?   :  x  ;
  endtable
endprimitive

//---------------------------------------------------------------------
// primitibe module (UDP_BUFF) state table definition
// FUNCTION : BUFF
//----------------------------------------------------------------------
primitive UDP_BUFF (Y, A);
  output Y;
  input  A;

  table
  //A     :  Y
    0  :  0;
    1  :  1;
    x  :  x;
  endtable
endprimitive

//---------------  END OF VERILOG PRIMITIVE SECTION --------------------

/*--------------------------------------------------------------------
NAME : SLE_Prim
TYPE : FF/Latch
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SLE_Prim (output Q,
                 input ADn,
                 input ALn,
                 input CLK,
                 input D,
                 input LAT,
                 input SD,
                 input EN,
                 input SLn);
  
  UDP_MUX2 mux_0(SYNC, SD, D, SLn);
  UDP_MUX2 mux_1(DATA, Q, SYNC, EN);
  
  UDP_DFF  DFF_0(QFF, ALn, ADn_, DATA, CLK);
  UDP_DL   DL_1(QL, ALn, ADn_, DATA, CLK);
  UDP_MUX2 mux_2(Q, QFF, QL, LAT);  
  
  not  U1(ADn_, ADn);
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : GND
TYPE : comb
LOGIC : Y=1'b0
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GND(Y);
  output Y;
  supply0 Y;

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : VCC
TYPE : comb
LOGIC : Y=1'b1
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module VCC(Y);
  output Y;
  supply1 Y;

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : ARI1
TYPE : comb
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module ARI1 (output Y,
             output S,
             output FCO,
             input A,
             input B,
             input C,
             input D,
             input FCI);
  
  parameter [19:0] INIT = 20'h0;
  supply1 VCC_0;
  supply0 GND_0;
  
  UDP_MUX2 mux_0(M0, INIT[0],  INIT[4],  D);
  UDP_MUX2 mux_1(M1, INIT[1],  INIT[5],  D);
  UDP_MUX2 mux_2(M2, INIT[2],  INIT[6],  D);
  UDP_MUX2 mux_3(M3, INIT[3],  INIT[7],  D);
  UDP_MUX2 mux_4(M4, INIT[8],  INIT[12], D);
  UDP_MUX2 mux_5(M5, INIT[9],  INIT[13], D);
  UDP_MUX2 mux_6(M6, INIT[10], INIT[14], D);
  UDP_MUX2 mux_7(M7, INIT[11], INIT[15], D);
  
  UDP_MUX2 mux_8 (M8,  M0,  M2,  C);
  UDP_MUX2 mux_9 (M9,  M1,  M3,  C);
  UDP_MUX2 mux_10(M10, M4,  M6,  C);
  UDP_MUX2 mux_11(M11, M5,  M7,  C);
  
  UDP_MUX2 mux_12(F0, M8,  M9,  B);
  UDP_MUX2 mux_13(F1, M10, M11, B);
  
  UDP_MUX2 mux_14(G0, GND_0, VCC_0, INIT[17]);
  UDP_MUX2 mux_15(G1, F0, F1, INIT[17]);
  UDP_MUX2 mux_16(G, G0, G1, INIT[16]);
  
  UDP_MUX2 mux_17(P0, GND_0, Y, INIT[18]);
  
  UDP_MUX2 mux_18(Y , F0, F1, A);
  or  U0(P, P0, INIT[19]);
  xor U1(S, Y, FCI);
  UDP_MUX2 mux_19(FCO, G, FCI, P);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_B_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_C_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_C_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_A_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_B_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_C_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_C_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_D_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_D_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_FCI_to_S   = (0.01:0.01:0.01);
    specparam tpdHL_FCI_to_S   = (0.01:0.01:0.01);
    specparam tpdLH_A_to_FCO   = (0.01:0.01:0.01);
    specparam tpdHL_A_to_FCO   = (0.01:0.01:0.01);
    specparam tpdLH_B_to_FCO   = (0.01:0.01:0.01);
    specparam tpdHL_B_to_FCO   = (0.01:0.01:0.01);
    specparam tpdLH_C_to_FCO   = (0.01:0.01:0.01);
    specparam tpdHL_C_to_FCO   = (0.01:0.01:0.01);
    specparam tpdLH_D_to_FCO   = (0.01:0.01:0.01);
    specparam tpdHL_D_to_FCO   = (0.01:0.01:0.01);
    specparam tpdLH_FCI_to_FCO = (0.01:0.01:0.01);
    specparam tpdHL_FCI_to_FCO = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
    (B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
    (C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
    (D => Y ) = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
    (A => S )   = ( tpdLH_A_to_S,   tpdHL_A_to_S );
    (B => S )   = ( tpdLH_B_to_S,   tpdHL_B_to_S );
    (C => S )   = ( tpdLH_C_to_S,   tpdHL_C_to_S );
    (D => S )   = ( tpdLH_D_to_S,   tpdHL_D_to_S );
    (FCI => S ) = ( tpdLH_FCI_to_S, tpdHL_FCI_to_S );
    (A => FCO )   = ( tpdLH_A_to_FCO,   tpdHL_A_to_FCO );
    (B => FCO )   = ( tpdLH_B_to_FCO,   tpdHL_B_to_FCO );
    (C => FCO )   = ( tpdLH_C_to_FCO,   tpdHL_C_to_FCO );
    (D => FCO )   = ( tpdLH_D_to_FCO,   tpdHL_D_to_FCO );
    (FCI => FCO ) = ( tpdLH_FCI_to_FCO, tpdHL_FCI_to_FCO );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG4
TYPE : comb
LOGIC: 4-INPUT LUT
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG4 (output Y,
             input A,
             input B,
             input C,
             input D);

  parameter [15:0] INIT = 16'h0;
  parameter LUT_FUNCTION = "";
  
  UDP_MUX2 mux_0(M0, INIT[0], INIT[8], D);
  UDP_MUX2 mux_1(M1, INIT[1], INIT[9], D);
  UDP_MUX2 mux_2(M2, INIT[2], INIT[10], D);
  UDP_MUX2 mux_3(M3, INIT[3], INIT[11], D);
  UDP_MUX2 mux_4(M4, INIT[4], INIT[12], D);
  UDP_MUX2 mux_5(M5, INIT[5], INIT[13], D);
  UDP_MUX2 mux_6(M6, INIT[6], INIT[14], D);
  UDP_MUX2 mux_7(M7, INIT[7], INIT[15], D);
  
  UDP_MUX2 mux_8(M8, M0, M4, C);
  UDP_MUX2 mux_9(M9, M1, M5, C);
  UDP_MUX2 mux_10(M10, M2, M6, C);
  UDP_MUX2 mux_11(M11, M3, M7, C);
  
  UDP_MUX2 mux_12(M12, M8, M10, B);
  UDP_MUX2 mux_13(M13, M9, M11, B);
  
  UDP_MUX2 mux_14(Y , M12, M13, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_B_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_B_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_C_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_C_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
    (B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
    (C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
    (D => Y ) = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG3
TYPE : comb
LOGIC: 3-INPUT LUT
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG3 (output Y,
             input A,
             input B,
             input C);

  parameter [7:0] INIT = 8'h0;
  parameter LUT_FUNCTION = "";
  
  UDP_MUX2 mux_0(M0, INIT[0], INIT[4], C);
  UDP_MUX2 mux_1(M1, INIT[1], INIT[5], C);
  UDP_MUX2 mux_2(M2, INIT[2], INIT[6], C);
  UDP_MUX2 mux_3(M3, INIT[3], INIT[7], C);
  UDP_MUX2 mux_4(M4, M0, M2, B);
  UDP_MUX2 mux_5(M5, M1, M3, B);
  UDP_MUX2 mux_6(Y , M4, M5, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_B_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_B_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_C_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_C_to_Y = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
    (B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
    (C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG2
TYPE : comb
LOGIC: 2-INPUT LUT
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG2 (output Y,
             input A,
             input B);

  parameter [3:0] INIT = 4'h0;
  parameter LUT_FUNCTION = "";
  
  UDP_MUX2 mux_0(M0, INIT[0], INIT[2], B);
  UDP_MUX2 mux_1(M1, INIT[1], INIT[3], B);
  UDP_MUX2 mux_2(Y , M0, M1, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_B_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_B_to_Y = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
    (B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG1
TYPE : comb
LOGIC: 1-INPUT LUT
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG1 (output Y,
             input A);

  parameter [1:0] INIT = 2'h0;
  parameter LUT_FUNCTION = "";
  
  not INV_0(A_, A);  
  and U0 (M0, INIT[0], A_);
  and U1 (M1, INIT[1], A );  
  or  U2 (Y, M0, M1);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG0
TYPE : comb
LOGIC: 0-INPUT LUT
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG0 (output Y);

  parameter INIT = 1'h0;
  parameter LUT_FUNCTION = "";
  
  buf  U0 (Y, INIT);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";

    //pin to pin path delay 
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : INV
TYPE : comb
EQN : Y = !A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module INV(output Y, input A);

  not	U0(Y, A);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : INV_BA
TYPE : comb
EQN : Y = !A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module INV_BA(output Y, input A);

  not	U0(Y, A);

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : INVD
TYPE : comb
EQN : Y = !A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module INVD(output Y, input A);

  not	U0(Y, A);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : BUFF
TYPE : comb
LOGIC : Y = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module BUFF(output Y, input A);
  
  buf	U0(Y, A);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : BUFD
TYPE : comb
LOGIC : Y = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module BUFD(output Y, input A);
  
  buf	U0(Y, A);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NAND3
TYPE : comb
LOGIC : Y = !(A B C)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NAND3(output Y, input A, input B, input C);
	CFG3 #('h7f) U0(.Y(Y), .A(A), .B(B), .C(C));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : MX2
TYPE : comb
LOGIC : Y = (A !S) + (B S)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module MX2(output Y, input A, input B, input S);
	CFG3 #('hca) U0(.Y(Y), .A(A), .B(B), .C(S));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : AND3
TYPE : comb
LOGIC : Y = A B C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module AND3(output Y, input A, input B, input C);
	CFG3 #('h80) U0(.Y(Y), .A(A), .B(B), .C(C));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : OR2
TYPE : comb
LOGIC : Y = A + B
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module OR2(output Y, input A, input B);
	CFG2 #('he) U0(.Y(Y), .A(A), .B(B));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : XOR2
TYPE : comb
LOGIC : Y = A ^ B
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module XOR2(output Y, input A, input B);
	CFG2 #('h6) U0(.Y(Y), .A(A), .B(B));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NOR2
TYPE : comb
LOGIC : Y = !(A + B)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NOR2(output Y, input A, input B);
	CFG2 #('h1) U0(.Y(Y), .A(A), .B(B));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : AND2
TYPE : comb
LOGIC : Y = A B
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module AND2(output Y, input A, input B);
	CFG2 #('h8) U0(.Y(Y), .A(A), .B(B));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : OR3
TYPE : comb
LOGIC : Y = A + B + C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module OR3(output Y, input A, input B, input C);
	CFG3 #('hfe) U0(.Y(Y), .A(A), .B(B), .C(C));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : XOR3
TYPE : comb
LOGIC : Y = A ^ B ^ C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module XOR3(output Y, input A, input B, input C);
	CFG3 #('h96) U0(.Y(Y), .A(A), .B(B), .C(C));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NOR3
TYPE : comb
LOGIC : Y = !(A + B + C)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NOR3(output Y, input A, input B, input C);
	CFG3 #('h01) U0(.Y(Y), .A(A), .B(B), .C(C));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NAND2
TYPE : comb
LOGIC : Y = !(A B)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NAND2(output Y, input A, input B);
	CFG2 #('h7) U0(.Y(Y), .A(A), .B(B));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : AND4
TYPE : comb
LOGIC : Y = A B C D
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module AND4(output Y, input A, input B, input C, input D);
	CFG4 #('h8000) U0(.Y(Y), .A(A), .B(B), .C(C), .D(D));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NAND4
TYPE : comb
LOGIC : Y = !(A B C D)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NAND4(output Y, input A, input B, input C, input D);
	CFG4 #('h7fff) U0(.Y(Y), .A(A), .B(B), .C(C), .D(D));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : OR4
TYPE : comb
LOGIC : Y = A + B + C + D
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module OR4(output Y, input A, input B, input C, input D);
	CFG4 #('hfffe) U0(.Y(Y), .A(A), .B(B), .C(C), .D(D));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : NOR4
TYPE : comb
LOGIC : Y = !(A + B + C + D)
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module NOR4(output Y, input A, input B, input C, input D);
	CFG4 #('h0001) U0(.Y(Y), .A(A), .B(B), .C(C), .D(D));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : XOR4
TYPE : comb
LOGIC : Y = A ^ B ^ C ^ D
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module XOR4(output Y, input A, input B, input C, input D);
	CFG4 #('h6996) U0(.Y(Y), .A(A), .B(B), .C(C), .D(D));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : XOR8
TYPE : comb
LOGIC : Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module XOR8(output Y, input A, input B, input C, input D, input E, input F, input G, input H);
	ARI1 #('h46996) U0(.Y(), .S(), .FCO(co), .A(A), .B(B), .C(C), .D(D), .FCI(1'b1));
  ARI1 #('h06996) U1(.Y(), .S(Y), .FCO(), .A(E), .B(F), .C(G), .D(H), .FCI(co));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : MX4
TYPE : comb
LOGIC : Y = !S0 !S1 D0 + S0 !S1 D1 + !S0 S1 D2 + S0 S1 D3
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module MX4(output Y, input D0, input D1, input D2, input D3, input S0, input S1);
	CFG4 #('hF0CA) U0(.Y(Y0), .A(D0), .B(D1), .C(S0), .D(S1));
  CFG4 #('hE4AA) U1(.Y(Y), .A(Y0), .B(D2), .C(D3), .D(S1));
	specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "comb";
	endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : ARI1_CC
TYPE : comb
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module ARI1_CC (output Y,
                output S,
                output P,
                output UB,
                output FCO,
                input FCI,
                input A,
                input B,
                input C,
                input D,
                input CC);
  
  parameter [19:0] INIT = 20'h0;
  supply1 VCC_0;
  supply0 GND_0;
  
  UDP_MUX2 mux_0(M0, INIT[0],  INIT[4],  D);
  UDP_MUX2 mux_1(M1, INIT[1],  INIT[5],  D);
  UDP_MUX2 mux_2(M2, INIT[2],  INIT[6],  D);
  UDP_MUX2 mux_3(M3, INIT[3],  INIT[7],  D);
  UDP_MUX2 mux_4(M4, INIT[8],  INIT[12], D);
  UDP_MUX2 mux_5(M5, INIT[9],  INIT[13], D);
  UDP_MUX2 mux_6(M6, INIT[10], INIT[14], D);
  UDP_MUX2 mux_7(M7, INIT[11], INIT[15], D);
  
  UDP_MUX2 mux_8 (M8,  M0,  M2,  C);
  UDP_MUX2 mux_9 (M9,  M1,  M3,  C);
  UDP_MUX2 mux_10(M10, M4,  M6,  C);
  UDP_MUX2 mux_11(M11, M5,  M7,  C);
  
  UDP_MUX2 mux_12(F0, M8,  M9,  B);
  UDP_MUX2 mux_13(F1, M10, M11, B);
  
  UDP_MUX2 mux_14(G0, GND_0, VCC_0, INIT[17]);
  UDP_MUX2 mux_15(G1, F0, F1, INIT[17]);
  UDP_MUX2 mux_16(G, G0, G1, INIT[16]);
  
  UDP_MUX2 mux_17(P0, GND_0, Y, INIT[18]);
  
  UDP_MUX2 mux_18(Y , F0, F1, A);
  or  U0(P, P0, INIT[19]);
  xor U1(S, Y, CC);
  not U2(UB, G);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_B_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_C_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_C_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y     = (0.01:0.01:0.01);
    specparam tpdLH_A_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_B_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_C_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_C_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_D_to_S     = (0.01:0.01:0.01);
    specparam tpdHL_D_to_S     = (0.01:0.01:0.01);
    specparam tpdLH_CC_to_S    = (0.01:0.01:0.01);
    specparam tpdHL_CC_to_S    = (0.01:0.01:0.01);
    specparam tpdLH_A_to_P     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_P     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_P     = (0.01:0.01:0.01);
    specparam tpdHL_B_to_P     = (0.01:0.01:0.01);
    specparam tpdLH_C_to_P     = (0.01:0.01:0.01);
    specparam tpdHL_C_to_P     = (0.01:0.01:0.01);
    specparam tpdLH_D_to_P     = (0.01:0.01:0.01);
    specparam tpdHL_D_to_P     = (0.01:0.01:0.01);
    specparam tpdLH_B_to_UB    = (0.01:0.01:0.01);
    specparam tpdHL_B_to_UB    = (0.01:0.01:0.01);
    specparam tpdLH_C_to_UB    = (0.01:0.01:0.01);
    specparam tpdHL_C_to_UB    = (0.01:0.01:0.01);
    specparam tpdLH_D_to_UB    = (0.01:0.01:0.01);
    specparam tpdHL_D_to_UB    = (0.01:0.01:0.01);
    specparam MacroType = "comb";

    //pin to pin path delay 
    (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
    (B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
    (C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
    (D => Y ) = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
    (A => S )   = ( tpdLH_A_to_S,   tpdHL_A_to_S );
    (B => S )   = ( tpdLH_B_to_S,   tpdHL_B_to_S );
    (C => S )   = ( tpdLH_C_to_S,   tpdHL_C_to_S );
    (D => S )   = ( tpdLH_D_to_S,   tpdHL_D_to_S );
    (CC => S )  = ( tpdLH_CC_to_S, tpdHL_CC_to_S );
    (A => P )   = ( tpdLH_A_to_P,   tpdHL_A_to_P );
    (B => P )   = ( tpdLH_B_to_P,   tpdHL_B_to_P );
    (C => P )   = ( tpdLH_C_to_P,   tpdHL_C_to_P );
    (D => P )   = ( tpdLH_D_to_P,   tpdHL_D_to_P );
    (B => UB )   = ( tpdLH_B_to_UB,   tpdHL_B_to_UB );
    (C => UB )   = ( tpdLH_C_to_UB,   tpdHL_C_to_UB );
    (D => UB )   = ( tpdLH_D_to_UB,   tpdHL_D_to_UB );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : FCINIT_BUFF
 CELL TYPE : comb
 CELL LOGIC : FCO = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module FCINIT_BUFF (output FCO,
                    input A);

  buf  U0 (FCO, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_FCO = (0.01:0.01:0.01);
		specparam tpdHL_A_to_FCO = (0.01:0.01:0.01);

    //pin to pin path delay 
    (A => FCO ) = ( tpdLH_A_to_FCO, tpdHL_A_to_FCO );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : FCEND_BUFF
 CELL TYPE : comb
 CELL LOGIC : CO = FCI
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module FCEND_BUFF (output CO,
                   input FCI);

  buf  U0 (CO, FCI);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_FCI_to_CO = (0.01:0.01:0.01);
		specparam tpdHL_FCI_to_CO = (0.01:0.01:0.01);

    //pin to pin path delay 
    (FCI => CO ) = ( tpdLH_FCI_to_CO, tpdHL_FCI_to_CO );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : FCINIT_BUFF_CC
 CELL TYPE : comb
 CELL LOGIC : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module FCINIT_BUFF_CC (output P,
                       output UB,
                       output FCO,
                       input A,
                       input CC);
  
  wire S, Y, FCI;
  
  ARI1_CC #('h1AAAA) U0 (.A(1'b0), .C(1'b0), .D(1'b0), .CC(1'b0), .B(A), .UB(UB), .P(P), .S(S), .Y(Y), .FCI(FCI), .FCO(FCO));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_A_to_P  = (0.01:0.01:0.01);
		specparam tpdHL_A_to_P  = (0.01:0.01:0.01);
    specparam tpdLH_A_to_UB = (0.01:0.01:0.01);
		specparam tpdHL_A_to_UB = (0.01:0.01:0.01);

    //pin to pin path delay 
    (A => P ) = ( tpdLH_A_to_P, tpdHL_A_to_P );
    (A => UB ) = ( tpdLH_A_to_UB, tpdHL_A_to_UB );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : FCEND_BUFF_CC
 CELL TYPE : comb
 CELL LOGIC : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module FCEND_BUFF_CC (output CO,
                      output P,
                      output UB,
                      input FCI,
                      input CC);
  wire Y;
  
  ARI1_CC #('h00000) U0 (.A(1'b0), .B(1'b0), .C(1'b0), .D(1'b0), .CC(CC), .UB(UB), .P(P), .S(CO), .Y(Y), .FCI(FCI), .FCO(FCO));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH_CC_to_CO  = (0.01:0.01:0.01);
		specparam tpdHL_CC_to_CO  = (0.01:0.01:0.01);

    //pin to pin path delay 
    (CC => CO ) = ( tpdLH_CC_to_CO, tpdHL_CC_to_CO );
  endspecify   
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : CC_CONFIG
 CELL TYPE : comb
 CELL LOGIC : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CC_CONFIG (output CO,
                  output [11:0] CC,
                  input CI,
                  input [11:0] P,
                  input [11:0] UB);

  wire [11:0] CC_int;
  wire [11:0] P_int;
  wire [11:0] UB_int;
  assign CC[0] = CC_int[11];
  assign CC[1] = CC_int[10];
  assign CC[2] = CC_int[9];
  assign CC[3] = CC_int[8];
  assign CC[4] = CC_int[7];
  assign CC[5] = CC_int[6];
  assign CC[6] = CC_int[5];
  assign CC[7] = CC_int[4];
  assign CC[8] = CC_int[3];
  assign CC[9] = CC_int[2];
  assign CC[10] = CC_int[1];
  assign CC[11] = CC_int[0];
  assign P_int[0] = P[11];
  assign P_int[1] = P[10];
  assign P_int[2] = P[9];
  assign P_int[3] = P[8];
  assign P_int[4] = P[7];
  assign P_int[5] = P[6];
  assign P_int[6] = P[5];
  assign P_int[7] = P[4];
  assign P_int[8] = P[3];
  assign P_int[9] = P[2];
  assign P_int[10] = P[1];
  assign P_int[11] = P[0];
  assign UB_int[0] = UB[11];
  assign UB_int[1] = UB[10];
  assign UB_int[2] = UB[9];
  assign UB_int[3] = UB[8];
  assign UB_int[4] = UB[7];
  assign UB_int[5] = UB[6];
  assign UB_int[6] = UB[5];
  assign UB_int[7] = UB[4];
  assign UB_int[8] = UB[3];
  assign UB_int[9] = UB[2];
  assign UB_int[10] = UB[1];
  assign UB_int[11] = UB[0];
  CC_CONFIG_2 u0(.CO(CO), .CC(CC_int), .CI(CI), .P(P_int), .UB(UB_int));
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "comb";
    specparam tpdLH  = (0.01:0.01:0.01);
		specparam tpdHL  = (0.01:0.01:0.01);
    
    (CI => CC[0] ) = ( tpdLH, tpdHL );
    (CI => CC[1] ) = ( tpdLH, tpdHL );
    (CI => CC[2] ) = ( tpdLH, tpdHL );
    (CI => CC[3] ) = ( tpdLH, tpdHL );
    (CI => CC[4] ) = ( tpdLH, tpdHL );
    (CI => CC[5] ) = ( tpdLH, tpdHL );
    (CI => CC[6] ) = ( tpdLH, tpdHL );
    (CI => CC[7] ) = ( tpdLH, tpdHL );
    (CI => CC[8] ) = ( tpdLH, tpdHL );
    (CI => CC[9] ) = ( tpdLH, tpdHL );
    (CI => CC[10] ) = ( tpdLH, tpdHL );
    (CI => CC[11] ) = ( tpdLH, tpdHL );
    (CI => CO ) = ( tpdLH, tpdHL );
    (P[0] => CC[1] ) = ( tpdLH, tpdHL );
    (P[0] => CC[2] ) = ( tpdLH, tpdHL );
    (P[0] => CC[3] ) = ( tpdLH, tpdHL );
    (P[0] => CC[4] ) = ( tpdLH, tpdHL );
    (P[0] => CC[5] ) = ( tpdLH, tpdHL );
    (P[0] => CC[6] ) = ( tpdLH, tpdHL );
    (P[0] => CC[7] ) = ( tpdLH, tpdHL );
    (P[0] => CC[8] ) = ( tpdLH, tpdHL );
    (P[0] => CC[9] ) = ( tpdLH, tpdHL );
    (P[0] => CC[10] ) = ( tpdLH, tpdHL );
    (P[0] => CC[11] ) = ( tpdLH, tpdHL );
    (P[0] => CO ) = ( tpdLH, tpdHL );
    (P[1] => CC[2] ) = ( tpdLH, tpdHL );
    (P[1] => CC[3] ) = ( tpdLH, tpdHL );
    (P[1] => CC[4] ) = ( tpdLH, tpdHL );
    (P[1] => CC[5] ) = ( tpdLH, tpdHL );
    (P[1] => CC[6] ) = ( tpdLH, tpdHL );
    (P[1] => CC[7] ) = ( tpdLH, tpdHL );
    (P[1] => CC[8] ) = ( tpdLH, tpdHL );
    (P[1] => CC[9] ) = ( tpdLH, tpdHL );
    (P[1] => CC[10] ) = ( tpdLH, tpdHL );
    (P[1] => CC[11] ) = ( tpdLH, tpdHL );
    (P[1] => CO ) = ( tpdLH, tpdHL );    
    (P[2] => CC[3] ) = ( tpdLH, tpdHL );
    (P[2] => CC[4] ) = ( tpdLH, tpdHL );
    (P[2] => CC[5] ) = ( tpdLH, tpdHL );
    (P[2] => CC[6] ) = ( tpdLH, tpdHL );
    (P[2] => CC[7] ) = ( tpdLH, tpdHL );
    (P[2] => CC[8] ) = ( tpdLH, tpdHL );
    (P[2] => CC[9] ) = ( tpdLH, tpdHL );
    (P[2] => CC[10] ) = ( tpdLH, tpdHL );
    (P[2] => CC[11] ) = ( tpdLH, tpdHL );
    (P[2] => CO ) = ( tpdLH, tpdHL );    
    (P[3] => CC[4] ) = ( tpdLH, tpdHL );
    (P[3] => CC[5] ) = ( tpdLH, tpdHL );
    (P[3] => CC[6] ) = ( tpdLH, tpdHL );
    (P[3] => CC[7] ) = ( tpdLH, tpdHL );
    (P[3] => CC[8] ) = ( tpdLH, tpdHL );
    (P[3] => CC[9] ) = ( tpdLH, tpdHL );
    (P[3] => CC[10] ) = ( tpdLH, tpdHL );
    (P[3] => CC[11] ) = ( tpdLH, tpdHL );
    (P[3] => CO ) = ( tpdLH, tpdHL );    
    (P[4] => CC[5] ) = ( tpdLH, tpdHL );
    (P[4] => CC[6] ) = ( tpdLH, tpdHL );
    (P[4] => CC[7] ) = ( tpdLH, tpdHL );
    (P[4] => CC[8] ) = ( tpdLH, tpdHL );
    (P[4] => CC[9] ) = ( tpdLH, tpdHL );
    (P[4] => CC[10] ) = ( tpdLH, tpdHL );
    (P[4] => CC[11] ) = ( tpdLH, tpdHL );
    (P[4] => CO ) = ( tpdLH, tpdHL );    
    (P[5] => CC[6] ) = ( tpdLH, tpdHL );
    (P[5] => CC[7] ) = ( tpdLH, tpdHL );
    (P[5] => CC[8] ) = ( tpdLH, tpdHL );
    (P[5] => CC[9] ) = ( tpdLH, tpdHL );
    (P[5] => CC[10] ) = ( tpdLH, tpdHL );
    (P[5] => CC[11] ) = ( tpdLH, tpdHL );
    (P[5] => CO ) = ( tpdLH, tpdHL );    
    (P[6] => CC[7] ) = ( tpdLH, tpdHL );
    (P[6] => CC[8] ) = ( tpdLH, tpdHL );
    (P[6] => CC[9] ) = ( tpdLH, tpdHL );
    (P[6] => CC[10] ) = ( tpdLH, tpdHL );
    (P[6] => CC[11] ) = ( tpdLH, tpdHL );
    (P[6] => CO ) = ( tpdLH, tpdHL );    
    (P[7] => CC[8] ) = ( tpdLH, tpdHL );
    (P[7] => CC[9] ) = ( tpdLH, tpdHL );
    (P[7] => CC[10] ) = ( tpdLH, tpdHL );
    (P[7] => CC[11] ) = ( tpdLH, tpdHL );
    (P[7] => CO ) = ( tpdLH, tpdHL );    
    (P[8] => CC[9] ) = ( tpdLH, tpdHL );
    (P[8] => CC[10] ) = ( tpdLH, tpdHL );
    (P[8] => CC[11] ) = ( tpdLH, tpdHL );
    (P[8] => CO ) = ( tpdLH, tpdHL );    
    (P[9] => CC[10] ) = ( tpdLH, tpdHL );
    (P[9] => CC[11] ) = ( tpdLH, tpdHL );
    (P[9] => CO ) = ( tpdLH, tpdHL );
    (P[10] => CC[11] ) = ( tpdLH, tpdHL );
    (P[10] => CO ) = ( tpdLH, tpdHL );
    (P[11] => CO ) = ( tpdLH, tpdHL );
    
    (UB[0] => CC[1] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[2] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[3] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[4] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[5] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[0] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[0] => CO ) = ( tpdLH, tpdHL );
    (UB[1] => CC[2] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[3] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[4] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[5] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[1] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[1] => CO ) = ( tpdLH, tpdHL );    
    (UB[2] => CC[3] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[4] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[5] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[2] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[2] => CO ) = ( tpdLH, tpdHL );    
    (UB[3] => CC[4] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[5] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[3] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[3] => CO ) = ( tpdLH, tpdHL );    
    (UB[4] => CC[5] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[4] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[4] => CO ) = ( tpdLH, tpdHL );    
    (UB[5] => CC[6] ) = ( tpdLH, tpdHL );
    (UB[5] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[5] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[5] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[5] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[5] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[5] => CO ) = ( tpdLH, tpdHL );    
    (UB[6] => CC[7] ) = ( tpdLH, tpdHL );
    (UB[6] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[6] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[6] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[6] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[6] => CO ) = ( tpdLH, tpdHL );    
    (UB[7] => CC[8] ) = ( tpdLH, tpdHL );
    (UB[7] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[7] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[7] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[7] => CO ) = ( tpdLH, tpdHL );    
    (UB[8] => CC[9] ) = ( tpdLH, tpdHL );
    (UB[8] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[8] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[8] => CO ) = ( tpdLH, tpdHL );    
    (UB[9] => CC[10] ) = ( tpdLH, tpdHL );
    (UB[9] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[9] => CO ) = ( tpdLH, tpdHL );
    (UB[10] => CC[11] ) = ( tpdLH, tpdHL );
    (UB[10] => CO ) = ( tpdLH, tpdHL );
    (UB[11] => CO ) = ( tpdLH, tpdHL );
  endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


`timescale 1 ns / 10 ps
module CC_CONFIG_2 (output CO,
                  output [11:0] CC,
                  input CI,
                  input [11:0] P,
                  input [11:0] UB);

  not U0(CI_, CI);
  UDP_MUX2 U1(CC1_, UB[0], CI_, P[0]);
  UDP_MUX2 U2(CC2_, UB[1], CC1_, P[1]);
  UDP_MUX2 U3(CC21, UB[1], UB[0], P[1]);
  UDP_MUX2 U4(CC22, UB[2], CC21, P[2]);
  not U5(CC22_, CC22);
  and U6(P2, P[0], P[1], P[2]);
  UDP_MUX2 U7(CC[3], CC22_, CI, P2);
  
  not U8(CC3_, CC[3]);
  UDP_MUX2 U9(CC4_, UB[3], CC3_, P[3]);
  UDP_MUX2 U10(CC5_, UB[4], CC4_, P[4]);  
  UDP_MUX2 U11(CC51, UB[4], UB[3], P[4]);
  UDP_MUX2 U12(CC52, UB[5], CC51, P[5]);
  not U13(CC52_, CC52);
  and U14(P5, P[3], P[4], P[5]);
  UDP_MUX2 U15(CC[6], CC52_, CC[3], P5);
  
  not U16(UB6_, UB[6]);
  not U17(UB7_, UB[7]);
  not U18(UB8_, UB[8]);
  UDP_MUX2 U19(CC[7], UB6_, CC[6], P[6]);
  UDP_MUX2 U20(CC[8], UB7_, CC[7], P[7]);
  UDP_MUX2 U21(CC81, UB7_, UB6_, P[7]);
  UDP_MUX2 U22(CC82, UB8_, CC81, P[8]);
  not U23(CC82_, CC82);
  and U24(P8, P[6], P[7], P[8]);
  UDP_MUX2 U25(CC9_, CC82_, CC6_, P8);
  
  not U26(UB9_, UB[9]);
  not U27(UB10_, UB[10]);
  not U28(UB11_, UB[11]);
  UDP_MUX2 U29(CC[10], UB9_, CC[9], P[9]);
  UDP_MUX2 U30(CC[11], UB10_, CC[10], P[10]);
  UDP_MUX2 U31(CC111, UB10_, UB9_, P[10]);
  UDP_MUX2 U32(CC112, UB11_, CC111, P[11]);
  not U33(CC112_, CC112);
  and U34(P11, P[9], P[10], P[11]);
  UDP_MUX2 U35(CO_, CC112_, CC9_, P11);
  
  
  assign CC[0] = CI;
  not U36(CC[1], CC1_);
  not U37(CC[2], CC2_);
  not U38(CC[4], CC4_);
  not U39(CC[5], CC5_);
  not U40(CC6_, CC[6]);
  not U41(CC[9], CC9_);
  not U42(CO, CO_);
endmodule


/*==============  Sequential Elements ==============*/

/*--------------------------------------------------------------------
NAME : SLE
TYPE : FF/Latch
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SLE (output Q,
            input ADn,
            input ALn,
            input CLK,
            input D,
            input LAT,
            input SD,
            input EN,
            input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim DF_0 (.Q(Q), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam   tSetup          = (0.0);
    specparam   tHold           = (0.0);
    specparam   tWidth          = (0.0);
    specparam   tpdLH_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )  
      (posedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q
    
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (posedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2Q Transperant Mode
      (D => Q)  = (tpdLH_D_to_Q, tpdHL_D_to_Q);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2Q
      (posedge SLn => (Q +: D))   = (tpdLH_SL_to_Q, tpdHL_SL_to_Q);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2Q
      (posedge ALn => (Q +: D))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2Q
      (posedge ALn => (Q +: SD))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2Q
      (negedge SLn => (Q +: SD))  = (tpdLH_SLn_to_Q, tpdHL_SLn_to_Q);  
    if ( LAT && !EN )                                                // Activating ALn ALn2Q
      (negedge ALn => (Q +: ADn)) = (tpdLH_ALn_to_Q, tpdHL_ALn_to_Q);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge D, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge D, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge D, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1E1C0 (output Q, input  D, input  CLK, input  E, input  CLR);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(VCC_0), .ALn(CLR), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(E), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1P0 (output Q, input  D, input  CLK, input  PRE);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(PRE), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(VCC_0), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1E1 (output Q, input  D, input  CLK, input  E);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(VCC_0), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(E), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1E1P0 (output Q, input  D, input  CLK, input  E, input  PRE);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(PRE), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(E), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1 (output Q, input  D, input  CLK);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(VCC_0), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(VCC_0), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DFN1C0 (output Q, input  D, input  CLK, input  CLR);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(VCC_0), .ALn(CLR), .CLK(CLK), 
          .D(D), .LAT(GND_0), .SD(GND_0), .EN(VCC_0), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DLN1 (output Q, input  D, input  G);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(VCC_0), .CLK(G), 
          .D(D), .LAT(VCC_0), .SD(GND_0), .EN(VCC_0), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DLN1C0 (output Q, input  D, input  G, input  CLR);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(VCC_0), .ALn(CLR), .CLK(G), 
          .D(D), .LAT(VCC_0), .SD(GND_0), .EN(CLR), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults

`suppress_faults 
`enable_portfaults 
`celldefine 
`delay_mode_path 
`timescale 1 ns / 10 ps
module DLN1P0 (output Q, input  D, input  G, input  PRE);
	reg NOTIFY_REG;
	supply1 VCC_0;
	supply0 GND_0;

	SLE DFF_0(.Q(Q), .ADn(GND_0), .ALn(PRE), .CLK(G), 
          .D(D), .LAT(VCC_0), .SD(GND_0), .EN(PRE), .SLn(VCC_0)); 
endmodule 
`endcelldefine 
`disable_portfaults 
`nosuppress_faults
/*--------------------------------------------------------------------
NAME : CFG1_IP_B
TYPE : shadowcomb
LOGIC: IPB = B
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG1_IP_B (output IPB,
                  input B);

  buf U0(IPB, B);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdHL_B_to_IPB = (0.01:0.01:0.01);
    specparam MacroType = "shadowcomb";

    //pin to pin path delay
    (B => IPB ) = ( tpdLH_B_to_IPB, tpdHL_B_to_IPB );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG1_IP_C
TYPE : shadowcomb
LOGIC: IPC = C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG1_IP_C (output IPC,
                  input C);

  buf U0(IPC, C);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_C_to_IPC = (0.01:0.01:0.01);
    specparam tpdHL_C_to_IPC = (0.01:0.01:0.01);
    specparam MacroType = "shadowcomb";

    //pin to pin path delay
    (C => IPC ) = ( tpdLH_C_to_IPC, tpdHL_C_to_IPC );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG2_IP_BC
TYPE : shadowcomb
LOGIC: IPB = B; IPC = C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG2_IP_BC (output IPB,
                   output IPC,
                   input  B,
                   input  C);

  buf U0(IPB, B);
  buf U1(IPC, C);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdHL_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdLH_C_to_IPC = (0.01:0.01:0.01);
    specparam tpdHL_C_to_IPC = (0.01:0.01:0.01);
    specparam MacroType = "shadowcomb";

    //pin to pin path delay
    (B => IPB ) = ( tpdLH_B_to_IPB, tpdHL_B_to_IPB );
    (C => IPC ) = ( tpdLH_C_to_IPC, tpdHL_C_to_IPC );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CFG3_IP_BCD
TYPE : shadowcomb
LOGIC: IPB = B; IPC = C; IPD = D
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CFG3_IP_BCD (output IPB,
                    output IPC,
                    output IPD,
                    input  B,
                    input  C,
                    input  D);

  buf U0(IPB, B);
  buf U1(IPC, C);
  buf U2(IPD, D);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdHL_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdLH_C_to_IPC = (0.01:0.01:0.01);
    specparam tpdHL_C_to_IPC = (0.01:0.01:0.01);
    specparam tpdLH_D_to_IPD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_IPD = (0.01:0.01:0.01);
    specparam MacroType = "shadowcomb";

    //pin to pin path delay
    (B => IPB ) = ( tpdLH_B_to_IPB, tpdHL_B_to_IPB );
    (C => IPC ) = ( tpdLH_C_to_IPC, tpdHL_C_to_IPC );
    (D => IPD ) = ( tpdLH_D_to_IPD, tpdHL_D_to_IPD );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : SLE_IP_CLK
TYPE : shadowcomb
LOGIC: IPCLKn =~ CLK
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SLE_IP_CLK (output IPCLKn,
                   input CLK);

  not U0(IPCLKn, CLK);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_CLK_to_IPCLKn = (0.01:0.01:0.01);
    specparam tpdHL_CLK_to_IPCLKn = (0.01:0.01:0.01);
    specparam MacroType = "shadowseq";

    //pin to pin path delay
    (CLK => IPCLKn ) = ( tpdLH_CLK_to_IPCLKn, tpdHL_CLK_to_IPCLKn );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : SLE_IP_EN
TYPE : shadowcomb
LOGIC: IPCLKn =~ CLK
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SLE_IP_EN (output IPENn,
                  input EN);

  not U0(IPENn, EN);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_EN_to_IPENn = (0.01:0.01:0.01);
    specparam tpdHL_EN_to_IPENn = (0.01:0.01:0.01);
    specparam MacroType = "shadowseq";

    //pin to pin path delay
    (EN => IPENn ) = ( tpdLH_EN_to_IPENn, tpdHL_EN_to_IPENn );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : SLE_IP_CLKEN
TYPE : shadowcomb
LOGIC: IPCLKn =~ CLK
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SLE_IP_CLKEN (output IPCLKn,
                     output IPENn,
                     input  CLK,
                     input  EN);

  not U0(IPCLKn, CLK);
  not U1(IPENn, EN);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_CLK_to_IPCLKn = (0.01:0.01:0.01);
    specparam tpdHL_CLK_to_IPCLKn = (0.01:0.01:0.01);
    specparam tpdLH_EN_to_IPENn = (0.01:0.01:0.01);
    specparam tpdHL_EN_to_IPENn = (0.01:0.01:0.01);
    specparam MacroType = "shadowseq";

    //pin to pin path delay
    (CLK => IPCLKn ) = ( tpdLH_CLK_to_IPCLKn, tpdHL_CLK_to_IPCLKn );
    (EN => IPENn )   = ( tpdLH_EN_to_IPENn, tpdHL_EN_to_IPENn );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

 /*--------------------------------------------------------------------
NAME : IP_INTERFACE
TYPE : ip_interface
LOGIC: IPA = A; IPB = B; IPC = C
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IP_INTERFACE (output IPA,
                     output IPB,
                     output IPC,
                     input A,
                     input B,
                     input C);

  buf U0(IPA, A);
  buf U1(IPB, B);
  buf U2(IPC, C);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_IPA = (0.01:0.01:0.01);
    specparam tpdHL_A_to_IPA = (0.01:0.01:0.01);
    specparam tpdLH_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdHL_B_to_IPB = (0.01:0.01:0.01);
    specparam tpdLH_C_to_IPC = (0.01:0.01:0.01);
    specparam tpdHL_C_to_IPC = (0.01:0.01:0.01);
    specparam MacroType = "ip_interface";

    //pin to pin path delay
    (A => IPA ) = ( tpdLH_A_to_IPA, tpdHL_A_to_IPA );
    (B => IPB ) = ( tpdLH_B_to_IPB, tpdHL_B_to_IPB );
    (C => IPC ) = ( tpdLH_C_to_IPC, tpdHL_C_to_IPC );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_IN(Y,PAD);
  input PAD;
  output Y;

  reg   NOTIFY_REG;
  buf BUF_U_00(Y,PAD);

  specify
		specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
		specparam PATHPULSE$     = (0.01, 0.01);
    specparam MacroType = "io";
		
    //pin to pin path delay 
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
   endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_TRI(PAD,D,E);
  input D,E;
  output PAD;

  reg NOTIFY_REG;
  bufif1   U1210(PAD, D, E);

  specify
		specparam tpdLH_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdHL_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
		specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
		specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    specparam PATHPULSE$     = (0.01, 0.01);
		specparam MacroType = "io";

		//pin to pin path delay 
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);
    (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_BI(Y,D,E,PAD);
  input D,E;
  output Y;
  inout PAD;

  reg NOTIFY_REG;
  bufif1   U1213(PAD, D, E);
  buf	BUF_U_01(Y,PAD);

  specify
    specparam MacroType = "iopad";
    specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdLH_E_to_Y   = (0.01:0.01:0.01);
    specparam tpdHL_E_to_Y   = (0.01:0.01:0.01);
    specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
    specparam PATHPULSE$     = (0.01, 0.01);
    
    //pin to pin path delay 
    (E => PAD ) = ( tpdLH_E_to_PAD, tpdHL_E_to_PAD, tpdLZ_E_to_PAD, tpdZH_E_to_PAD, tpdHZ_E_to_PAD, tpdZL_E_to_PAD );
    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
    (D => Y )   = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
    (E => Y )   = ( tpdLH_E_to_Y, tpdHL_E_to_Y );
    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    //Controls Pulse Width
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_DELAY
TYPE : iopad
EQN  : IOUT_P = IOUT_IN
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_DELAY (input IOUT_IN,
                    output IOUT_P);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, IOUT_IN);
  buf	U1(IOUT_P,IOUT_IN);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$            = (0.01, 0.01);
    specparam tpdLH_IOUTIN_to_IOUTP = (0.01:0.01:0.01);
    specparam tpdHL_IOUTIN_to_IOUTP = (0.01:0.01:0.01);

    //pin to pin path delay 
    (IOUT_IN => IOUT_P) = ( tpdLH_IOUTIN_to_IOUTP, tpdHL_IOUTIN_to_IOUTP );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_VDD
TYPE : iopad
EQN  : IOUT_IN = IOUT_VDD
          : OIN_VDD = OIN_P @ ( EIN_P == 1'b1 )
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_VDD(input OIN_P,
                  input EIN_P,
                  input IOUT_VDD,
                  output OIN_VDD,
                  output EIN_VDD,
                  output IOUT_IN);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, IOUT_IN);
  buf	U1(IOUT_IN, IOUT_VDD);
  bufif1 U2(OIN_VDD, OIN_P, EIN_P);
  buf	U3(EIN_VDD, EIN_P);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$              = (0.01, 0.01);
    specparam tpdLH_IOUTVDD_to_IOUTIN = (0.01:0.01:0.01);
    specparam tpdHL_IOUTVDD_to_IOUTIN = (0.01:0.01:0.01);
    specparam tpdLH_EINP_to_EINVDD    = (0.01:0.01:0.01);
    specparam tpdHL_EINP_to_EINVDD    = (0.01:0.01:0.01);
    specparam tpdLH_EINP_to_OINVDD    = (0.0:0.0:0.0);
		specparam tpdHL_EINP_to_OINVDD    = (0.0:0.0:0.0);
		specparam tpdLZ_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdZL_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdHZ_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdZH_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdLH_OINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdHL_OINP_to_OINVDD    = (0.01:0.01:0.01);

    //pin to pin path delay 
    (IOUT_VDD => IOUT_IN) = ( tpdLH_IOUTVDD_to_IOUTIN, tpdHL_IOUTVDD_to_IOUTIN );
    (EIN_P => OIN_VDD )   = ( tpdLH_EINP_to_OINVDD,tpdHL_EINP_to_OINVDD,tpdLZ_EINP_to_OINVDD,tpdZH_EINP_to_OINVDD,tpdHZ_EINP_to_OINVDD,tpdZL_EINP_to_OINVDD);
    (OIN_P => OIN_VDD )   = ( tpdLH_OINP_to_OINVDD,tpdHL_OINP_to_OINVDD);
    (EIN_P => EIN_VDD )   = ( tpdLH_EINP_to_EINVDD,tpdHL_EINP_to_EINVDD);
    
    $width(negedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_IN_VDDI
TYPE : iopad
EQN  : IOUT_VDD = PAD_P
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_IN_VDDI (input PAD_P,
                      output IOUT_VDD);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, PAD_P);
  buf	U1(IOUT_VDD,PAD_P);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$            = (0.01, 0.01);
    specparam tpdLH_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdHL_PADP_to_IOUTVDD = (0.01:0.01:0.01);

    //pin to pin path delay 
    (PAD_P => IOUT_VDD) = ( tpdLH_PADP_to_IOUTVDD, tpdHL_PADP_to_IOUTVDD );
    
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_TRI_VDDI
TYPE : iopad
EQN  : PAD_P = OIN_VDD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_TRI_VDDI(input OIN_VDD,
                      input EIN_VDD,
                      output PAD_P);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, PAD_P);
  bufif1	 U1(PAD_P,OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$           = (0.01, 0.01);
    specparam tpdLH_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdHL_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdLH_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdLZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZH_EINVDD_to_PADP = (0.01:0.01:0.01);

    //pin to pin path delay 
    (OIN_VDD => PAD_P) = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    (EIN_VDD => PAD_P) = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_BI_VDDI
TYPE : iopad
EQN  : PAD_P = OIN_VDD
          : IOUT_VDD = PAD_P
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_BI_VDDI (input OIN_VDD,
                      input EIN_VDD,
                      inout PAD_P,
                      output IOUT_VDD);
  reg NOTIFY_REG;
  
  UDP_BUFF ux(Y_int, OIN_VDD);
  buf	U1(IOUT_VDD,PAD_P);
  bufif1 U2(PAD_P,OIN_VDD,EIN_VDD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$            = (0.01, 0.01);
    specparam tpdLH_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdHL_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdLH_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdHL_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdLH_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdLZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZH_EINVDD_to_PADP = (0.01:0.01:0.01);

    //pin to pin path delay 
    (PAD_P => IOUT_VDD) = ( tpdLH_PADP_to_IOUTVDD, tpdHL_PADP_to_IOUTVDD );
    (OIN_VDD => PAD_P)  = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    (EIN_VDD => PAD_P)  = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
    (EIN_VDD => IOUT_VDD)  = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
    (OIN_VDD => IOUT_VDD)  = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IO_TEST
TYPE : io
EQN  : Y = D@E
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IO_TEST(input D,
               input E,
               output Y);
  reg NOTIFY_REG;

  buf U0(Y, D);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "io";
    specparam tpdLH_D_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y = (0.01:0.01:0.01);
                
		//pin to pin path delay 
		(D => Y ) = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
   endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOIN_IB
TYPE : io
EQN  : Y = YIN
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOIN_IB(input YIN,
               input E,
               output Y);
  reg NOTIFY_REG;
  buf	U0(Y,YIN);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "io";
    specparam tpdLH_YIN_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_YIN_to_Y = (0.01:0.01:0.01);
		
		//pin to pin path delay 
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IO_UNUSED
TYPE : io
EQN  : Y = YIN
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IO_UNUSED(input YIN,
                 output Y);
  reg NOTIFY_REG;
  buf	U0(Y,YIN);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "io";
    specparam tpdLH_YIN_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_YIN_to_Y = (0.01:0.01:0.01);
		
		//pin to pin path delay 
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOTRI_OB_EB
TYPE : io
EQN  : DOUT = D; EOUT = E
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOTRI_OB_EB(input D,
                   input E,
                   output DOUT,
                   output EOUT);
  reg NOTIFY_REG;
  
  buf	U0(DOUT,D);
  buf	U1(EOUT,E);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType = "io";
    specparam tpdLH_D_to_DOUT = (0.01:0.01:0.01);
		specparam tpdHL_D_to_DOUT = (0.01:0.01:0.01);
		specparam tpdLH_E_to_EOUT = (0.01:0.01:0.01);
		specparam tpdHL_E_to_EOUT = (0.01:0.01:0.01);
		
		//pin to pin path delay 
		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOBI_IB_OB_EB
TYPE : io
EQN  : DOUT = D; EOUT = E; Y = YIN
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOBI_IB_OB_EB(input D,
                     input E,
                     input YIN,
                     output DOUT,
                     output EOUT,
                     output Y);
  reg NOTIFY_REG;

  buf	U0(DOUT,D);
  buf	U1(EOUT,E);
  buf	U2(Y,YIN);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "io";
    specparam tpdLH_D_to_DOUT = (0.01:0.01:0.01);
		specparam tpdHL_D_to_DOUT = (0.01:0.01:0.01);
		specparam tpdLH_E_to_EOUT = (0.01:0.01:0.01);
		specparam tpdHL_E_to_EOUT = (0.01:0.01:0.01);
		specparam tpdLH_YIN_to_Y  = (0.01:0.01:0.01);
		specparam tpdHL_YIN_to_Y  = (0.01:0.01:0.01);
		
		//pin to pin path delay 
		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
		(YIN => Y )  = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : LIVE_FB_PROBES
TYPE : io
EQN  : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module LIVE_FB_PROBES(output PRBA,
                      output PRBB);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "io";
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : LIVE_PROBE_FB
TYPE : io
EQN  : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module LIVE_PROBE_FB(output PROBE_A,
                      output PROBE_B);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "io";
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : PRB_IB
TYPE : io
EQN  : 
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module PRB_IB(output Y);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
		specparam MacroType = "io";
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOINFF_BYPASS
TYPE : io
EQN  : Y = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOINFF_BYPASS (input A,
                      output Y);
  reg NOTIFY_REG;
  buf	U0(Y,A);

  specify
    specparam MacroType = "io";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
		specparam PATHPULSE$   = (0.01, 0.01);
    
		//pin to pin path delay 
		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOOUTFF_BYPASS
TYPE : io
EQN  : Y = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOOUTFF_BYPASS (input A,
                      output Y);
  reg NOTIFY_REG;
  buf	U0(Y,A);

  specify
    specparam MacroType = "io";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
		specparam PATHPULSE$   = (0.01, 0.01);
    
		//pin to pin path delay 
		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOENFF_BYPASS
TYPE : io
EQN  : Y = A
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOENFF_BYPASS (input A,
                      output Y);
  reg NOTIFY_REG;
  buf	U0(Y,A);

  specify
    specparam MacroType = "io";
    specparam tpdLH_A_to_Y = (0.01:0.01:0.01);
		specparam tpdHL_A_to_Y = (0.01:0.01:0.01);
    specparam PATHPULSE$   = (0.01, 0.01);
		
		//pin to pin path delay 
		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_VCCA
TYPE : iopad
EQN  : IOUT_IN = IOUT_VDD
          : OIN_VDD = OIN_P @ ( EIN_P == 1'b1 )
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_VCCA(input OIN_P,
                  input EIN_P,
                  input IOUT_VDD,
                  output OIN_VDD,
                  output EIN_VDD,
                  output IOUT_IN);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, IOUT_IN);
  buf	U1(IOUT_IN, IOUT_VDD);
  bufif1 U2(OIN_VDD, OIN_P, EIN_P);
  buf	U3(EIN_VDD, EIN_P);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$              = (0.01, 0.01);
    specparam tpdLH_IOUTVDD_to_IOUTIN = (0.01:0.01:0.01);
    specparam tpdHL_IOUTVDD_to_IOUTIN = (0.01:0.01:0.01);
    specparam tpdLH_EINP_to_EINVDD    = (0.01:0.01:0.01);
    specparam tpdHL_EINP_to_EINVDD    = (0.01:0.01:0.01);
    specparam tpdLH_EINP_to_OINVDD    = (0.0:0.0:0.0);
		specparam tpdHL_EINP_to_OINVDD    = (0.0:0.0:0.0);
		specparam tpdLZ_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdZL_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdHZ_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdZH_EINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdLH_OINP_to_OINVDD    = (0.01:0.01:0.01);
		specparam tpdHL_OINP_to_OINVDD    = (0.01:0.01:0.01);

    //pin to pin path delay 
    (IOUT_VDD => IOUT_IN) = ( tpdLH_IOUTVDD_to_IOUTIN, tpdHL_IOUTVDD_to_IOUTIN );
    (EIN_P => OIN_VDD )   = ( tpdLH_EINP_to_OINVDD,tpdHL_EINP_to_OINVDD,tpdLZ_EINP_to_OINVDD,tpdZH_EINP_to_OINVDD,tpdHZ_EINP_to_OINVDD,tpdZL_EINP_to_OINVDD);
    (OIN_P => OIN_VDD )   = ( tpdLH_OINP_to_OINVDD,tpdHL_OINP_to_OINVDD);
    (EIN_P => EIN_VDD )   = ( tpdLH_EINP_to_EINVDD,tpdHL_EINP_to_EINVDD);
    
    $width(negedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_IN_VCCI
TYPE : iopad
EQN  : IOUT_VDD = PAD_P
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_IN_VCCI (input PAD_P,
                      output IOUT_VDD);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, PAD_P);
  buf	U1(IOUT_VDD,PAD_P);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$            = (0.01, 0.01);
    specparam tpdLH_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdHL_PADP_to_IOUTVDD = (0.01:0.01:0.01);

    //pin to pin path delay 
    (PAD_P => IOUT_VDD) = ( tpdLH_PADP_to_IOUTVDD, tpdHL_PADP_to_IOUTVDD );
    
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_TRI_VCCI
TYPE : iopad
EQN  : PAD_P = OIN_VDD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_TRI_VCCI(input OIN_VDD,
                      input EIN_VDD,
                      output PAD_P);
  reg NOTIFY_REG;
  
  UDP_BUFF u0(Y_int, PAD_P);
  bufif1	 U1(PAD_P,OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$           = (0.01, 0.01);
    specparam tpdLH_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdHL_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdLH_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdLZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZH_EINVDD_to_PADP = (0.01:0.01:0.01);

    //pin to pin path delay 
    (OIN_VDD => PAD_P) = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    (EIN_VDD => PAD_P) = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPAD_BI_VCCI
TYPE : iopad
EQN  : PAD_P = OIN_VDD
          : IOUT_VDD = PAD_P
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPAD_BI_VCCI (input OIN_VDD,
                      input EIN_VDD,
                      inout PAD_P,
                      output IOUT_VDD);
  reg NOTIFY_REG;
  
  UDP_BUFF ux(Y_int, OIN_VDD);
  buf	U1(IOUT_VDD,PAD_P);
  bufif1 U2(PAD_P,OIN_VDD,EIN_VDD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$            = (0.01, 0.01);
    specparam tpdLH_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdHL_PADP_to_IOUTVDD = (0.01:0.01:0.01);
    specparam tpdLH_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdHL_OINVDD_to_PADP = (0.01:0.01:0.01);
    specparam tpdLH_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdLZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZL_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdHZ_EINVDD_to_PADP = (0.01:0.01:0.01);
		specparam tpdZH_EINVDD_to_PADP = (0.01:0.01:0.01);

    //pin to pin path delay 
    (PAD_P => IOUT_VDD) = ( tpdLH_PADP_to_IOUTVDD, tpdHL_PADP_to_IOUTVDD );
    (OIN_VDD => PAD_P)  = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    (EIN_VDD => PAD_P)  = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
    (EIN_VDD => IOUT_VDD)  = ( tpdLH_EINVDD_to_PADP,tpdHL_EINVDD_to_PADP,tpdLZ_EINVDD_to_PADP,tpdZH_EINVDD_to_PADP,tpdHZ_EINVDD_to_PADP,tpdZL_EINVDD_to_PADP);
    (OIN_VDD => IOUT_VDD)  = ( tpdLH_OINVDD_to_PADP, tpdHL_OINVDD_to_PADP );
    
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOINFF
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOINFF (output Q,
               input ADn,
               input ALn,
               input CLK,
               input D,
               input LAT,
               input SD,
               input EN,
               input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim DF_0 (.Q(Q), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType         = "ioff";
    specparam   tSetup          = (0.0);
    specparam   tHold           = (0.0);
    specparam   tWidth          = (0.0);
    specparam   tpdLH_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )  
      (posedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q
    
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (posedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (Q +: D))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2Q Transperant Mode
      (D => Q)  = (tpdLH_D_to_Q, tpdHL_D_to_Q);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2Q
      (posedge SLn => (Q +: D))   = (tpdLH_SL_to_Q, tpdHL_SL_to_Q);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2Q
      (posedge ALn => (Q +: D))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2Q
      (posedge ALn => (Q +: SD))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2Q
      (negedge SLn => (Q +: SD))  = (tpdLH_SLn_to_Q, tpdHL_SLn_to_Q);  
    if ( LAT && !EN )                                                // Activating ALn ALn2Q
      (negedge ALn => (Q +: ADn)) = (tpdLH_ALn_to_Q, tpdHL_ALn_to_Q);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge D, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge D, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge D, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOINFF_TEST
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOINFF_TEST (output QR,
                    output QF,
                    input ADn,
                    input ALn,
                    input CLK,
                    input D,
                    input LAT,
                    input SD,
                    input EN,
                    input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim latch (.Q(DF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(1'b1),
                 .SD(1'b1), .EN(ALn), .SLn(1'b1));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType          = "ioff";
    specparam   tSetup           = (0.0);
    specparam   tHold            = (0.0);
    specparam   tWidth           = (0.0);
    specparam   tpdLH_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QF   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QF   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QR +: D))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);   // CLK2QR
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QR +: SD))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);  // CLK2QR
    if ( !LAT )
      (negedge ALn => (QR +: ADn))  = (tpdLH_AL_to_QR, tpdHL_AL_to_QR);    // ALB2QR
      
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QF +: D))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);   // CLK2QF
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QF +: SD))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);  // CLK2QF
    if ( !LAT )
      (negedge ALn => (QF +: ADn))  = (tpdLH_AL_to_QF, tpdHL_AL_to_QF);    // ALB2QF
    
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2QR
      (posedge CLK => (QR +: D))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2QR
      (posedge CLK => (QR +: SD))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);    
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (QR +: D))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (QR +: SD))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2QR Transperant Mode
      (D => QR)  = (tpdLH_D_to_QR, tpdHL_D_to_QR);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2QR
      (posedge SLn => (QR +: D))   = (tpdLH_SL_to_QR, tpdHL_SL_to_QR);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2QR
      (posedge ALn => (QR +: D))  = (tpdLH_AL_to_QR, tpdHL_AL_to_QR);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2QR
      (posedge ALn => (QR +: SD))  = (tpdLH_AL_to_QR, tpdHL_AL_to_QR);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2QR
      (negedge SLn => (QR +: SD))  = (tpdLH_SLn_to_QR, tpdHL_SLn_to_QR);  
    if ( LAT && !EN )                                                // Activating ALn ALn2QR
      (negedge ALn => (QR +: ADn)) = (tpdLH_ALn_to_QR, tpdHL_ALn_to_QR);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge D, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge D, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge D, tHold, NOTIFY_REG);
    
    // Data setup and hold timing checks for the f_reg latch
    $setup(posedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, negedge D, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : DDR_IN
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module DDR_IN  (output QR,
                output QF,
                input ADn,
                input ALn,
                input CLK,
                input D,
                input SD,
                input EN,
                input SLn);
  
  reg NOTIFY_REG;
  wire LAT;
  
  assign LAT = 1'b0;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim latch (.Q(DF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(1'b1),
                 .SD(1'b1), .EN(ALn), .SLn(1'b1));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType          = "ioff";
    specparam   tSetup           = (0.0);
    specparam   tHold            = (0.0);
    specparam   tWidth           = (0.0);
    specparam   tpdLH_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QF   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QF   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QR +: D))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);   // CLK2QR
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QR +: SD))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);  // CLK2QR
    if ( !LAT )
      (negedge ALn => (QR +: ADn))  = (tpdLH_AL_to_QR, tpdHL_AL_to_QR);    // ALB2QR
      
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QF +: D))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);   // CLK2QF
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QF +: SD))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);  // CLK2QF
    if ( !LAT )
      (negedge ALn => (QF +: ADn))  = (tpdLH_AL_to_QF, tpdHL_AL_to_QF);    // ALB2QF
    
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge D, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge D, tHold, NOTIFY_REG);
    
    // Data setup and hold timing checks for the f_reg latch
    $setup(posedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, negedge D, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : DDR_IN_UNIT
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module DDR_IN_UNIT (output QR,
                    output QF,
                    input ADn,
                    input ALn,
                    input CLK,
                    input D,
                    input SD,
                    input EN,
                    input SLn,
                    input LAT);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim latch (.Q(DF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(D), .LAT(1'b1),
                 .SD(1'b1), .EN(ALn), .SLn(1'b1));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType          = "ioff";
    specparam   tSetup           = (0.0);
    specparam   tHold            = (0.0);
    specparam   tWidth           = (0.0);
    specparam   tpdLH_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QF  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_QR    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_QR  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QR   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QF   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QF   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QR +: D))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);   // CLK2QR
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QR +: SD))  = (tpdLH_CLK_to_QR, tpdHL_CLK_to_QR);  // CLK2QR
    if ( !LAT )
      (negedge ALn => (QR +: ADn))  = (tpdLH_AL_to_QR, tpdHL_AL_to_QR);    // ALB2QR
      
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QF +: D))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);   // CLK2QF
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (QF +: SD))  = (tpdLH_CLK_to_QF, tpdHL_CLK_to_QF);  // CLK2QF
    if ( !LAT )
      (negedge ALn => (QF +: ADn))  = (tpdLH_AL_to_QF, tpdHL_AL_to_QF);    // ALB2QF
    
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge D, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge D, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge D, tHold, NOTIFY_REG);
    
    // Data setup and hold timing checks for the f_reg latch
    $setup(posedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge D, negedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, posedge D, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable2, negedge D, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOOEFF_TEST
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOOEFF_TEST (output Q,
                    output QRDn,
                    input ADn,
                    input ALn,
                    input CLK,
                    input DR,
                    input DF,
                    input SDR,
                    input LAT,
                    input SD,
                    input EN,
                    input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DR), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF), .LAT(1'b0),
                 .SD(SD), .EN(EN), .SLn(SLn));
  or sdr_0(SEL, CLK, SDR);
  UDP_MUX2 mux_0(Q, QF, QR, SEL);
  not qrd_0(QRDn, QF);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType           = "ioff";
    specparam   tSetup            = (0.0);
    specparam   tHold             = (0.0);
    specparam   tWidth            = (0.0);
    specparam   tpdLH_CLK_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_CLK_to_QRDn = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QRDn = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q      = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q      = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QRDn  = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QRDn  = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (Q +: DR))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && SLn )
      (negedge CLK => (Q +: DF))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q
      
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QRDn +: DF))  = (tpdLH_CLK_to_QRDn, tpdHL_CLK_to_QRDn);   // CLK2Q
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (QRDn +: SD))  = (tpdLH_CLK_to_QRDn, tpdHL_CLK_to_QRDn);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (QRDn +: ADn))  = (tpdLH_AL_to_QRDn, tpdHL_AL_to_QRDn);    // ALB2Q
        
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (posedge CLK => (Q +: DR))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2QR
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (Q +: DR))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2Q Transperant Mode
      (DR => Q)  = (tpdLH_D_to_Q, tpdHL_D_to_Q);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2Q
      (posedge SLn => (Q +: DR))   = (tpdLH_SL_to_Q, tpdHL_SL_to_Q);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2Q
      (posedge ALn => (Q +: DR))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2Q
      (posedge ALn => (Q +: SD))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2Q
      (negedge SLn => (Q +: SD))  = (tpdLH_SLn_to_Q, tpdHL_SLn_to_Q);  
    if ( LAT && !EN )                                                // Activating ALn ALn2Q
      (negedge ALn => (Q +: ADn)) = (tpdLH_ALn_to_Q, tpdHL_ALn_to_Q);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge DR, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DR, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DR, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DR, tHold, NOTIFY_REG);
    
    $setup(posedge DF, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DF, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DF, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DF, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge DR, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge DR, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge DR, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge DR, tHold, NOTIFY_REG);
    
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOOEFF
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOOEFF (output Q,
               input ADn,
               input ALn,
               input CLK,
               input Dn,
               input SDR,
               input LAT,
               input SD,
               input EN,
               input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  not dn_0(Dn_, Dn);
  
  SLE_Prim DF_0 (.Q(Q), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(Dn_), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType         = "ioff";
    specparam   tSetup          = (0.0);
    specparam   tHold           = (0.0);
    specparam   tWidth          = (0.0);
    specparam   tpdLH_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q   = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )  
      (posedge CLK => (Q +: Dn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && !SLn )  
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q
    
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (posedge CLK => (Q +: Dn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (Q +: Dn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2Q Transperant Mode
      (Dn => Q)  = (tpdLH_D_to_Q, tpdHL_D_to_Q);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2Q
      (posedge SLn => (Q +: Dn))   = (tpdLH_SL_to_Q, tpdHL_SL_to_Q);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2Q
      (posedge ALn => (Q +: Dn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2Q
      (posedge ALn => (Q +: SD))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2Q
      (negedge SLn => (Q +: SD))  = (tpdLH_SLn_to_Q, tpdHL_SLn_to_Q);  
    if ( LAT && !EN )                                                // Activating ALn ALn2Q
      (negedge ALn => (Q +: ADn)) = (tpdLH_ALn_to_Q, tpdHL_ALn_to_Q);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge Dn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge Dn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge Dn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge Dn, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge Dn, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge Dn, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge Dn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge Dn, tHold, NOTIFY_REG);
   
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOOEFF_TEST_UNIT
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOOEFF_TEST_UNIT (output Q,
                         output QRDn,
                         input ADn,
                         input ALn,
                         input CLK,
                         input DRn,
                         input DFn,
                         input SDR,
                         input LAT,
                         input SD,
                         input EN,
                         input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  not dr_0(DR_, DRn);
  not df_0(DF_, DFn);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DR_), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF_), .LAT(1'b0),
                 .SD(SD), .EN(EN), .SLn(SLn));
  or sdr_0(SEL, CLK, SDR);
  UDP_MUX2 mux_0(Q, QF, QR, SEL);
  not qrd_0(QRDn, QF);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType           = "ioff";
    specparam   tSetup            = (0.0);
    specparam   tHold             = (0.0);
    specparam   tWidth            = (0.0);
    specparam   tpdLH_CLK_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_CLK_to_QRDn = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_QRDn = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q      = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q      = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q     = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_QRDn  = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_QRDn  = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (Q +: DRn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && SLn )
      (negedge CLK => (Q +: DFn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q
      
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (QRDn +: DFn))  = (tpdLH_CLK_to_QRDn, tpdHL_CLK_to_QRDn);   // CLK2Q
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (QRDn +: SD))  = (tpdLH_CLK_to_QRDn, tpdHL_CLK_to_QRDn);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (QRDn +: ADn))  = (tpdLH_AL_to_QRDn, tpdHL_AL_to_QRDn);    // ALB2Q
        
    // Latch mode
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (posedge CLK => (Q +: DRn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2QR
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  
    if ( LAT && ALn && EN && SLn )                                     // CLK2Q
      (negedge CLK => (Q +: DRn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && EN && !SLn )                                    // CLK2Q
      (negedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);    
    if ( LAT && ALn && CLK && EN && SLn )                              // D2Q Transperant Mode
      (DRn => Q)  = (tpdLH_D_to_Q, tpdHL_D_to_Q);
    if ( LAT && ALn && CLK && EN )                                    // Deactivating SLn SL2Q
      (posedge SLn => (Q +: DRn))   = (tpdLH_SL_to_Q, tpdHL_SL_to_Q);
    if ( LAT && EN && CLK && SLn )                                    // Deactivating ALn AL2Q
      (posedge ALn => (Q +: DRn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && EN && CLK && !SLn )                                   // Deactivating ALn AL2Q
      (posedge ALn => (Q +: SD))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);          
    if ( LAT && ALn && CLK && EN )                                    // Activating SLn SLn2Q
      (negedge SLn => (Q +: SD))  = (tpdLH_SLn_to_Q, tpdHL_SLn_to_Q);  
    if ( LAT && !EN )                                                // Activating ALn ALn2Q
      (negedge ALn => (Q +: ADn)) = (tpdLH_ALn_to_Q, tpdHL_ALn_to_Q);   
   
    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge DRn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DRn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DRn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DRn, tHold, NOTIFY_REG);
    
    $setup(posedge DFn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DFn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DFn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DFn, tHold, NOTIFY_REG);
    
    // Latch Data setup and hold timing checks
    $setup(posedge DRn, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $setup(negedge DRn, negedge CLK &&& Enable5, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, posedge DRn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable5, negedge DRn, tHold, NOTIFY_REG);
    
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $setup(negedge SLn, negedge CLK &&& Enable6, tSetup, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, posedge SLn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable6, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(posedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable7, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    $hold (negedge CLK &&& Enable7, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
    $recovery(posedge ALn, negedge CLK &&& Enable7, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : DDR_OUT
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module DDR_OUT (output Q,
                input ADn,
                input ALn,
                input CLK,
                input DR,
                input DF,
                input SD,
                input EN,
                input SLn);
  
  reg NOTIFY_REG;
  wire LAT;
  
  assign LAT = 1'b0;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DR), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF), .LAT(1'b0),
                 .SD(SD), .EN(EN), .SLn(SLn));
  UDP_MUX2 mux_0(Q, QF, QR, CLK);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType          = "ioff";
    specparam   tSetup           = (0.0);
    specparam   tHold            = (0.0);
    specparam   tWidth           = (0.0);
    specparam   tpdLH_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q    = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (Q +: DR))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && SLn )
      (negedge CLK => (Q +: DF))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q

    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge DR, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DR, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DR, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DR, tHold, NOTIFY_REG);
    
    $setup(posedge DF, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DF, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DF, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DF, tHold, NOTIFY_REG);
    
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : DDR_OE_UNIT
TYPE : IOFF
EQN  : Q = FF/LATCH
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module DDR_OE_UNIT (output Q,
                    input ADn,
                    input ALn,
                    input CLK,
                    input DRn,
                    input DFn,
                    input SDR,
                    input LAT,
                    input SD,
                    input EN,
                    input SLn);
  
  reg NOTIFY_REG;
  
  // FF Enables
  and  U0(Enable0, LAT_, EN, ALn, SLn);
  and  U1(Enable1, LAT_, EN, ALn);
  and  U2(Enable2, LAT_, ALn);
  and  U3(Enable3, LAT_, EN);
  buf  U4(Enable4, LAT_);
  
  // Latch Enables
  and  U5(Enable5, LAT, EN, ALn, SLn);
  and  U6(Enable6, LAT, EN, ALn);
  buf  U7(Enable7, LAT);
  
  not  U10(LAT_, LAT);
  
  not dr_0(DR_, DRn);
  not df_0(DF_, DFn);
  
  SLE_Prim r_reg (.Q(QR), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DR_), .LAT(LAT),
                 .SD(SD), .EN(EN), .SLn(SLn));
  SLE_Prim f_reg (.Q(QF), .ADn(ADn), .ALn(ALn), .CLK(CLK), .D(DF_), .LAT(1'b0),
                 .SD(SD), .EN(EN), .SLn(SLn));
  or sdr_0(SEL, CLK, SDR);
  UDP_MUX2 mux_0(Q, QF, QR, SEL);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType          = "ioff";
    specparam   tSetup           = (0.0);
    specparam   tHold            = (0.0);
    specparam   tWidth           = (0.0);
    specparam   tpdLH_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdHL_CLK_to_Q  = (0.01:0.01:0.01);
    specparam   tpdLH_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_D_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_SLn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_SLn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_ALn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdHL_ALn_to_Q   = (0.01:0.01:0.01);
    specparam   tpdLH_SL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_SL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdLH_AL_to_Q    = (0.01:0.01:0.01);
    specparam   tpdHL_AL_to_Q    = (0.01:0.01:0.01);
    
    //Output Path Delays
    // FF mode
    if ( !LAT && ALn && EN && SLn )
      (posedge CLK => (Q +: DRn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    if ( !LAT && ALn && EN && SLn )
      (negedge CLK => (Q +: DFn))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);   // CLK2Q
    
    if ( !LAT && ALn && EN && !SLn )
      (posedge CLK => (Q +: SD))  = (tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);  // CLK2Q
    if ( !LAT )
      (negedge ALn => (Q +: ADn))  = (tpdLH_AL_to_Q, tpdHL_AL_to_Q);    // ALB2Q

    //Inputs setup and hold times
    // FF Data setup and hold timing checks
    $setup(posedge DRn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DRn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DRn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DRn, tHold, NOTIFY_REG);
    
    $setup(posedge DFn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $setup(negedge DFn, posedge CLK &&& Enable0, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, posedge DFn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable0, negedge DFn, tHold, NOTIFY_REG);
    
    //Controls Setup and Hold times
    $setup(posedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $setup(negedge SLn, posedge CLK &&& Enable1, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, posedge SLn, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable1, negedge SLn, tHold, NOTIFY_REG);
    
    $setup(posedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $setup(negedge EN, posedge CLK &&& Enable2, tSetup, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, posedge EN, tHold, NOTIFY_REG);
    $hold (posedge CLK &&& Enable2, negedge EN, tHold, NOTIFY_REG);
        
    //Controls Pulse Width
    $width(posedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge CLK &&& Enable4, 0.0, 0, NOTIFY_REG);
    $width(negedge ALn            , 0.0, 0, NOTIFY_REG);
    
    // Asynchronous Controls Removal
    $hold (posedge CLK &&& Enable3, posedge ALn, tHold, NOTIFY_REG);
    
    // Asynchronous Controls Recovery
    $recovery(posedge ALn, posedge CLK &&& Enable3, tSetup, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : RGB
TYPE : RGB
LOGIC: YR = YL = !An @ !ENn
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module RGB (input An,
            input ENn,
            output YL,
            output YR);

  reg NOTIFY_REG;
  
  UDP_GBLAT rgb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(EN, ENn);
  nor U2(YL, An, Qn);
  nor U3(YR, An, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType      = "rgb";
    specparam tpdLH_A_to_YL  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YL  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YL = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YL = (0.01:0.01:0.01);
    specparam tpdLH_A_to_YR  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YR  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YR = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YR = (0.01:0.01:0.01);
    
    // Path Delays
    (posedge An => (YL +: 1'b0)) = (tpdLH_A_to_YL, tpdHL_A_to_YL);
    (negedge An => (YL +: ENn))  = (tpdLH_An_to_YL, tpdHL_An_to_YL);
    (posedge An => (YR +: 1'b0)) = (tpdLH_A_to_YR, tpdHL_A_to_YR);
    (negedge An => (YR +: ENn))  = (tpdLH_An_to_YR, tpdHL_An_to_YR);
    
    // Setup and Hold Timing Checks
    $setup(posedge ENn, negedge An, 0.0, NOTIFY_REG);
    $setup(negedge ENn, negedge An, 0.0, NOTIFY_REG);
    $hold (negedge An, posedge ENn, 0.0, NOTIFY_REG);    
    $hold (negedge An, negedge ENn, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(negedge An, 0.0, 0, NOTIFY_REG);
    $width(posedge An, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : RGB_TEST
TYPE : RGB
LOGIC: YR = YL = A @ EN
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module RGB_TEST (input A,
                 input EN,
                 output YL,
                 output YR);

  reg NOTIFY_REG;
  
  UDP_GBLAT rgb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(An, A);
  nor U2(YL, An, Qn);
  nor U3(YR, An, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType      = "rgb";
    specparam tpdLH_A_to_YL  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YL  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YL = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YL = (0.01:0.01:0.01);
    specparam tpdLH_A_to_YR  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YR  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YR = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YR = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (YL +: 1'b0)) = (tpdLH_An_to_YL, tpdHL_An_to_YL);
    (posedge A => (YL +: EN))   = (tpdLH_A_to_YL,  tpdHL_A_to_YL);
    (negedge A => (YR +: 1'b0)) = (tpdLH_An_to_YR, tpdHL_An_to_YR);
    (posedge A => (YR +: EN))   = (tpdLH_A_to_YR,  tpdHL_A_to_YR);
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge A, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge A, 0.0, NOTIFY_REG);
    $hold (posedge A, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge A, negedge EN, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : RGCLKINT
TYPE : RGB
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module RGCLKINT (input A,
                 input EN,
                 output Y);

    reg NOTIFY_REG;
  
  UDP_GBLAT rgb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(An, A);
  or U2(Yn, An, Qn);
  not U3(Y, Yn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType     = "rgb";
    specparam tpdLH_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_An_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (Y +: 1'b0)) = (tpdLH_An_to_Y, tpdHL_An_to_Y);
    (posedge A => (Y +: EN))   = (tpdLH_A_to_Y,  tpdHL_A_to_Y);
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge A, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge A, 0.0, NOTIFY_REG);
    $hold (posedge A, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge A, negedge EN, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : RCLKINT
TYPE : RGB
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module RCLKINT (input A,
                output Y);

  reg NOTIFY_REG;
  
  buf U0(Y, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType     = "rgb";
    specparam tpdLH_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_An_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (Y +: 1'b0)) = (tpdLH_An_to_Y, tpdHL_An_to_Y);
    (posedge A => (Y +: 1'b1)) = (tpdLH_A_to_Y,  tpdHL_A_to_Y);
    
    // Setup and Hold Timing Checks
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*---------------------------------------------------------------
NAME : GBM
TYPE : GBM
LOGIC: YWn = YEn = An @ !ENn
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GBM (input An,
            input ENn,
            output YEn,
            output YWn);

  reg NOTIFY_REG;

  UDP_GBLAT gb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(EN, ENn);
  or  U2(YEn, An, Qn);
  or  U3(YWn, An, Qn);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_A_to_YEn  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YEn  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YEn = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YEn = (0.01:0.01:0.01);
    specparam tpdLH_A_to_YWn  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YWn  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YWn = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YWn = (0.01:0.01:0.01);

    // Path Delays
    (posedge An => (YEn +: 1'b1)) = (tpdLH_A_to_YEn, tpdHL_A_to_YEn);
    (negedge An => (YEn +: ENn))  = (tpdLH_An_to_YEn, tpdHL_An_to_YEn);
    (posedge An => (YWn +: 1'b1)) = (tpdLH_A_to_YWn, tpdHL_A_to_YWn);
    (negedge An => (YWn +: ENn))  = (tpdLH_An_to_YWn, tpdHL_An_to_YWn);

    // Setup and Hold Timing Checks
    $setup(posedge ENn, negedge An, 0.0, NOTIFY_REG);
    $setup(negedge ENn, negedge An, 0.0, NOTIFY_REG);
    $hold (negedge An, posedge ENn, 0.0, NOTIFY_REG);
    $hold (negedge An, negedge ENn, 0.0, NOTIFY_REG);
    
    $setup(posedge ENn, posedge An, 0.0, NOTIFY_REG);
    $setup(negedge ENn, posedge An, 0.0, NOTIFY_REG);
    $hold (posedge An, posedge ENn, 0.0, NOTIFY_REG);
    $hold (posedge An, negedge ENn, 0.0, NOTIFY_REG);

    // Minimum Pulse Width Timing Checks
    $width(negedge An, 0.0, 0, NOTIFY_REG);
    $width(posedge An, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*---------------------------------------------------------------
NAME : GB
TYPE : GB
LOGIC: YNn = YSn = An @ !ENn
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GB (input An,
           input ENn,
           output YNn,
           output YSn);

  reg NOTIFY_REG;
  
  UDP_GBLAT gb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(EN, ENn);
  or  U2(YNn, An, Qn);
  or  U3(YSn, An, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_A_to_YNn  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YNn  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YNn = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YNn = (0.01:0.01:0.01);
    specparam tpdLH_A_to_YSn  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YSn  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YSn = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YSn = (0.01:0.01:0.01);
    
    // Path Delays
    (posedge An => (YNn +: 1'b1)) = (tpdLH_A_to_YNn, tpdHL_A_to_YNn);
    (negedge An => (YNn +: ENn))  = (tpdLH_An_to_YNn, tpdHL_An_to_YNn);
    (posedge An => (YSn +: 1'b1)) = (tpdLH_A_to_YSn, tpdHL_A_to_YSn);
    (negedge An => (YSn +: ENn))  = (tpdLH_An_to_YSn, tpdHL_An_to_YSn);
    
    // Setup and Hold Timing Checks
    $setup(posedge ENn, negedge An, 0.0, NOTIFY_REG);
    $setup(negedge ENn, negedge An, 0.0, NOTIFY_REG);
    $hold (negedge An, posedge ENn, 0.0, NOTIFY_REG);    
    $hold (negedge An, negedge ENn, 0.0, NOTIFY_REG);
    
    $setup(posedge ENn, posedge An, 0.0, NOTIFY_REG);
    $setup(negedge ENn, posedge An, 0.0, NOTIFY_REG);
    $hold (posedge An, posedge ENn, 0.0, NOTIFY_REG);
    $hold (posedge An, negedge ENn, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(negedge An, 0.0, 0, NOTIFY_REG);
    $width(posedge An, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : GB_TEST
TYPE : GB
LOGIC: YNn = YSn = An @ !ENn
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GB_TEST (input A,
                input EN,
                output YN,
                output YS);

  reg NOTIFY_REG;
  
  UDP_GBLAT gb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(An, A);
  nor U2(YN, An, Qn);
  nor U3(YS, An, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_A_to_YN  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YN  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YN = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YN = (0.01:0.01:0.01);
    specparam tpdLH_A_to_YS  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_YS  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_YS = (0.01:0.01:0.01);
    specparam tpdHL_An_to_YS = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (YN +: 1'b0)) = (tpdLH_An_to_YN, tpdHL_An_to_YN);
    (posedge A => (YN +: EN))   = (tpdLH_A_to_YN, tpdHL_A_to_YN);
    (negedge A => (YS +: 1'b0)) = (tpdLH_An_to_YS, tpdHL_An_to_YS);
    (posedge A => (YS +: EN))   = (tpdLH_A_to_YS, tpdHL_A_to_YS);
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge A, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge A, 0.0, NOTIFY_REG);
    $hold (posedge A, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge A, negedge EN, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : GCLKINT
TYPE : GB
LOGIC: Y = A @ EN
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GCLKINT (input A,
                input EN,
                output Y);

  reg NOTIFY_REG;
  
  UDP_GBLAT gb_0(Q, EN, An);
  not U0(Qn, Q);
  not U1(An, A);
  nor U2(Y, An, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_An_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (Y +: 1'b0)) = (tpdLH_An_to_Y, tpdHL_An_to_Y);
    (posedge A => (Y +: EN))   = (tpdLH_A_to_Y, tpdHL_A_to_Y);
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge A, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge A, 0.0, NOTIFY_REG);
    $hold (posedge A, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge A, negedge EN, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : CLKINT
TYPE : GB
LOGIC: Y = A
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CLKINT (input A,
               output Y);

  reg NOTIFY_REG;
  
  buf U0(Y, A);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_An_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_An_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge A => (Y +: 1'b0)) = (tpdLH_An_to_Y, tpdHL_An_to_Y);
    (posedge A => (Y +: 1'b1)) = (tpdLH_A_to_Y, tpdHL_A_to_Y);
    
    // Setup and Hold Timing Checks
    
    // Minimum Pulse Width Timing Checks
    $width(posedge A, 0.0, 0, NOTIFY_REG);
    $width(negedge A, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CLKBUF
TYPE : GB
EQN  : Y = PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CLKBUF(output Y,
              input PAD);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  buf U0(Y, PAD);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_PAD_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_PADn_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PADn_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge PAD => (Y +: 1'b0)) = (tpdLH_PADn_to_Y, tpdHL_PADn_to_Y);
    (posedge PAD => (Y +: 1'b1)) = (tpdLH_PAD_to_Y, tpdHL_PAD_to_Y);
    
    // Setup and Hold Timing Checks
    
    // Minimum Pulse Width Timing Checks
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : CLKBIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E % Y=PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CLKBIBUF(Y,D,E,PAD);
  input D,E;
  output Y;
  inout PAD;
  parameter IOSTD = "";
  reg NOTIFY_REG;

  bufif1  U0(PAD, D, E);
  buf     U1(Y, PAD);

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PAD= (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
    specparam MacroType = "gb";

    (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

    (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
    (D => Y ) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    (E => Y ) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 CELL NAME : GCLKBIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@EN % Y=PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GCLKBIBUF(Y,D,E,EN,PAD);
  input D,E,EN;
  output Y;
  inout PAD;
  parameter IOSTD = "";
  reg NOTIFY_REG;

  bufif1  U0(PAD, D, E);
  UDP_GBLAT gb_0(Q, EN, PADn);
  not U1(Qn, Q);
  not U2(PADn, PAD);
  nor U3(Y, PADn, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdLH_EN_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_EN_to_Y  = (0.01:0.01:0.01);
    specparam MacroType      = "gb";

    (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

    (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    (D => Y )   = ( tpdLH_D_to_Y, tpdLH_D_to_Y );
    (EN => Y )  = ( tpdLH_EN_to_Y, tpdLH_EN_to_Y );
    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge EN, 0.0, 0, NOTIFY_REG);
    $width(posedge EN, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*---------------------------------------------------------------
NAME : GCLKBUF
TYPE : GB
LOGIC: Y = A @ EN
-----------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GCLKBUF (input PAD,
                input EN,
                output Y);

  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  UDP_GBLAT gb_0(Q, EN, PADn);
  not U0(Qn, Q);
  not U1(PADn, PAD);
  nor U2(Y, PADn, Qn);
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam MacroType       = "gb";
    specparam tpdLH_PAD_to_Y  = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y  = (0.01:0.01:0.01);
    specparam tpdLH_PADn_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PADn_to_Y = (0.01:0.01:0.01);
    
    // Path Delays
    (negedge PAD => (Y +: 1'b0)) = (tpdLH_PADn_to_Y, tpdHL_PADn_to_Y);
    (posedge PAD => (Y +: EN))   = (tpdLH_PAD_to_Y, tpdHL_PAD_to_Y);
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge PAD, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge PAD, 0.0, NOTIFY_REG);
    $hold (posedge PAD, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge PAD, negedge EN, 0.0, NOTIFY_REG);
    
    // Minimum Pulse Width Timing Checks
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
 endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : OUTBUF
TYPE : iopad
EQN  : PAD = D
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module OUTBUF(output PAD,
              input D);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  buf	U0(PAD,D);
  
  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
    
    //Controls Pulse Width
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : INBUF
TYPE : iopad
EQN  : Y = PAD
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module INBUF(output Y,
             input PAD);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  buf U0(Y,PAD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    //Controls Pulse Width
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : TRIBUFF
TYPE : iopad
EQN  : PAD = D@E
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module TRIBUFF(output PAD,
               input D,
               input E);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  bufif1 U0(PAD, D, E);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (E => PAD ) = ( tpdLH_E_to_PAD, tpdHL_E_to_PAD, tpdLZ_E_to_PAD, tpdZH_E_to_PAD, tpdHZ_E_to_PAD, tpdZL_E_to_PAD );
    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
    
    //Controls Pulse Width
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : BIBUF
TYPE : iopad
EQN  : Y = PAD; PAD = D@E
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module BIBUF(output Y,
             input D,
             input E,
             inout PAD);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  bufif1 U0(PAD, D, E);
  buf	   U1(Y,PAD);

  specify
    specparam MacroType = "iopad";
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PAD = (0.01:0.01:0.01);
    specparam tpdLH_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdHL_D_to_Y   = (0.01:0.01:0.01);
    specparam tpdLH_E_to_Y   = (0.01:0.01:0.01);
    specparam tpdHL_E_to_Y   = (0.01:0.01:0.01);
    specparam tpdLH_PAD_to_Y = (0.01:0.01:0.01);
    specparam tpdHL_PAD_to_Y = (0.01:0.01:0.01);
    
    //pin to pin path delay 
    (E => PAD ) = ( tpdLH_E_to_PAD, tpdHL_E_to_PAD, tpdLZ_E_to_PAD, tpdZH_E_to_PAD, tpdHZ_E_to_PAD, tpdZL_E_to_PAD );
    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
    (D => Y )   = ( tpdLH_D_to_Y, tpdHL_D_to_Y );
    (E => Y )   = ( tpdLH_E_to_Y, tpdHL_E_to_Y );
    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    //Controls Pulse Width
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
/*--------------------------------------------------------------------
NAME : INBUF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module INBUF_DIFF(input PADP,
                  input PADN,
                  output Y);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  reg temp;
  pmos  u2(Y, temp, 1'b0);

  always @(PADP or PADN) begin
    if ((PADP == 1'b1) && (PADN == 1'b0))
      temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
      temp = 1'b0;
    else
        temp = 1'bx;
  end
    
  specify
		specparam MacroType = "io";
    specparam tpdLH_PAD_to_Y  = (0.01:0.01:0.01);
		specparam tpdHL_PAD_to_Y  = (0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
		
		//pin to pin path delay 
		(PADP => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
		(PADN => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    $width(negedge PADP, 0.0, 0, NOTIFY_REG);
    $width(posedge PADP, 0.0, 0, NOTIFY_REG);
    $width(negedge PADN, 0.0, 0, NOTIFY_REG);
    $width(posedge PADN, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : CLKBUF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module CLKBUF_DIFF(input PADP,
                   input PADN,
                   output Y);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  reg temp;
  pmos  u2(Y, temp, 1'b0);

  always @(PADP or PADN) begin
    if ((PADP == 1'b1) && (PADN == 1'b0))
      temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
      temp = 1'b0;
    else
        temp = 1'bx;
  end
    
  specify
		specparam MacroType = "io";
    specparam tpdLH_PAD_to_Y  = (0.01:0.01:0.01);
		specparam tpdHL_PAD_to_Y  = (0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
		
		//pin to pin path delay 
		(PADP => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
		(PADN => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    $width(negedge PADP, 0.0, 0, NOTIFY_REG);
    $width(posedge PADP, 0.0, 0, NOTIFY_REG);
    $width(negedge PADN, 0.0, 0, NOTIFY_REG);
    $width(posedge PADN, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : GCLKBUF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module GCLKBUF_DIFF(input PADP,
                    input PADN,
                    input EN,
                    output Y);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  reg temp;
  //pmos  u2(Y, temp, 1'b0);
  
  UDP_GBLAT gb_0(Q, EN, _temp);
  not u0(Qn, Q);
  not u1(_temp, temp);
  nor u3(Y, _temp, Qn);

  always @(PADP or PADN) begin
    if ((PADP == 1'b1) && (PADN == 1'b0))
      temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
      temp = 1'b0;
    else
        temp = 1'bx;
  end
    
  specify
		specparam MacroType = "io";
    specparam tpdLH_PAD_to_Y  = (0.01:0.01:0.01);
		specparam tpdHL_PAD_to_Y  = (0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
		
		//pin to pin path delay 
		(PADP => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
		(PADN => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    
    // Setup and Hold Timing Checks
    $setup(posedge EN, posedge PADP, 0.0, NOTIFY_REG);
    $setup(negedge EN, posedge PADP, 0.0, NOTIFY_REG);
    $hold (posedge PADP, posedge EN, 0.0, NOTIFY_REG);    
    $hold (posedge PADP, negedge EN, 0.0, NOTIFY_REG);
    
    $setup(posedge EN, negedge PADN, 0.0, NOTIFY_REG);
    $setup(negedge EN, negedge PADN, 0.0, NOTIFY_REG);
    $hold (negedge PADN, posedge EN, 0.0, NOTIFY_REG);    
    $hold (negedge PADN, negedge EN, 0.0, NOTIFY_REG);
    
    $width(negedge PADP, 0.0, 0, NOTIFY_REG);
    $width(posedge PADP, 0.0, 0, NOTIFY_REG);
    $width(negedge PADN, 0.0, 0, NOTIFY_REG);
    $width(posedge PADN, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : OUTBUF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module OUTBUF_DIFF (output PADP,
                    output PADN,
                    input D);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  buf u0(PADP, D);
  not u1(PADN, D);
    
  specify
		specparam MacroType = "io";
    specparam tpdLH_D_to_PAD  = (0.01:0.01:0.01);
		specparam tpdHL_D_to_PAD  = (0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
		
		//pin to pin path delay 
		(D => PADP ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
		(D => PADN ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
    
    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : BIBUF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module BIBUF_DIFF(inout PADP,
                  inout PADN,
                  input D,
                  input E,
                  output Y);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  reg temp;

  bufif1  u0(PADP, D, E);
  not     u1(D_tmp, D);
  bufif1  u2(PADN, D_tmp, E);
  pmos    u3(Y, temp, 1'b0);

  always @(PADP or PADN) begin
    if ((PADP == 1'b1) && (PADN == 1'b0))
      temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
      temp = 1'b0;
    else
      temp = 1'bx;
  end

  specify
    specparam tpdLH_E_to_PADP = ( 0.0:0.0:0.0 );
    specparam tpdHL_E_to_PADP = ( 0.0:0.0:0.0 );
    specparam tpdLH_E_to_PADN = ( 0.0:0.0:0.0 );
    specparam tpdHL_E_to_PADN = ( 0.0:0.0:0.0 );
    specparam tpdLZ_E_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PADP = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PADN = ( 0.01:0.01:0.01 );
    specparam tpdLH_PADP_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_PADP_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdLH_PADN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_PADN_to_Y = ( 0.01:0.01:0.01 );
    specparam PATHPULSE$       = (0.01, 0.01);
    specparam MacroType = "io";

    //pin to pin path delay 
    ( E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP );
    ( E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN );

    ( D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP );
    ( D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN );

    ( D => Y )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( E => Y )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PADP => Y ) = ( tpdLH_PADP_to_Y, tpdHL_PADP_to_Y );
    ( PADN => Y ) = ( tpdLH_PADN_to_Y, tpdHL_PADN_to_Y );

    $width( negedge PADP, 0.0, 0, NOTIFY_REG );
    $width( posedge PADP, 0.0, 0, NOTIFY_REG );
    $width( negedge PADN, 0.0, 0, NOTIFY_REG );
    $width( posedge PADN, 0.0, 0, NOTIFY_REG );
    $width( negedge D, 0.0, 0, NOTIFY_REG );
    $width( posedge D, 0.0, 0, NOTIFY_REG );
    $width( negedge E, 0.0, 0, NOTIFY_REG );
    $width( posedge E, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : TRIBUFF_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module TRIBUFF_DIFF(output PADP,
                    output PADN,
                    input D,
                    input E);
  parameter IOSTD = "";
  reg NOTIFY_REG;
  
  bufif1  u0(PADP, D, E);
  not     u1(D_tmp, D);
  bufif1  u2(PADN, D_tmp, E);

  specify
    specparam tpdLH_E_to_PADP = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PADP = (0.0:0.0:0.0);
    specparam tpdLH_E_to_PADN = (0.0:0.0:0.0);
    specparam tpdHL_E_to_PADN = (0.0:0.0:0.0);
    specparam tpdLZ_E_to_PADP = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PADP = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PADP = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PADP = (0.01:0.01:0.01);
    specparam tpdLZ_E_to_PADN = (0.01:0.01:0.01);
    specparam tpdZL_E_to_PADN = (0.01:0.01:0.01);
    specparam tpdHZ_E_to_PADN = (0.01:0.01:0.01);
    specparam tpdZH_E_to_PADN = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PADP = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PADP = (0.01:0.01:0.01);
    specparam tpdLH_D_to_PADN = (0.01:0.01:0.01);
    specparam tpdHL_D_to_PADN = (0.01:0.01:0.01);
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    //pin to pin path delay 
    (E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP);
    (E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN);

    (D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP);
    (D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN);

    $width(negedge D, 0.0, 0, NOTIFY_REG);
    $width(posedge D, 0.0, 0, NOTIFY_REG);
    $width(negedge E, 0.0, 0, NOTIFY_REG);
    $width(posedge E, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME : IOPADN_IN
TYPE : iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_IN (input   PAD_P,
                  output  N2POUT_P);
  reg NOTIFY_REG;
  not u0(N2POUT_P, PAD_P);

  specify
    specparam MacroType = "io";

    (PAD_P => N2POUT_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
    
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME  : IOPADN_TRI
 TYPE: iopad
---------------------------------------------------------------------*/      
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_TRI(output  PAD_P,
                  input   OIN_P,
                  input   EIN_P);
  reg NOTIFY_REG;
  not    u0 (_OIN_P, OIN_P);
  bufif1 u1 (PAD_P, _OIN_P, EIN_P);

  specify
    specparam MacroType = "io";
    (EIN_P  => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_P => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    specparam PATHPULSE$       = (0.01, 0.01);
    
    $width(negedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME : IOPADN_BI
 TYPE : iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_BI (inout   PAD_P,
                  output  N2POUT_P,
                  input   OIN_P,
                  input   EIN_P);
  reg NOTIFY_REG;
  reg temp;
  
  not     u0(_OIN_P, OIN_P);
  bufif1  u1(PAD_P, _OIN_P, EIN_P);
  buf     u2(N2POUT_P, PAD_P);

  specify
    specparam tpdLH_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD  = ( 0.01:0.01:0.01 );
    specparam tpdLH_DB_to_PAD = ( 0.01:0.01:0.01 );
    specparam tpdHL_DB_to_PAD = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_N2POUT = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_N2POUT = ( 0.01:0.01:0.01 );
    specparam PATHPULSE$       = (0.01, 0.01);
    specparam MacroType = "io";

    //pin to pin path delay 
    ( EIN_P => PAD_P ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_P => PAD_P ) = ( tpdLH_DB_to_PAD,tpdHL_DB_to_PAD );
    ( PAD_P => N2POUT_P ) = ( tpdLH_PAD_to_N2POUT, tpdHL_PAD_to_N2POUT );
    ( OIN_P => N2POUT_P ) = ( tpdLH_PAD_to_N2POUT, tpdHL_PAD_to_N2POUT );
    ( EIN_P => N2POUT_P ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPADN_DELAY
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_DELAY (output N2POUT_P,
                     input  IOUT_IN);
  reg NOTIFY_REG;
  reg temp;
  
  buf u0 (N2POUT_P, IOUT_IN);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( IOUT_IN => N2POUT_P )   = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPADN_VDD
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPADN_VDD (output IOUT_IN,
                    output EIN_VDD,
                    output OIN_VDD,
                    input  OIN_P,
                    input  EIN_P,
                    input  IOUT_VDD);
  reg NOTIFY_REG;
  
  buf u0 (IOUT_IN, IOUT_VDD);
  buf u1 (EIN_VDD, EIN_P);
  buf u2 (OIN_VDD, OIN_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_P => EIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( OIN_P => OIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( IOUT_VDD => IOUT_IN ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOPADN_BI_VDDI
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_BI_VDDI (inout  PAD_P,
                       output IOUT_VDD,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  reg temp;
  
  not    u2 (_OIN_VDD, OIN_VDD);
  bufif1 u0 (PAD_P, _OIN_VDD, EIN_VDD);
  pmos   u1 (IOUT_VDD, temp, 1'b0);

  always @( PAD_P ) begin
    if ((PAD_P == 1'b1))
      temp = 1'b0;
    else if ((PAD_P == 1'b0))
      temp = 1'b1;
    else
      temp = 1'bx;
  end


  specify
    specparam tpdLH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdLH_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_VDD => PAD_P )    = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_VDD => PAD_P )    = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    ( OIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( EIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PAD_P => IOUT_VDD )   = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_VDD, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME: IOPADN_IN_VDDI
 TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_IN_VDDI (output IOUT_VDD,
                       input  PAD_P);
 
  reg NOTIFY_REG;
  
  not u0(IOUT_VDD, PAD_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (PAD_P => IOUT_VDD)        = (0.01:0.01:0.01, 0.01:0.01:0.01); 
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME  : IOPADN_TRI_VDDI
TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_TRI_VDDI(output PAD_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  not    u2 (_OIN_VDD, OIN_VDD);
  bufif1 u0 (PAD_P, _OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (EIN_VDD => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_VDD => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_VDD, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME: IOPADP_IN
 TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_IN (output IOUT_P,
                  input  PAD_P,
                  input  N2PIN_P);
 
  reg NOTIFY_REG;
  
  buf u0(IOUT_P, PAD_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (PAD_P => IOUT_P) = (0.01:0.01:0.01, 0.01:0.01:0.01); 
    (N2PIN_P => IOUT_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME  : IOPADP_TRI
TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_TRI(output PAD_P,
                  input  OIN_P,
                  input  EIN_P);
  reg NOTIFY_REG;
  bufif1 u0 (PAD_P, OIN_P, EIN_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (EIN_P => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_P => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPADP_BI
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_BI (inout  PAD_P,
                  output IOUT_P,
                  input  N2PIN_P,
                  input  OIN_P,
                  input  EIN_P);
  reg NOTIFY_REG;
  reg temp;
  
  bufif1 u0 (PAD_P, OIN_P, EIN_P);
  pmos   u1 (IOUT_P, temp, 1'b0);

  always @( PAD_P or N2PIN_P ) begin
    if ((PAD_P == 1'b1) && (N2PIN_P == 1'b0))
      temp = 1'b1;
    else if ((PAD_P == 1'b0) && (N2PIN_P == 1'b1))
      temp = 1'b0;
    else
      temp = 1'bx;
  end


  specify
    specparam tpdLH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdLH_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_P => PAD_P )    = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_P => PAD_P )    = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    ( OIN_P => IOUT_P )   = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( EIN_P => IOUT_P )   = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PAD_P => IOUT_P )   = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    ( N2PIN_P => IOUT_P ) = ( tpdLH_N2PIN_to_Y, tpdHL_N2PIN_to_Y );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IO_DIFF
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IO_DIFF (input  YIN);
  reg NOTIFY_REG;
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    $width( negedge YIN, 0.0, 0, NOTIFY_REG );
    $width( posedge YIN, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults



/*--------------------------------------------------------------------
NAME : IOPADP_DELAY
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_DELAY (output IOUT_P,
                     input  IOUT_IN);
  reg NOTIFY_REG;
  reg temp;
  
  buf u0 (IOUT_P, IOUT_IN);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( IOUT_IN => IOUT_P )   = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPADP_VDD
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPADP_VDD (output IOUT_IN,
                    output EIN_VDD,
                    output OIN_VDD,
                    input  OIN_P,
                    input  EIN_P,
                    input  IOUT_VDD);
  reg NOTIFY_REG;
  
  buf u0 (IOUT_IN, IOUT_VDD);
  buf u1 (EIN_VDD, EIN_P);
  buf u2 (OIN_VDD, OIN_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_P => EIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( OIN_P => OIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( IOUT_VDD => IOUT_IN ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOPADP_BI_VDDI
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_BI_VDDI (inout  PAD_P,
                       output IOUT_VDD,
                       input  N2PIN_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  reg temp;
  
  bufif1 u0 (PAD_P, OIN_VDD, EIN_VDD);
  pmos   u1 (IOUT_VDD, temp, 1'b0);

  always @(PAD_P or N2PIN_P) begin
    if ((PAD_P == 1'b1) && (N2PIN_P == 1'b1))
      temp = 1'b1;
    else if ((PAD_P == 1'b0) && (N2PIN_P == 1'b0))
      temp = 1'b0;
    else
        temp = 1'bx;
  end


  specify
    specparam tpdLH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdLH_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_VDD => PAD_P )    = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_VDD => PAD_P )    = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    ( OIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( EIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PAD_P => IOUT_VDD )   = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    ( N2PIN_P => IOUT_VDD ) = ( tpdLH_N2PIN_to_Y, tpdHL_N2PIN_to_Y );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_VDD, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME: IOPADP_IN_VDDI
 TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_IN_VDDI (output IOUT_VDD,
                       input  PAD_P,
                       input  N2PIN_P);
 
  reg NOTIFY_REG;
  reg temp;
  buf u0(IOUT_VDD, temp);
  
  always @(PAD_P or N2PIN_P) begin
    if ((PAD_P == 1'b1) && (N2PIN_P == 1'b1))
      temp = 1'b1;
    else if ((PAD_P == 1'b0) && (N2PIN_P == 1'b0))
      temp = 1'b0;
    else
        temp = 1'bx;
  end

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (PAD_P => IOUT_VDD)        = (0.01:0.01:0.01, 0.01:0.01:0.01); 
    (N2PIN_P => IOUT_VDD)      = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME  : IOPADP_TRI_VDDI
TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_TRI_VDDI(output PAD_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  bufif1 u0 (PAD_P, OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (EIN_VDD => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_VDD => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_VDD, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOPADN_VCCA
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPADN_VCCA (output IOUT_IN,
                    output EIN_VDD,
                    output OIN_VDD,
                    input  OIN_P,
                    input  EIN_P,
                    input  IOUT_VDD);
  reg NOTIFY_REG;
  
  buf u0 (IOUT_IN, IOUT_VDD);
  buf u1 (EIN_VDD, EIN_P);
  buf u2 (OIN_VDD, OIN_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_P => EIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( OIN_P => OIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( IOUT_VDD => IOUT_IN ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOPADN_BI_VCCI
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_BI_VCCI (inout  PAD_P,
                       output IOUT_VDD,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  reg temp;
  
  not    u2 (_OIN_VDD, OIN_VDD);
  bufif1 u0 (PAD_P, _OIN_VDD, EIN_VDD);
  pmos   u1 (IOUT_VDD, temp, 1'b0);

  always @( PAD_P ) begin
    if ((PAD_P == 1'b1))
      temp = 1'b0;
    else if ((PAD_P == 1'b0))
      temp = 1'b1;
    else
      temp = 1'bx;
  end


  specify
    specparam tpdLH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdLH_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_VDD => PAD_P )    = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_VDD => PAD_P )    = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    ( OIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( EIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PAD_P => IOUT_VDD )   = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_VDD, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME: IOPADN_IN_VCCI
 TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_IN_VCCI (output IOUT_VDD,
                       input  PAD_P);
 
  reg NOTIFY_REG;
  
  not u0(IOUT_VDD, PAD_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (PAD_P => IOUT_VDD)        = (0.01:0.01:0.01, 0.01:0.01:0.01); 
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME  : IOPADN_TRI_VCCI
TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADN_TRI_VCCI(output PAD_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  not    u2 (_OIN_VDD, OIN_VDD);
  bufif1 u0 (PAD_P, _OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (EIN_VDD => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_VDD => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_VDD, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME : IOPADP_VCCA
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module IOPADP_VCCA (output IOUT_IN,
                    output EIN_VDD,
                    output OIN_VDD,
                    input  OIN_P,
                    input  EIN_P,
                    input  IOUT_VDD);
  reg NOTIFY_REG;
  
  buf u0 (IOUT_IN, IOUT_VDD);
  buf u1 (EIN_VDD, EIN_P);
  buf u2 (OIN_VDD, OIN_P);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_P => EIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( OIN_P => OIN_VDD )    = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( IOUT_VDD => IOUT_IN ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    $width( negedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_P, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


/*--------------------------------------------------------------------
NAME : IOPADP_BI_VCCI
TYPE : io
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_BI_VCCI (inout  PAD_P,
                       output IOUT_VDD,
                       input  N2PIN_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  reg temp;
  
  bufif1 u0 (PAD_P, OIN_VDD, EIN_VDD);
  pmos   u1 (IOUT_VDD, temp, 1'b0);

  always @(PAD_P or N2PIN_P) begin
    if ((PAD_P == 1'b1) && (N2PIN_P == 1'b1))
      temp = 1'b1;
    else if ((PAD_P == 1'b0) && (N2PIN_P == 1'b0))
      temp = 1'b0;
    else
        temp = 1'bx;
  end


  specify
    specparam tpdLH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZL_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHZ_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdZH_E_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdHL_D_to_PAD   = ( 0.01:0.01:0.01 );
    specparam tpdLH_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdHL_PAD_to_Y   = ( 0.01:0.01:0.01 );
    specparam tpdLH_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam tpdHL_N2PIN_to_Y = ( 0.01:0.01:0.01 );
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);

    ( EIN_VDD => PAD_P )    = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
    ( OIN_VDD => PAD_P )    = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );
    ( OIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( EIN_VDD => IOUT_VDD ) = ( 0.01:0.01:0.01, 0.01:0.01:0.01 );
    ( PAD_P => IOUT_VDD )   = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    ( N2PIN_P => IOUT_VDD ) = ( tpdLH_N2PIN_to_Y, tpdHL_N2PIN_to_Y );
    $width( negedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( posedge PAD_P, 0.0, 0, NOTIFY_REG );
    $width( negedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( posedge N2PIN_P, 0.0, 0, NOTIFY_REG );
    $width( negedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge OIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( negedge EIN_VDD, 0.0, 0, NOTIFY_REG );
    $width( posedge EIN_VDD, 0.0, 0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
 NAME: IOPADP_IN_VCCI
 TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_IN_VCCI (output IOUT_VDD,
                       input  PAD_P,
                       input  N2PIN_P);
 
  reg NOTIFY_REG;
  reg temp;
  buf u0(IOUT_VDD, temp);
  
  always @(PAD_P or N2PIN_P) begin
    if ((PAD_P == 1'b1) && (N2PIN_P == 1'b1))
      temp = 1'b1;
    else if ((PAD_P == 1'b0) && (N2PIN_P == 1'b0))
      temp = 1'b0;
    else
        temp = 1'bx;
  end

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (PAD_P => IOUT_VDD)        = (0.01:0.01:0.01, 0.01:0.01:0.01); 
    (N2PIN_P => IOUT_VDD)      = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(posedge N2PIN_P, 0.0, 0, NOTIFY_REG);
    $width(negedge PAD_P, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD_P, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

/*--------------------------------------------------------------------
NAME  : IOPADP_TRI_VCCI
TYPE: iopad
---------------------------------------------------------------------*/
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module IOPADP_TRI_VCCI(output PAD_P,
                       input  OIN_VDD,
                       input  EIN_VDD);
  reg NOTIFY_REG;
  bufif1 u0 (PAD_P, OIN_VDD, EIN_VDD);

  specify
    specparam MacroType = "io";
    specparam PATHPULSE$       = (0.01, 0.01);
    (EIN_VDD => PAD_P) = (0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01,0.01:0.01:0.01); 
    (OIN_VDD => PAD_P) = (0.01:0.01:0.01, 0.01:0.01:0.01);
    $width(negedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge OIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(negedge EIN_VDD, 0.0, 0, NOTIFY_REG);
    $width(posedge EIN_VDD, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module G4C (output          CLK_1MHZ_ENA,
            output          CLK_50MHZ_ENA_FAB,
            output          CLK_XTAL_ENA,
            output          FF_IN_PROGRESS_FAB,
            output          RAM_INIT_DONE_B,
            output          UJ_DRCAP,
            output          UJ_DRSH,
            output          UJ_DRUPD,
            output [7:0]    UJ_IR,
            output          UJ_RSTB,
            output          UJ_TCK,
            output          UJ_TDI,
            output          US_ASICRESET_B,
            output          US_ASICTEST,
            output          US_FF_ACK,
            output          US_POR_B,
            output          US_RESTORE,
            output [15:0]   US_TAMPER,
            output          US_WE,
            input  [5:0]    CALIB_CLKS,
            input  [1:0]    OSC_XTAL_MODE,
            input           UJ_TDO,
            input  [6:0]    US_IRQ_B,
            input           US_RC1MHZ_OFF,
            input           US_RC50MHZ_OFF,
            input  [7:0]    US_RESPONSE_B,
            input  [16:0]   US_SPARE_IN,
            input           US_XTAL_OFF,
            input           TDI,
            input           TMS,
            input           TCK,
            input           TRSTB,
            output          TDO
          );

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UJ_DRUPD_zd, UJ_DRCAP_zd, UJ_DRSH_zd, UJ_RSTB_zd;
  reg       NOTIFY_REG;

  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UJ_TDO_int,  UJ_TDO  );

  pmos pmos_uireg0  ( UJ_IR[0], UJ_IR0_zd, 0 );
  pmos pmos_uireg1  ( UJ_IR[1], UJ_IR1_zd, 0 );
  pmos pmos_uireg2  ( UJ_IR[2], UJ_IR2_zd, 0 );
  pmos pmos_uireg3  ( UJ_IR[3], UJ_IR3_zd, 0 );
  pmos pmos_uireg4  ( UJ_IR[4], UJ_IR4_zd, 0 );
  pmos pmos_uireg5  ( UJ_IR[5], UJ_IR5_zd, 0 );
  pmos pmos_uireg6  ( UJ_IR[6], UJ_IR6_zd, 0 );
  pmos pmos_uireg7  ( UJ_IR[7], UJ_IR7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( UJ_RSTB,  UJ_RSTB_zd,  0 );
  pmos pmos_udrcap  ( UJ_DRCAP, UJ_DRCAP_zd, 0 );
  pmos pmos_udrsh   ( UJ_DRSH,  UJ_DRSH_zd,  0 );
  pmos pmos_udrupd  ( UJ_DRUPD, UJ_DRUPD_zd, 0 );

  assign { UJ_IR7_zd, UJ_IR6_zd, UJ_IR5_zd, UJ_IR4_zd, UJ_IR3_zd, UJ_IR2_zd, UJ_IR1_zd, UJ_IR0_zd } = IR;
  assign UJ_TDI  = TDI_int;
  assign UJ_TCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UJ_DRUPD_zd <= 0;
      UJ_DRSH_zd  <= 0;
      UJ_DRCAP_zd <= 0;
      UJ_RSTB_zd  <= 0;
    end else begin
      UJ_DRUPD_zd <= ( STATE == `Update_DR        );
      UJ_DRSH_zd  <= ( STATE == `Shift_DR         );
      UJ_DRCAP_zd <= ( STATE == `Capture_DR       );
      UJ_RSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UJ_TDO_int;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UJ_IR[0]+:UJ_IR[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[1]+:UJ_IR[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[2]+:UJ_IR[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[3]+:UJ_IR[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[4]+:UJ_IR[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[5]+:UJ_IR[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[6]+:UJ_IR[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_IR[7]+:UJ_IR[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UJ_TCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_TCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UJ_TDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UJ_TDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (UJ_RSTB +:UJ_RSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_DRSH +:UJ_DRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_DRCAP+:UJ_DRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UJ_DRUPD+:UJ_DRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UJ_IR[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_IR[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UJ_RSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_DRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_DRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UJ_DRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UJ_TDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UJ_TDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UJ_TDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UJ_TDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
  endspecify

endmodule
//---- END MODULE G4C ----


/*--------------------------------------------------------------------
NAME : UJTAG
TYPE : IP
LOGIC: Simple TAP for simulation of designs using the IGLOO2 user JTAG interface
NOTES:
  1. This TAP is not a model of the actual TAP used in the IGLOO2. The
  only instruction implemented is BYPASS. An instruction scan operation
  will capture the pattern 8'bxxxxxx01
  2. This model should not be used for the A500K family, as it uses
  a different set of interface signals.
---------------------------------------------------------------------*/

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG ( UIREG,
               URSTB, UDRCK, UTDI, UDRCAP, UDRSH, UDRUPD, UTDO,
               TRSTB, TDO, TDI, TMS, TCK );

  output  [7:0] UIREG;
  output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, TDO;
  input   UTDO, TMS, TDI, TCK, TRSTB;
  

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
  reg       NOTIFY_REG;

  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UTDO_int,  UTDO  );

  pmos pmos_uireg0  ( UIREG[0], UIREG0_zd, 0 );
  pmos pmos_uireg1  ( UIREG[1], UIREG1_zd, 0 );
  pmos pmos_uireg2  ( UIREG[2], UIREG2_zd, 0 );
  pmos pmos_uireg3  ( UIREG[3], UIREG3_zd, 0 );
  pmos pmos_uireg4  ( UIREG[4], UIREG4_zd, 0 );
  pmos pmos_uireg5  ( UIREG[5], UIREG5_zd, 0 );
  pmos pmos_uireg6  ( UIREG[6], UIREG6_zd, 0 );
  pmos pmos_uireg7  ( UIREG[7], UIREG7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
  pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
  pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
  pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );

  assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
  assign UTDI  = TDI_int;
  assign UDRCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UDRUPD_zd <= 0;
      UDRSH_zd  <= 0;
      UDRCAP_zd <= 0;
      URSTB_zd  <= 0;
    end else begin
      UDRUPD_zd <= ( STATE == `Update_DR        );
      UDRSH_zd  <= ( STATE == `Shift_DR         );
      UDRCAP_zd <= ( STATE == `Capture_DR       );
      URSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UTDO;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
  endspecify

endmodule
//---- END MODULE UJTAG ----


/*--------------------------------------------------------------------
NAME : UJTAG_SYSRESET 
TYPE : IP
LOGIC: Simple TAP for simulation of designs using the IGLOO2 user JTAG interface
NOTES:
  1. This TAP is not a model of the actual TAP used in the IGLOO2. The
  only instruction implemented is BYPASS. An instruction scan operation
  will capture the pattern 8'bxxxxxx01
  2. This model should not be used for the A500K family, as it uses
  a different set of interface signals.
---------------------------------------------------------------------*/

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG_SYSRESET ( UIREG,
               URSTB, UDRCK, UTDI, UDRCAP, UDRSH, UDRUPD, UTDO,
               TRSTB, TDO, TDI, TMS, TCK,
               DEVRST_N, POWER_ON_RESET_N);

  output  [7:0] UIREG;
  output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, TDO;
  input   UTDO, TMS, TDI, TCK, TRSTB;
  input   DEVRST_N;
  output  POWER_ON_RESET_N;

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
  reg       NOTIFY_REG;

  reg reset_n_int;
  
  initial begin
    reset_n_int = 1'b1;
    #1;
    reset_n_int = 1'b0;
    #1000;
    reset_n_int = 1'b1;
  end
  
  and U0 ( POWER_ON_RESET_N, DEVRST_N, reset_n_int );
  
  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UTDO_int,  UTDO  );

  pmos pmos_uireg0  ( UIREG[0], UIREG0_zd, 0 );
  pmos pmos_uireg1  ( UIREG[1], UIREG1_zd, 0 );
  pmos pmos_uireg2  ( UIREG[2], UIREG2_zd, 0 );
  pmos pmos_uireg3  ( UIREG[3], UIREG3_zd, 0 );
  pmos pmos_uireg4  ( UIREG[4], UIREG4_zd, 0 );
  pmos pmos_uireg5  ( UIREG[5], UIREG5_zd, 0 );
  pmos pmos_uireg6  ( UIREG[6], UIREG6_zd, 0 );
  pmos pmos_uireg7  ( UIREG[7], UIREG7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
  pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
  pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
  pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );

  assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
  assign UTDI  = TDI_int;
  assign UDRCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UDRUPD_zd <= 0;
      UDRSH_zd  <= 0;
      UDRCAP_zd <= 0;
      URSTB_zd  <= 0;
    end else begin
      UDRUPD_zd <= ( STATE == `Update_DR        );
      UDRSH_zd  <= ( STATE == `Shift_DR         );
      UDRCAP_zd <= ( STATE == `Capture_DR       );
      URSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UTDO;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
    
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    (DEVRST_N => POWER_ON_RESET_N ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );

  endspecify

endmodule
//---- END MODULE UJTAG_SYSRESET ----

/*--------------------------------------------------------------------
NAME : UJTAG_SYSRESET_FF 
TYPE : IP
LOGIC: Simple TAP for simulation of designs using the IGLOO2 user JTAG interface
NOTES:
  1. This TAP is not a model of the actual TAP used in the IGLOO2. The
  only instruction implemented is BYPASS. An instruction scan operation
  will capture the pattern 8'bxxxxxx01
  2. This model should not be used for the A500K family, as it uses
  a different set of interface signals.
---------------------------------------------------------------------*/

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG_SYSRESET_FF ( UIREG,
               URSTB, UDRCK, UTDI, UDRCAP, UDRSH, UDRUPD, UTDO,
               TRSTB, TDO, TDI, TMS, TCK,
               DEVRST_N, POWER_ON_RESET_N, FF_TO_START, FF_DONE);

  output  [7:0] UIREG;
  output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, TDO;
  input   UTDO, TMS, TDI, TCK, TRSTB;
  input   DEVRST_N;
  output  POWER_ON_RESET_N;
  output FF_TO_START;
  output FF_DONE;
  
  assign FF_TO_START = 1'b0;
  assign FF_DONE = 1'b0;

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
  reg       NOTIFY_REG;

  reg reset_n_int;
  
  initial begin
    reset_n_int = 1'b1;
    #1;
    reset_n_int = 1'b0;
    #1000;
    reset_n_int = 1'b1;
  end
  
  and U0 ( POWER_ON_RESET_N, DEVRST_N, reset_n_int );
  
  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UTDO_int,  UTDO  );

  pmos pmos_uireg0  ( UIREG[0], UIREG0_zd, 0 );
  pmos pmos_uireg1  ( UIREG[1], UIREG1_zd, 0 );
  pmos pmos_uireg2  ( UIREG[2], UIREG2_zd, 0 );
  pmos pmos_uireg3  ( UIREG[3], UIREG3_zd, 0 );
  pmos pmos_uireg4  ( UIREG[4], UIREG4_zd, 0 );
  pmos pmos_uireg5  ( UIREG[5], UIREG5_zd, 0 );
  pmos pmos_uireg6  ( UIREG[6], UIREG6_zd, 0 );
  pmos pmos_uireg7  ( UIREG[7], UIREG7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
  pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
  pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
  pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );

  assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
  assign UTDI  = TDI_int;
  assign UDRCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UDRUPD_zd <= 0;
      UDRSH_zd  <= 0;
      UDRCAP_zd <= 0;
      URSTB_zd  <= 0;
    end else begin
      UDRUPD_zd <= ( STATE == `Update_DR        );
      UDRSH_zd  <= ( STATE == `Shift_DR         );
      UDRCAP_zd <= ( STATE == `Capture_DR       );
      URSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UTDO;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
    
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    (DEVRST_N => POWER_ON_RESET_N ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );

  endspecify

endmodule
//---- END MODULE UJTAG_SYSRESET_FF ----

/*--------------------------------------------------------------------
NAME : SYSRESET_FF 
TYPE : IP
LOGIC: Simple TAP for simulation of designs using the IGLOO2 user JTAG interface
NOTES:
  1. This TAP is not a model of the actual TAP used in the IGLOO2. The
  only instruction implemented is BYPASS. An instruction scan operation
  will capture the pattern 8'bxxxxxx01
  2. This model should not be used for the A500K family, as it uses
  a different set of interface signals.
---------------------------------------------------------------------*/

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module SYSRESET_FF ( UIREG,
               URSTB, UDRCK, UTDI, UDRCAP, UDRSH, UDRUPD, UTDO,
               TRSTB, TDO, TDI, TMS, TCK,
               DEVRST_N, POWER_ON_RESET_N, FF_TO_START, FF_DONE);

  output  [7:0] UIREG;
  output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, TDO;
  input   UTDO, TMS, TDI, TCK, TRSTB;
  input   DEVRST_N;
  output  POWER_ON_RESET_N;
  output FF_TO_START;
  output FF_DONE;
  
  assign FF_TO_START = 1'b0;
  assign FF_DONE = 1'b0;

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
  reg       NOTIFY_REG;

  reg reset_n_int;
  
  initial begin
    reset_n_int = 1'b1;
    #1;
    reset_n_int = 1'b0;
    #1000;
    reset_n_int = 1'b1;
  end
  
  and U0 ( POWER_ON_RESET_N, DEVRST_N, reset_n_int );
  
  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UTDO_int,  UTDO  );

  pmos pmos_uireg0  ( UIREG[0], UIREG0_zd, 0 );
  pmos pmos_uireg1  ( UIREG[1], UIREG1_zd, 0 );
  pmos pmos_uireg2  ( UIREG[2], UIREG2_zd, 0 );
  pmos pmos_uireg3  ( UIREG[3], UIREG3_zd, 0 );
  pmos pmos_uireg4  ( UIREG[4], UIREG4_zd, 0 );
  pmos pmos_uireg5  ( UIREG[5], UIREG5_zd, 0 );
  pmos pmos_uireg6  ( UIREG[6], UIREG6_zd, 0 );
  pmos pmos_uireg7  ( UIREG[7], UIREG7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
  pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
  pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
  pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );

  assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
  assign UTDI  = TDI_int;
  assign UDRCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UDRUPD_zd <= 0;
      UDRSH_zd  <= 0;
      UDRCAP_zd <= 0;
      URSTB_zd  <= 0;
    end else begin
      UDRUPD_zd <= ( STATE == `Update_DR        );
      UDRSH_zd  <= ( STATE == `Shift_DR         );
      UDRCAP_zd <= ( STATE == `Capture_DR       );
      URSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UTDO;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
    
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    (DEVRST_N => POWER_ON_RESET_N ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );

  endspecify

endmodule
//---- END MODULE SYSRESET_FF ----

/*--------------------------------------------------------------------
NAME : UJTAG_FF 
TYPE : IP
LOGIC: Simple TAP for simulation of designs using the IGLOO2 user JTAG interface
NOTES:
  1. This TAP is not a model of the actual TAP used in the IGLOO2. The
  only instruction implemented is BYPASS. An instruction scan operation
  will capture the pattern 8'bxxxxxx01
  2. This model should not be used for the A500K family, as it uses
  a different set of interface signals.
---------------------------------------------------------------------*/

`timescale 1ns/1ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG_FF ( UIREG,
               URSTB, UDRCK, UTDI, UDRCAP, UDRSH, UDRUPD, UTDO,
               TRSTB, TDO, TDI, TMS, TCK,
               DEVRST_N, POWER_ON_RESET_N, FF_TO_START, FF_DONE);

  output  [7:0] UIREG;
  output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, TDO;
  input   UTDO, TMS, TDI, TCK, TRSTB;
  input   DEVRST_N;
  output  POWER_ON_RESET_N;
  output FF_TO_START;
  output FF_DONE;
  
  assign FF_TO_START = 1'b0;
  assign FF_DONE = 1'b0;

  reg [3:0] STATE;
  reg [7:0] IR, SHREG;
  reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
  reg       NOTIFY_REG;

  reg reset_n_int;
  
  initial begin
    reset_n_int = 1'b1;
    #1;
    reset_n_int = 1'b0;
    #1000;
    reset_n_int = 1'b1;
  end
  
  and U0 ( POWER_ON_RESET_N, DEVRST_N, reset_n_int );
  
  buf  buf_tdi      ( TDI_int,   TDI   );
  buf  buf_tms      ( TMS_int,   TMS   );
  buf  buf_tck      ( TCK_int,   TCK   );
  buf  buf_trstb    ( TRSTB_int, TRSTB );
  buf  buf_utdo     ( UTDO_int,  UTDO  );

  pmos pmos_uireg0  ( UIREG[0], UIREG0_zd, 0 );
  pmos pmos_uireg1  ( UIREG[1], UIREG1_zd, 0 );
  pmos pmos_uireg2  ( UIREG[2], UIREG2_zd, 0 );
  pmos pmos_uireg3  ( UIREG[3], UIREG3_zd, 0 );
  pmos pmos_uireg4  ( UIREG[4], UIREG4_zd, 0 );
  pmos pmos_uireg5  ( UIREG[5], UIREG5_zd, 0 );
  pmos pmos_uireg6  ( UIREG[6], UIREG6_zd, 0 );
  pmos pmos_uireg7  ( UIREG[7], UIREG7_zd, 0 );

  pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
  pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
  pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
  pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
  pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );

  assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
  assign UTDI  = TDI_int;
  assign UDRCK = TCK_int;

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      UDRUPD_zd <= 0;
      UDRSH_zd  <= 0;
      UDRCAP_zd <= 0;
      URSTB_zd  <= 0;
    end else begin
      UDRUPD_zd <= ( STATE == `Update_DR        );
      UDRSH_zd  <= ( STATE == `Shift_DR         );
      UDRCAP_zd <= ( STATE == `Capture_DR       );
      URSTB_zd  <= ( STATE != `Test_Logic_Reset );
    end
  end

  always @( posedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      STATE <= `Test_Logic_Reset;
    end
    else begin
      case ( STATE )
        `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
        `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
        `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
        `Capture_DR,
        `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
        `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
        `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
        `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
        `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
        `Capture_IR,
        `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
        `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
        `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
        `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
        `Update_DR,
        `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
      endcase
    end
  end

  always @( posedge TCK_int ) begin
    case ( STATE )
      `Capture_IR : SHREG <=  8'bxxxxxx01;
      `Capture_DR : SHREG <=  8'b00000000;
      `Shift_IR,
      `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
    endcase
  end

  always @( negedge TCK_int or negedge TRSTB_int ) begin
    if ( !TRSTB_int ) begin
      IR  <= `Bypass;
      TDO_zd <= 'bz;
    end else if ( STATE == `Shift_IR )
      TDO_zd <= SHREG[0];
    else if ( STATE == `Shift_DR ) begin
      casez ( IR )
        8'b01??????,
        8'b0?1?????,
        8'b0??1????: TDO_zd <= UTDO;
        default    : TDO_zd <= SHREG[7];
      endcase
    end
    else if ( STATE == `Update_IR ) begin
      TDO_zd <= 'bz;
      IR  <= SHREG;
    end else begin
      TDO_zd <= 'bz;
    end
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
    
    specparam tpdLH_A_to_Y     = (0.01:0.01:0.01);
    specparam tpdHL_A_to_Y     = (0.01:0.01:0.01);
    (DEVRST_N => POWER_ON_RESET_N ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );

  endspecify

endmodule
//---- END MODULE UJTAG_FF ----

`timescale 1 ps/1 ps
module SYSRESET(input DEVRST_N,
                output POWER_ON_RESET_N);
      
  reg reset_n_int;
  
  initial begin
    reset_n_int = 1'b1;
    #1;
    reset_n_int = 1'b0;
    #1000;
    reset_n_int = 1'b1;
  end
  
  and U0 ( POWER_ON_RESET_N, DEVRST_N, reset_n_int );
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_Y     = (10:10:10);
    specparam tpdHL_A_to_Y     = (10:10:10);
    
    (DEVRST_N => POWER_ON_RESET_N ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
  endspecify
endmodule


/*--------------------------------------------------------------------
 CELL NAME : RCOSC_25_50MHZ
---------------------------------------------------------------------*/
`timescale 1 ps/1 ps
module RCOSC_25_50MHZ  (CLKOUT);

  output CLKOUT;
  reg CLKOUT_25M, CLKOUT_50M;
  parameter real FREQUENCY = 50.0;
  
  assign CLKOUT = (FREQUENCY == 50.0) ? CLKOUT_50M : CLKOUT_25M;
  always begin
    forever begin
      CLKOUT_50M = 1'b1;
      # 10000;
      CLKOUT_50M = 1'b0;
      # 10000;
    end
  end
  
  always begin
    forever begin
      CLKOUT_25M = 1'b1;
      # 20000;
      CLKOUT_25M = 1'b0;
      # 20000;
    end
  end
endmodule

/*--------------------------------------------------------------------
 CELL NAME : RCOSC_1MHZ
---------------------------------------------------------------------*/
`timescale 1 ps/1 ps
module RCOSC_1MHZ  (CLKOUT);

  output reg CLKOUT;

  always begin
    forever begin
      CLKOUT = 1'b1;
      # 500000;
      CLKOUT = 1'b0;
      # 500000;
    end
  end
endmodule

/*--------------------------------------------------------------------
 CELL NAME : XTLOSC 
---------------------------------------------------------------------*/
`timescale 1 ps/1 ps
module XTLOSC (XTL,
               CLKOUT);

  output CLKOUT;
  input  XTL;
  parameter real FREQUENCY = 20.0;
  parameter [1:0] MODE = 2'h3;

  `define PW_limit0 15625000  // 0.032MHz
  `define PW_limit1  6666667  // 0.075MHz  --> should be 6666666.667
  `define PW_limit2   250000  // 2MHz
  `define PW_limit3    25000  // 20MHz

  wire XTL_int;
  wire SELMODE_int;
  wire [ 1 : 0 ] RTCMODE_int;
  reg  CLKOUT_int;
  reg  XTL_last_value = 1'bx;

  reg  chk_PW  = 1'b0;
  time min_PW;
  time max_PW;
  time PW;
  time XTL_last_change = 0;

  buf U0 ( XTL_int, XTL );
  buf U3 ( CLKOUT, CLKOUT_int );

  always @( * )
  begin
    case ( MODE )
      2'b00 :
      begin
        chk_PW = 1'b0;
      end
      2'b01 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit0;
        min_PW = `PW_limit1;
      end
      2'b10 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit1;
        min_PW = `PW_limit2;
      end
      2'b11 :
      begin
        chk_PW = 1'b1;
        max_PW = `PW_limit2;
        min_PW = `PW_limit3;
      end
      default:
      begin
        chk_PW = 1'b1;
        max_PW = 0;
        $display( "Mode is unknown, unable to determine acceptable frequency range - no acceptable input frequencies at time %10g", $realtime);
      end
    endcase
  end

  always @( XTL_int )
  begin
    PW = $time - XTL_last_change;
    if ( XTL_int === 1'bx ) begin
      CLKOUT_int = 1'bx;
    end else if ( chk_PW === 1'b1 &&
                  ( ( PW > max_PW ) || ( PW < min_PW ) ) &&
                  ( XTL_last_change > 0 ) ) begin
      CLKOUT_int = 1'b0;
      $display( "XTL frequency not within acceptable frequency range at time %10g", $realtime);
    end 
    else begin
      CLKOUT_int = XTL_int;
    end

    XTL_last_change = $time;
    XTL_last_value = XTL_int;
  end

  specify
    specparam PATHPULSE$     = (0.001, 0.001);

    specparam tpdLH_XTL_to_CLKOUT = ( 100 : 100 : 100 );
    specparam tpdHL_XTL_to_CLKOUT = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( XTL => CLKOUT ) = ( tpdLH_XTL_to_CLKOUT, tpdHL_XTL_to_CLKOUT );
  
  endspecify

endmodule




module RCOSC_1MHZ_FAB(output CLKOUT,
                      input A);

  buf U0(CLKOUT, A);
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_CLKOUT = (0.01:0.01:0.01);
    specparam tpdHL_A_to_CLKOUT = (0.01:0.01:0.01);

    //pin to pin path delay
    (A => CLKOUT ) = ( tpdLH_A_to_CLKOUT, tpdHL_A_to_CLKOUT );
  endspecify
endmodule

module RCOSC_25_50MHZ_FAB(output CLKOUT,
                          input A);
  buf U0(CLKOUT, A);
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_CLKOUT = (0.01:0.01:0.01);
    specparam tpdHL_A_to_CLKOUT = (0.01:0.01:0.01);

    //pin to pin path delay
    (A => CLKOUT ) = ( tpdLH_A_to_CLKOUT, tpdHL_A_to_CLKOUT );
  endspecify
endmodule

module XTLOSC_FAB(output CLKOUT,
                  input A);
  buf U0(CLKOUT, A);
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    specparam tpdLH_A_to_CLKOUT = (0.01:0.01:0.01);
    specparam tpdHL_A_to_CLKOUT = (0.01:0.01:0.01);

    //pin to pin path delay
    (A => CLKOUT ) = ( tpdLH_A_to_CLKOUT, tpdHL_A_to_CLKOUT );
  endspecify
endmodule


module FLASH_FREEZE(output FF_TO_START,
                    output FF_DONE);
  
  assign FF_TO_START = 1'b0;
  assign FF_DONE = 1'b0;

endmodule


/* ODT Modules */

module ODT_DYNAMIC (input A);
  parameter ODT_BANK = -1;
endmodule


`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module ODT_DYNAMIC_UNIT (output Q,
                         output QRDn,
                         input ADn,
                         input ALn,
                         input CLK,
                         input DRn,
                         input DFn,
                         input SDR,
                         input LAT,
                         input SD,
                         input EN,
                         input SLn);

  parameter ODT_BANK = -1;
  reg NOTIFY_REG;

  IOOEFF_TEST_UNIT u0(.Q(), .QRDn(),
                      .ADn (ADn),
                      .ALn (ALn),
                      .CLK (CLK),
                      .DRn (DRn),
                      .DFn (DFn),
                      .SDR (SDR),
                      .LAT (LAT),
                      .SD  (SD),
                      .EN  (EN),
                      .SLn (SLn));
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


  
`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module TAMPER (output       JTAG_ACTIVE,
               output       LOCK_TAMPER_DETECT,
               output       MESH_SHORT_ERROR,
               output       CLK_ERROR,
               output [3:0] DETECT_CATEGORY,
               output       DETECT_ATTEMPT,
               output       DETECT_FAIL,               
               output       DIGEST_ERROR,
               output       POWERUP_DIGEST_ERROR,
               output       SC_ROM_DIGEST_ERROR,
               output       TAMPER_CHANGE_STROBE,
               input        LOCKDOWN_ALL_N,
               input        DISABLE_ALL_IOS_N,
               input        RESET_N,
               input        ZEROIZE_N );

  parameter ZEROIZE_CONFIG = "";
  parameter POWERUP_DIGEST_ERROR_CONFIG = "";
  parameter CLK_ERROR_CONFIG            = 0;

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module FF_TAMPER_RSTATUS(output   FF_TO_START, 
                         output   FF_DONE, 
                         output   JTAG_ACTIVE, 
                         output   LOCK_TAMPER_DETECT, 
                         output   MESH_SHORT_ERROR, 
                         output   CLK_ERROR, 
                         output [3:0] DETECT_CATEGORY,
                         output   DETECT_ATTEMPT, 
                         output   DETECT_FAIL, 
                         output   DIGEST_ERROR, 
                         output   POWERUP_DIGEST_ERROR, 
                         output   SC_ROM_DIGEST_ERROR, 
                         output   TAMPER_CHANGE_STROBE, 
                         output   RESET_STATUS, 
                         input    LOCKDOWN_ALL_N, 
                         input    DISABLE_ALL_IOS_N, 
                         input    RESET_N, 
                         input    ZEROIZE_N);

  parameter ZEROIZE_CONFIG = "";
  parameter POWERUP_DIGEST_ERROR_CONFIG = "";
  parameter CLK_ERROR_CONFIG            = 0;
  
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SYSRESET_FF_TAMPER_RSTATUS(output    POWER_ON_RESET_N, 
                                  output    FF_TO_START, 
                                  output    FF_DONE, 
                                  output    JTAG_ACTIVE, 
                                  output    LOCK_TAMPER_DETECT, 
                                  output    MESH_SHORT_ERROR, 
                                  output    CLK_ERROR, 
                                  output [3:0] DETECT_CATEGORY,
                                  output    DETECT_ATTEMPT, 
                                  output    DETECT_FAIL, 
                                  output    DIGEST_ERROR, 
                                  output    POWERUP_DIGEST_ERROR, 
                                  output    SC_ROM_DIGEST_ERROR, 
                                  output    TAMPER_CHANGE_STROBE, 
                                  output    RESET_STATUS, 
                                  input     LOCKDOWN_ALL_N, 
                                  input     DISABLE_ALL_IOS_N, 
                                  input     RESET_N, 
                                  input     ZEROIZE_N, 
                                  input     DEVRST_N );

  parameter ZEROIZE_CONFIG = "";
  parameter POWERUP_DIGEST_ERROR_CONFIG = "";
  parameter CLK_ERROR_CONFIG            = 0;
  
  SYSRESET u0(.DEVRST_N           (DEVRST_N), 
              .POWER_ON_RESET_N   (POWER_ON_RESET_N));
  
  FF_TAMPER_RSTATUS #(.ZEROIZE_CONFIG(ZEROIZE_CONFIG),
                      .POWERUP_DIGEST_ERROR_CONFIG(POWERUP_DIGEST_ERROR_CONFIG),
                      .CLK_ERROR_CONFIG(CLK_ERROR_CONFIG))
                    u1 (.FF_TO_START                (FF_TO_START), 
                        .FF_DONE                    (FF_DONE), 
                        .JTAG_ACTIVE                (JTAG_ACTIVE), 
                        .LOCK_TAMPER_DETECT         (LOCK_TAMPER_DETECT), 
                        .MESH_SHORT_ERROR           (MESH_SHORT_ERROR), 
                        .CLK_ERROR                  (CLK_ERROR), 
                        .DETECT_CATEGORY            (DETECT_CATEGORY),
                        .DETECT_ATTEMPT             (DETECT_ATTEMPT), 
                        .DETECT_FAIL                (DETECT_FAIL), 
                        .DIGEST_ERROR               (DIGEST_ERROR), 
                        .POWERUP_DIGEST_ERROR       (POWERUP_DIGEST_ERROR),
                        .SC_ROM_DIGEST_ERROR           (SC_ROM_DIGEST_ERROR), 
                        .TAMPER_CHANGE_STROBE                      (TAMPER_CHANGE_STROBE),                         
                        .RESET_STATUS               (RESET_STATUS), 
                        .LOCKDOWN_ALL_N             (LOCKDOWN_ALL_N), 
                        .DISABLE_ALL_IOS_N          (DISABLE_ALL_IOS_N), 
                        .RESET_N                    (RESET_N), 
                        .ZEROIZE_N                  (ZEROIZE_N) );

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module UJTAG_FF_TAMPER_RSTATUS (input         UTDO, 
                                input         TDI, 
                                input         TMS, 
                                input         TCK, 
                                input         TRSTB,
                                input         LOCKDOWN_ALL_N, 
                                input         DISABLE_ALL_IOS_N, 
                                input         RESET_N, 
                                input         ZEROIZE_N,
                                output        TDO, 
                                output        UDRCAP, 
                                output        UDRSH, 
                                output        UDRUPD, 
                                output [7:0]  UIREG, 
                                output        URSTB, 
                                output        UDRCK, 
                                output        UTDI, 
                                output        FF_TO_START, 
                                output        FF_DONE, 
                                output        JTAG_ACTIVE, 
                                output        LOCK_TAMPER_DETECT, 
                                output        MESH_SHORT_ERROR, 
                                output        CLK_ERROR, 
                                output [3:0]  DETECT_CATEGORY,
                                output        DETECT_ATTEMPT, 
                                output        DETECT_FAIL, 
                                output        DIGEST_ERROR, 
                                output        POWERUP_DIGEST_ERROR, 
                                output        SC_ROM_DIGEST_ERROR, 
                                output        TAMPER_CHANGE_STROBE, 
                                output        RESET_STATUS);

  parameter ZEROIZE_CONFIG = "";
  parameter POWERUP_DIGEST_ERROR_CONFIG = "";
  parameter CLK_ERROR_CONFIG            = 0;
  reg       NOTIFY_REG;
  
  FF_TAMPER_RSTATUS #(.ZEROIZE_CONFIG(ZEROIZE_CONFIG),
                      .POWERUP_DIGEST_ERROR_CONFIG(POWERUP_DIGEST_ERROR_CONFIG),
                      .CLK_ERROR_CONFIG(CLK_ERROR_CONFIG))
                    u1 (.FF_TO_START                (FF_TO_START), 
                        .FF_DONE                    (FF_DONE), 
                        .JTAG_ACTIVE                (JTAG_ACTIVE), 
                        .LOCK_TAMPER_DETECT         (LOCK_TAMPER_DETECT), 
                        .MESH_SHORT_ERROR           (MESH_SHORT_ERROR), 
                        .CLK_ERROR                  (CLK_ERROR), 
                        .DETECT_CATEGORY            (DETECT_CATEGORY),
                        .DETECT_ATTEMPT             (DETECT_ATTEMPT), 
                        .DETECT_FAIL                (DETECT_FAIL), 
                        .DIGEST_ERROR               (DIGEST_ERROR), 
                        .POWERUP_DIGEST_ERROR       (POWERUP_DIGEST_ERROR),
                        .SC_ROM_DIGEST_ERROR           (SC_ROM_DIGEST_ERROR), 
                        .TAMPER_CHANGE_STROBE                      (TAMPER_CHANGE_STROBE),                         
                        .RESET_STATUS               (RESET_STATUS), 
                        .LOCKDOWN_ALL_N             (LOCKDOWN_ALL_N), 
                        .DISABLE_ALL_IOS_N          (DISABLE_ALL_IOS_N), 
                        .RESET_N                    (RESET_N), 
                        .ZEROIZE_N                  (ZEROIZE_N) );

  UJTAG u2 (.UIREG        (UIREG[7:0]),
            .URSTB        (URSTB), 
            .UDRCK        (UDRCK), 
            .UTDI         (UTDI), 
            .UDRCAP       (UDRCAP), 
            .UDRSH        (UDRSH), 
            .UDRUPD       (UDRUPD), 
            .UTDO         (UTDO),
            .TRSTB        (TRSTB), 
            .TDO          (TDO), 
            .TDI          (TDI), 
            .TMS          (TMS), 
            .TCK          (TCK) );
            
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
  endspecify
               
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults



`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module UJTAG_SYSRESET_FF_TAMPER_RSTATUS(input         UTDO, 
                                        input         TDI, 
                                        input         TMS, 
                                        input         TCK, 
                                        input         TRSTB,
                                        input         LOCKDOWN_ALL_N, 
                                        input         DISABLE_ALL_IOS_N, 
                                        input         RESET_N, 
                                        input         ZEROIZE_N,
                                        input         DEVRST_N,
                                        output        TDO, 
                                        output        UDRCAP, 
                                        output        UDRSH, 
                                        output        UDRUPD, 
                                        output [7:0]  UIREG, 
                                        output        URSTB, 
                                        output        UDRCK, 
                                        output        UTDI, 
                                        output        FF_TO_START, 
                                        output        FF_DONE, 
                                        output        JTAG_ACTIVE, 
                                        output        LOCK_TAMPER_DETECT, 
                                        output        MESH_SHORT_ERROR, 
                                        output        CLK_ERROR, 
                                        output [3:0]  DETECT_CATEGORY,
                                        output        DETECT_ATTEMPT, 
                                        output        DETECT_FAIL, 
                                        output        DIGEST_ERROR, 
                                        output        POWERUP_DIGEST_ERROR, 
                                        output        RESET_STATUS,
                                        output        SC_ROM_DIGEST_ERROR, 
                                        output        TAMPER_CHANGE_STROBE, 
                                        output        POWER_ON_RESET_N);

  parameter ZEROIZE_CONFIG = "";
  parameter POWERUP_DIGEST_ERROR_CONFIG = "";
  parameter CLK_ERROR_CONFIG            = 0;
  reg       NOTIFY_REG;
  
  SYSRESET u0(.DEVRST_N           (DEVRST_N), 
              .POWER_ON_RESET_N   (POWER_ON_RESET_N));
  
  FF_TAMPER_RSTATUS #(.ZEROIZE_CONFIG(ZEROIZE_CONFIG),
                      .POWERUP_DIGEST_ERROR_CONFIG(POWERUP_DIGEST_ERROR_CONFIG),
                      .CLK_ERROR_CONFIG(CLK_ERROR_CONFIG)) 
                    u1 (.FF_TO_START                (FF_TO_START), 
                        .FF_DONE                    (FF_DONE), 
                        .JTAG_ACTIVE                (JTAG_ACTIVE), 
                        .LOCK_TAMPER_DETECT         (LOCK_TAMPER_DETECT), 
                        .MESH_SHORT_ERROR           (MESH_SHORT_ERROR), 
                        .CLK_ERROR                  (CLK_ERROR), 
                        .DETECT_CATEGORY            (DETECT_CATEGORY),
                        .DETECT_ATTEMPT             (DETECT_ATTEMPT), 
                        .DETECT_FAIL                (DETECT_FAIL), 
                        .DIGEST_ERROR               (DIGEST_ERROR), 
                        .POWERUP_DIGEST_ERROR       (POWERUP_DIGEST_ERROR),
                        .SC_ROM_DIGEST_ERROR           (SC_ROM_DIGEST_ERROR), 
                        .TAMPER_CHANGE_STROBE                      (TAMPER_CHANGE_STROBE),                         
                        .RESET_STATUS               (RESET_STATUS), 
                        .LOCKDOWN_ALL_N             (LOCKDOWN_ALL_N), 
                        .DISABLE_ALL_IOS_N          (DISABLE_ALL_IOS_N), 
                        .RESET_N                    (RESET_N), 
                        .ZEROIZE_N                  (ZEROIZE_N) );

  UJTAG u2 (.UIREG        (UIREG[7:0]),
            .URSTB        (URSTB), 
            .UDRCK        (UDRCK), 
            .UTDI         (UTDI), 
            .UDRCAP       (UDRCAP), 
            .UDRSH        (UDRSH), 
            .UDRUPD       (UDRUPD), 
            .UTDO         (UTDO),
            .TRSTB        (TRSTB), 
            .TDO          (TDO), 
            .TDI          (TDI), 
            .TMS          (TMS), 
            .TCK          (TCK) );

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    (negedge TCK   => (UIREG[0]+:UIREG[0]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[1]+:UIREG[1]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[2]+:UIREG[2]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[3]+:UIREG[3]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[4]+:UIREG[4]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[5]+:UIREG[5]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[6]+:UIREG[6]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UIREG[7]+:UIREG[7]) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (UIREG[0]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[1]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[2]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[3]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[4]+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[5]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[6]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UIREG[7]+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
    (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

    (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

    $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

    $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
    $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

    $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
    $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

    $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
    $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

    $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
    $width(posedge TCK, 0.0, 0, NOTIFY_REG);
    $width(negedge TCK, 0.0, 0, NOTIFY_REG);
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps
module SYSCTRL_RESET_STATUS(output        RESET_STATUS);
  
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults



/********************************************************************
        CCC
        NOTE: This file was automatically generated
*********************************************************************/

`timescale 1 ps/1 ps

module CCC_CONFIG(PCLK, PRESET_N, PSEL, PWRITE, PENABLE, PWDATA, PADDR, PRDATA,
                  CORE_LOCK,
                  RF_SEL, RF_INV, RF_DIV, FB_SEL, FB_INV, FB_DIV,
                  GLMUX0_SEL, GLMUX1_SEL, GLMUX2_SEL, GLMUX3_SEL,
                  GLMUX0_INV, GLMUX1_INV, GLMUX2_INV, GLMUX3_INV,
                  GLMUX0_BUSY, GLMUX1_BUSY, GLMUX2_BUSY, GLMUX3_BUSY,
                  GLMUX0_SELOUT, GLMUX1_SELOUT, GLMUX2_SELOUT, GLMUX3_SELOUT,
                  GPD0_SEL, GPD0_INV, GPD0_DIV, GPD0_NOPIPE_RSTSYNC,
                  GPD1_SEL, GPD1_INV, GPD1_DIV, GPD1_NOPIPE_RSTSYNC,
                  GPD2_SEL, GPD2_INV, GPD2_DIV, GPD2_NOPIPE_RSTSYNC,
                  GPD3_SEL, GPD3_INV, GPD3_DIV, GPD3_NOPIPE_RSTSYNC,
                  GPD_SWRESYNC,
                  PLL_LOCKWIN, PLL_LOCKCNT,
                  PLL_FBSEL, PLL_SSE, PLL_SSMD, PLL_SSMF,
                  PLL_MODE_32K, PLL_MODE_1V2, PLL_MODE_3V3,
                  PLL_RANGE, PLL_FBDIV, PLL_CLKDIV, PLL_VCODIV,
                  GPD0_G3STYLE_N, GPD0_SRESETGENEN, GPD0_RESETGENEN,
                  GPD1_G3STYLE_N, GPD1_SRESETGENEN, GPD1_RESETGENEN,
                  GPD2_G3STYLE_N, GPD2_SRESETGENEN, GPD2_RESETGENEN,
                  GPD3_G3STYLE_N, GPD3_SRESETGENEN, GPD3_RESETGENEN,
                  DELAY_LINE_SET, DELAY_LINE_RF,                  
                  OVWR_SEL_RESET, OVWR_VAL_RESET,OVWR_SEL_PD, OVWR_VAL_PD,
                  OVWR_SEL_BYPASS, OVWR_VAL_BYPASS,OVWR_SEL_GL, OVWR_VAL_GL);

  input           PCLK, PRESET_N, PSEL, PWRITE, PENABLE;
  input   [7:0]   PWDATA;
  input   [7:2]   PADDR;
  output  [7:0]   PRDATA;

  input           CORE_LOCK;
  output          RF_INV, FB_INV;
  output  [3:0]   RF_SEL;
  output  [7:0]   RF_DIV;
  output  [3:0]   FB_SEL;
  output  [13:0]  FB_DIV;
  output  [9:0]  GLMUX0_SEL;
  output  [9:0]  GLMUX1_SEL;
  output  [9:0]  GLMUX2_SEL;
  output  [9:0]  GLMUX3_SEL;
  output          GLMUX0_INV, GLMUX1_INV, GLMUX2_INV, GLMUX3_INV;
  input           GLMUX0_BUSY, GLMUX1_BUSY, GLMUX2_BUSY, GLMUX3_BUSY;
  output          GLMUX0_SELOUT, GLMUX1_SELOUT, GLMUX2_SELOUT, GLMUX3_SELOUT;
  output          GPD0_INV, GPD0_NOPIPE_RSTSYNC;
  output          GPD1_INV, GPD1_NOPIPE_RSTSYNC;
  output          GPD2_INV, GPD2_NOPIPE_RSTSYNC;
  output          GPD3_INV, GPD3_NOPIPE_RSTSYNC;
  output  [4:0]   GPD0_SEL;
  output  [4:0]   GPD1_SEL;
  output  [4:0]   GPD2_SEL;
  output  [4:0]   GPD3_SEL;
  output  [7:0]   GPD0_DIV;
  output  [7:0]   GPD1_DIV;
  output  [7:0]   GPD2_DIV;
  output  [7:0]   GPD3_DIV;
  
  output  [2:0]   PLL_LOCKWIN;
  output  [3:0]   PLL_LOCKCNT;
  output          GPD_SWRESYNC;
  output          GPD0_G3STYLE_N, GPD0_SRESETGENEN, GPD0_RESETGENEN;
  output          GPD1_G3STYLE_N, GPD1_SRESETGENEN, GPD1_RESETGENEN;
  output          GPD2_G3STYLE_N, GPD2_SRESETGENEN, GPD2_RESETGENEN;
  output          GPD3_G3STYLE_N, GPD3_SRESETGENEN, GPD3_RESETGENEN;
  output          DELAY_LINE_RF;
  output  [5:0]   DELAY_LINE_SET;

  output          PLL_FBSEL, PLL_SSE;
  output  [1:0]   PLL_SSMD;
  output  [4:0]   PLL_SSMF;
  output          PLL_MODE_32K, PLL_MODE_1V2, PLL_MODE_3V3;
  output  [3:0]   PLL_RANGE;
  output  [7:0]   PLL_FBDIV;
  output  [5:0]   PLL_CLKDIV;
  output  [2:0]   PLL_VCODIV;

  output          OVWR_SEL_RESET, OVWR_VAL_RESET,OVWR_SEL_PD, OVWR_VAL_PD;
  output          OVWR_SEL_BYPASS, OVWR_VAL_BYPASS,OVWR_SEL_GL, OVWR_VAL_GL;

  parameter [209:0] CONFIG = 210'b0;
  parameter         VCOFREQUENCY  = 0.0;
  parameter         WARNING_MSGS_ON = 1;  // Used to turn off warnings about read &
                                          // write to same address at same time.
                                          // Default = on.  Set to 0 to turn them off.
  reg NOTIFY_REG;
  
  reg [7:0] REGISTERS  [0:42];

  reg     [1:0]   APB_state;
  reg             PCLK_lat, PRESET_N_lat, PSEL_lat, PWRITE_lat, PENABLE_lat;
  reg     [7:0]   PWDATA_lat;
  reg     [7:2]   PADDR_lat;
  reg     [7:0]   PRDATA_reg;

  `define APB_IDLE    0
  `define APB_SETUP   1
  `define APB_ENABLE  2
  `define APB_RESET   3

  assign PRDATA = PRDATA_reg;

  assign RF_SEL[3:0]          = REGISTERS['h1][3:0];
  assign RF_INV               = REGISTERS['h1][4];
  assign RF_DIV[7:0]          = REGISTERS['h2][7:0];

  assign FB_SEL[3:0]          = REGISTERS['h3][3:0];
  assign FB_INV               = REGISTERS['h3][4];
  assign FB_DIV[13:0]         = {REGISTERS['h5][5:0], REGISTERS['h4][7:0]};

  assign GLMUX0_SEL[9:0]      = {REGISTERS['h7][4:0], REGISTERS['h6][4:0]};
  assign GLMUX0_INV           = REGISTERS['h7][5];
  assign GLMUX0_SELOUT        = REGISTERS['h7][6];

  assign GLMUX1_SEL[9:0]      = {REGISTERS['h9][4:0], REGISTERS['h8][4:0]};
  assign GLMUX1_INV           = REGISTERS['h9][5];
  assign GLMUX1_SELOUT        = REGISTERS['h9][6];

  assign GLMUX2_SEL[9:0]      = {REGISTERS['hB][4:0], REGISTERS['hA][4:0]};
  assign GLMUX2_INV           = REGISTERS['hB][5];
  assign GLMUX2_SELOUT        = REGISTERS['hB][6];

  assign GLMUX3_SEL[9:0]      = {REGISTERS['hD][4:0], REGISTERS['hC][4:0]};
  assign GLMUX3_INV           = REGISTERS['hD][5];
  assign GLMUX3_SELOUT        = REGISTERS['hD][6];

  assign GPD0_SEL[4:0]        = REGISTERS['hE][4:0];
  assign GPD0_INV             = REGISTERS['hE][5];
  assign GPD0_NOPIPE_RSTSYNC  = REGISTERS['hE][6];

  assign GPD1_SEL[4:0]        = REGISTERS['hF][4:0];
  assign GPD1_INV             = REGISTERS['hF][5];
  assign GPD1_NOPIPE_RSTSYNC  = REGISTERS['hF][6];

  assign GPD2_SEL[4:0]        = REGISTERS['h10][4:0];
  assign GPD2_INV             = REGISTERS['h10][5];
  assign GPD2_NOPIPE_RSTSYNC  = REGISTERS['h10][6];

  assign GPD3_SEL[4:0]        = REGISTERS['h11][4:0];
  assign GPD3_INV             = REGISTERS['h11][5];
  assign GPD3_NOPIPE_RSTSYNC  = REGISTERS['h11][6];

  assign GPD0_DIV[7:0]        = REGISTERS['h12][7:0];
  assign GPD1_DIV[7:0]        = REGISTERS['h13][7:0];
  assign GPD2_DIV[7:0]        = REGISTERS['h14][7:0];
  assign GPD3_DIV[7:0]        = REGISTERS['h15][7:0];

  assign PLL_LOCKWIN[2:0]     = REGISTERS['h16][2:0];
  assign PLL_LOCKCNT[3:0]     = REGISTERS['h17][3:0];

  assign PLL_SSMF[4:0]        = REGISTERS['h18][4:0];
  assign PLL_SSMD[1:0]        = REGISTERS['h19][1:0];
  assign PLL_SSE              = REGISTERS['h1A][0];
  assign PLL_MODE_32K         = REGISTERS['h1B][0];
  assign PLL_MODE_1V2         = REGISTERS['h1B][1];
  assign PLL_MODE_3V3         = REGISTERS['h1B][2];
  assign PLL_FBSEL            = REGISTERS['h1C][0];

  assign GPD_SWRESYNC         = REGISTERS['h1D][0];

  assign PLL_VCODIV[2:0]      = REGISTERS['h1E][2:0];
  assign PLL_CLKDIV[5:0]      = REGISTERS['h1F][5:0];
  assign PLL_FBDIV[7:0]       = REGISTERS['h20][7:0];
  assign PLL_RANGE[3:0]       = REGISTERS['h21][3:0];

  assign GPD0_G3STYLE_N       = REGISTERS['h22][2];
  assign GPD0_SRESETGENEN     = REGISTERS['h22][1];
  assign GPD0_RESETGENEN      = REGISTERS['h22][0];

  assign GPD1_G3STYLE_N       = REGISTERS['h23][2];
  assign GPD1_SRESETGENEN     = REGISTERS['h23][1];
  assign GPD1_RESETGENEN      = REGISTERS['h23][0];

  assign GPD2_G3STYLE_N       = REGISTERS['h24][2];
  assign GPD2_SRESETGENEN     = REGISTERS['h24][1];
  assign GPD2_RESETGENEN      = REGISTERS['h24][0];

  assign GPD3_G3STYLE_N       = REGISTERS['h25][2];
  assign GPD3_SRESETGENEN     = REGISTERS['h25][1];
  assign GPD3_RESETGENEN      = REGISTERS['h25][0];

  assign DELAY_LINE_SET[5:0]  = REGISTERS['h26][5:0];
  assign DELAY_LINE_RF        = REGISTERS['h26][6];


  assign OVWR_SEL_RESET       = REGISTERS['h27][0];
  assign OVWR_VAL_RESET       = REGISTERS['h27][1];

  assign OVWR_SEL_PD          = REGISTERS['h28][0];
  assign OVWR_VAL_PD          = REGISTERS['h28][1];

  assign OVWR_SEL_BYPASS      = REGISTERS['h29][0];
  assign OVWR_VAL_BYPASS      = REGISTERS['h29][1];

  assign OVWR_SEL_GL          = REGISTERS['h2A][0];
  assign OVWR_VAL_GL          = REGISTERS['h2A][1];

  
  wire [5:0] ovrd_addr;
  assign ovr_raddr = REGISTERS[0][7];
  assign ovrd_addr[5:0] = REGISTERS[0][5:0];
  
  initial begin
    REGISTERS[2][7:0]                         = CONFIG[7:0];     // REF_DIV
    {REGISTERS[5][5:0], REGISTERS[4][7:0]}    = CONFIG[21:8];    // FB_DIV
    REGISTERS[18][7:0]                        = CONFIG[29:22];   // GB_DIV0
    REGISTERS[19][7:0]                        = CONFIG[37:30];   // GB_DIV1
    REGISTERS[20][7:0]                        = CONFIG[45:38];   // GB_DIV2
    REGISTERS[21][7:0]                        = CONFIG[53:46];   // GB_DIV3
    REGISTERS[1][3:0]                         = CONFIG[57:54];   // REF_SEL
    REGISTERS[3][3:0]                         = CONFIG[61:58];   // FB_SEL
    {REGISTERS[14][4:0], REGISTERS[14][5]}    = {CONFIG[66:62], CONFIG[188]};   // GPD0_SEL and GPD0_INV
    {REGISTERS[15][4:0], REGISTERS[15][5]}    = {CONFIG[71:67], CONFIG[189]};   // GPD1_SEL and GPD1_INV
    {REGISTERS[16][4:0], REGISTERS[16][5]}    = {CONFIG[76:72], CONFIG[190]};   // GPD2_SEL and GPD2_INV
    {REGISTERS[17][4:0], REGISTERS[17][5]}    = {CONFIG[81:77], CONFIG[191]};   // GPD3_SEL and GPD3_INV
    {REGISTERS[7][4:0], REGISTERS[6][4:0]}    = CONFIG[91:82];         // GLMUX0_SEL
    {REGISTERS[9][4:0], REGISTERS[8][4:0]}    = CONFIG[101:92];        // GLMUX1_SEL
    {REGISTERS[11][4:0], REGISTERS[10][4:0]}  = CONFIG[111:102];       // GLMUX2_SEL
    {REGISTERS[13][4:0], REGISTERS[12][4:0]}  = CONFIG[121:112];       // GLMUX3_SEL
    REGISTERS[34][0]                          = CONFIG[122];           // GPD0_RESETGENEN
    REGISTERS[35][0]                          = CONFIG[123];           // GPD1_RESETGENEN
    REGISTERS[36][0]                          = CONFIG[124];           // GPD2_RESETGENEN
    REGISTERS[37][0]                          = CONFIG[125];           // GPD3_RESETGENEN
    REGISTERS[1][4]                           = CONFIG[126];           // RFMUX_INV
    REGISTERS[3][4]                           = CONFIG[127];           // FBMUX_INV
    REGISTERS[7][5]                           = CONFIG[128];           // GLMUX0_INV
    REGISTERS[9][5]                           = CONFIG[129];           // GLMUX1_INV
    REGISTERS[11][5]                          = CONFIG[130];           // GLMUX2_INV
    REGISTERS[13][5]                          = CONFIG[131];           // GLMUX3_INV
    REGISTERS[38][5:0]                        = CONFIG[137:132];       // DELAY_LINE_SET
    REGISTERS[38][6]                          = CONFIG[138];           // DELAY_LINE_RF
    REGISTERS[22][2:0]                        = CONFIG[141:139];       // PLL_LOCKWIN
    REGISTERS[23][3:0]                        = CONFIG[145:142];       // PLL_LOCKCNT
    REGISTERS[30][2:0]                        = CONFIG[148:146];       // PLL_VCODIV
    REGISTERS[27][2:0]                        = CONFIG[151:149];       // PLL_MODE_3v3,PLL_MODE_1v2,PLL_MODE32K
    REGISTERS[28][0]                          = CONFIG[152];           // PLL_FSE
    REGISTERS[26][0]                          = CONFIG[153];           // PLL_SSE
    REGISTERS[25][1:0]                        = CONFIG[155:154];       // PLL_SSMD
    REGISTERS[24][4:0]                        = CONFIG[160:156];       // PLL_SSMF
    REGISTERS[31][5:0]                        = CONFIG[166:161];       // PLL_DIVR
    REGISTERS[32][7:0]                        = CONFIG[174:167];       // PLL_DIVF
    REGISTERS[33][3:0]                        = CONFIG[178:175];       // PLL_RANGE

    REGISTERS[14][6]                          = CONFIG[179];           // GPD0_NOPIPE_RSTSYNC
    REGISTERS[15][6]                          = CONFIG[180];           // GPD1_NOPIPE_RSTSYNC
    REGISTERS[16][6]                          = CONFIG[181];           // GPD2_NOPIPE_RSTSYNC
    REGISTERS[17][6]                          = CONFIG[182];           // GPD3_NOPIPE_RSTSYNC
    REGISTERS[34][1]                          = CONFIG[183];           // GPD0_SRESETGENEN
    REGISTERS[35][1]                          = CONFIG[184];           // GPD1_SRESETGENEN
    REGISTERS[36][1]                          = CONFIG[185];           // GPD2_SRESETGENEN
    REGISTERS[37][1]                          = CONFIG[186];           // GPD3_SRESETGENEN
    REGISTERS[29][0]                          = CONFIG[187];           // GPD_SW_RESYNC
    REGISTERS[0][7]                           = CONFIG[192];           // OVR_RDADDR
    REGISTERS[0][6]                           = CONFIG[193];           // REG_AUTO_INC
    REGISTERS[34][2]                          = CONFIG[194];           // GPD0_G3STYLE_N
    REGISTERS[35][2]                          = CONFIG[195];           // GPD1_G3STYLE_N
    REGISTERS[36][2]                          = CONFIG[196];           // GPD2_G3STYLE_N
    REGISTERS[37][2]                          = CONFIG[197];           // GPD3_G3STYLE_N
    REGISTERS[7][7:6]                         = {1'b0, CONFIG[198]};   // GLMUX0_SELOUT
    REGISTERS[9][7:6]                         = {1'b0, CONFIG[199]};   // GLMUX1_SELOUT
    REGISTERS[11][7:6]                        = {1'b0, CONFIG[200]};   // GLMUX2_SELOUT
    REGISTERS[13][7:6]                        = {1'b0, CONFIG[201]};   // GLMUX3_SELOUT

    REGISTERS[39][0]                          = CONFIG[202];           // OVWR_SEL_RESET
    REGISTERS[39][1]                          = CONFIG[203];           // OVWR_VAL_RESET
    REGISTERS[40][0]                          = CONFIG[204];           // OVWR_SEL_POWERDOWN
    REGISTERS[40][1]                          = CONFIG[205];           // OVWR_VAL_POWERDOWN
    REGISTERS[41][0]                          = CONFIG[206];           // OVWR_SEL_BYPASS
    REGISTERS[41][1]                          = CONFIG[207];           // OVWR_VAL_BYPASS
    REGISTERS[42][0]                          = CONFIG[208];           // OVWR_SEL_GL
    REGISTERS[42][1]                          = CONFIG[209];           // OVWR_VAL_GL
  end

  initial begin
    APB_state = `APB_IDLE;
  end

  always @( GLMUX0_BUSY or GLMUX1_BUSY or GLMUX2_BUSY or GLMUX3_BUSY ) begin
    REGISTERS['h7][7]  = GLMUX0_BUSY;
    REGISTERS['h9][7]  = GLMUX1_BUSY;
    REGISTERS['hB][7]  = GLMUX2_BUSY;
    REGISTERS['hD][7]  = GLMUX3_BUSY;
  end

  always @( CORE_LOCK )
    REGISTERS['h17][4]   = CORE_LOCK;


  /////// APB Activity /////
  always @( APB_state ) begin
    APB_ACTIVITY();
  end
  always @( negedge PRESET_N ) begin
    APB_state = `APB_RESET;
  end
  always @( posedge PCLK ) begin
    PADDR_lat   = ovr_raddr ? ovrd_addr : PADDR;
    PWDATA_lat  = PWDATA;
    PWRITE_lat  = PWRITE;
    PSEL_lat    = PSEL;
    PENABLE_lat = PENABLE;

    APB_SM();
  end

  task APB_SM;
    begin
      case ( APB_state )
        `APB_SETUP  : APB_state = `APB_ENABLE;

        `APB_ENABLE : begin
                        if( PSEL_lat === 1'b1 )
                          APB_state = `APB_ENABLE;    // [HH] SAR63313: skipping the setup phase in the APB state machine.
                        else
                          APB_state = `APB_IDLE;
                      end

        `APB_IDLE   : begin
                        if ( (PSEL_lat === 1'b1) && (PENABLE_lat === 1'b0) )
                          APB_state = `APB_ENABLE;    // [HH] SAR63313: skipping the setup phase in the APB state machine.
                      end

        `APB_RESET  : begin
                        if ( PRESET_N === 1'b1 )
                          APB_state = `APB_IDLE;
                      end
        default     : APB_state = `APB_IDLE;
      endcase
    end
  endtask

  task APB_ACTIVITY;
    begin
      case ( APB_state )
        `APB_IDLE :
            ;

        `APB_RESET :
            begin
              REGISTERS[ 0 ] = 8'h00;
            end

        `APB_SETUP :
            begin
              if ( (^PADDR_lat) === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: Illegal address to the CCCL_CONFIG at time %0.1fns! Instance: %m", $realtime);
              end
            end

        `APB_ENABLE :
            begin
              if ( (^PADDR_lat) === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: Illegal address to the CCCL_CONFIG at time %0.1fns! Instance: %m", $realtime);
              end
              else begin
                if ( PWRITE_lat === 1'b1 ) begin
                  REGISTERS[ PADDR_lat ][ 7:0 ] = PWDATA_lat;
                end
                else if ( PWRITE_lat === 1'b0 )
                  PRDATA_reg = REGISTERS[ PADDR_lat ][ 7:0 ];
                else begin
                  if ( WARNING_MSGS_ON == 1 )
                    $display(" Warning: CCCL_CONFIG write enable went unknown at time %0.1fns! Instance: %m", $realtime);
                end
              end
            end
      endcase
    end
  endtask
  //////////////////////////////
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
        
    (posedge PCLK => (PRDATA[0] +: PRDATA[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[1] +: PRDATA[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[2] +: PRDATA[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[3] +: PRDATA[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[4] +: PRDATA[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[5] +: PRDATA[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[6] +: PRDATA[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PRDATA[7] +: PRDATA[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
                    
    (posedge PCLK => (RF_INV +: RF_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_INV +: FB_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_INV +: GLMUX0_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_INV +: GLMUX1_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_INV +: GLMUX2_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_INV +: GLMUX3_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SELOUT +: GLMUX0_SELOUT)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SELOUT +: GLMUX1_SELOUT)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SELOUT +: GLMUX2_SELOUT)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SELOUT +: GLMUX3_SELOUT)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_INV +: GPD0_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_NOPIPE_RSTSYNC +: GPD0_NOPIPE_RSTSYNC)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_INV +: GPD1_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_NOPIPE_RSTSYNC +: GPD1_NOPIPE_RSTSYNC)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_INV +: GPD2_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_NOPIPE_RSTSYNC +: GPD2_NOPIPE_RSTSYNC)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_INV +: GPD3_INV)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_NOPIPE_RSTSYNC +: GPD3_NOPIPE_RSTSYNC)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD_SWRESYNC +: GPD_SWRESYNC)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_G3STYLE_N +: GPD0_G3STYLE_N)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SRESETGENEN +: GPD0_SRESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_RESETGENEN +: GPD0_RESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_G3STYLE_N +: GPD1_G3STYLE_N)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SRESETGENEN +: GPD1_SRESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_RESETGENEN +: GPD1_RESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_G3STYLE_N +: GPD2_G3STYLE_N)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SRESETGENEN +: GPD2_SRESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_RESETGENEN +: GPD2_RESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_G3STYLE_N +: GPD3_G3STYLE_N)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SRESETGENEN +: GPD3_SRESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_RESETGENEN +: GPD3_RESETGENEN)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_RF +: DELAY_LINE_RF)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBSEL +: PLL_FBSEL)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSE +: PLL_SSE)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_MODE_32K +: PLL_MODE_32K)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_MODE_1V2 +: PLL_MODE_1V2)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_MODE_3V3 +: PLL_MODE_3V3)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_SEL_RESET +: OVWR_SEL_RESET)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_VAL_RESET +: OVWR_VAL_RESET)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_SEL_PD +: OVWR_SEL_PD)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_VAL_PD +: OVWR_VAL_PD)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_SEL_BYPASS +: OVWR_SEL_BYPASS)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_VAL_BYPASS +: OVWR_VAL_BYPASS)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_SEL_GL +: OVWR_SEL_GL)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (OVWR_VAL_GL +: OVWR_VAL_GL)) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_SEL[3] +: RF_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_SEL[2] +: RF_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_SEL[1] +: RF_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_SEL[0] +: RF_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[7] +: RF_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[6] +: RF_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[5] +: RF_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[4] +: RF_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[3] +: RF_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[2] +: RF_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[1] +: RF_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (RF_DIV[0] +: RF_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_SEL[3] +: FB_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_SEL[2] +: FB_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_SEL[1] +: FB_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_SEL[0] +: FB_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[13] +: FB_DIV[13])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[12] +: FB_DIV[12])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[11] +: FB_DIV[11])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[10] +: FB_DIV[10])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[9] +: FB_DIV[9])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[8] +: FB_DIV[8])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[7] +: FB_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[6] +: FB_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[5] +: FB_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[4] +: FB_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[3] +: FB_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[2] +: FB_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[1] +: FB_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (FB_DIV[0] +: FB_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[9] +: GLMUX0_SEL[9])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[8] +: GLMUX0_SEL[8])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[7] +: GLMUX0_SEL[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[6] +: GLMUX0_SEL[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[5] +: GLMUX0_SEL[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[4] +: GLMUX0_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[3] +: GLMUX0_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[2] +: GLMUX0_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[1] +: GLMUX0_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX0_SEL[0] +: GLMUX0_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[9] +: GLMUX1_SEL[9])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[8] +: GLMUX1_SEL[8])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[7] +: GLMUX1_SEL[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[6] +: GLMUX1_SEL[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[5] +: GLMUX1_SEL[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[4] +: GLMUX1_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[3] +: GLMUX1_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[2] +: GLMUX1_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[1] +: GLMUX1_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX1_SEL[0] +: GLMUX1_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[9] +: GLMUX2_SEL[9])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[8] +: GLMUX2_SEL[8])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[7] +: GLMUX2_SEL[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[6] +: GLMUX2_SEL[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[5] +: GLMUX2_SEL[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[4] +: GLMUX2_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[3] +: GLMUX2_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[2] +: GLMUX2_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[1] +: GLMUX2_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX2_SEL[0] +: GLMUX2_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[9] +: GLMUX3_SEL[9])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[8] +: GLMUX3_SEL[8])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[7] +: GLMUX3_SEL[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[6] +: GLMUX3_SEL[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[5] +: GLMUX3_SEL[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[4] +: GLMUX3_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[3] +: GLMUX3_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[2] +: GLMUX3_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[1] +: GLMUX3_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GLMUX3_SEL[0] +: GLMUX3_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SEL[4] +: GPD0_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SEL[3] +: GPD0_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SEL[2] +: GPD0_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SEL[1] +: GPD0_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_SEL[0] +: GPD0_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SEL[4] +: GPD1_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SEL[3] +: GPD1_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SEL[2] +: GPD1_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SEL[1] +: GPD1_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_SEL[0] +: GPD1_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SEL[4] +: GPD2_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SEL[3] +: GPD2_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SEL[2] +: GPD2_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SEL[1] +: GPD2_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_SEL[0] +: GPD2_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SEL[4] +: GPD3_SEL[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SEL[3] +: GPD3_SEL[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SEL[2] +: GPD3_SEL[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SEL[1] +: GPD3_SEL[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_SEL[0] +: GPD3_SEL[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[7] +: GPD0_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[6] +: GPD0_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[5] +: GPD0_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[4] +: GPD0_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[3] +: GPD0_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[2] +: GPD0_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[1] +: GPD0_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD0_DIV[0] +: GPD0_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[7] +: GPD1_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[6] +: GPD1_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[5] +: GPD1_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[4] +: GPD1_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[3] +: GPD1_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[2] +: GPD1_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[1] +: GPD1_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD1_DIV[0] +: GPD1_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[7] +: GPD2_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[6] +: GPD2_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[5] +: GPD2_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[4] +: GPD2_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[3] +: GPD2_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[2] +: GPD2_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[1] +: GPD2_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD2_DIV[0] +: GPD2_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[7] +: GPD3_DIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[6] +: GPD3_DIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[5] +: GPD3_DIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[4] +: GPD3_DIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[3] +: GPD3_DIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[2] +: GPD3_DIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[1] +: GPD3_DIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (GPD3_DIV[0] +: GPD3_DIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKWIN[2] +: PLL_LOCKWIN[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKWIN[1] +: PLL_LOCKWIN[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKWIN[0] +: PLL_LOCKWIN[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKCNT[3] +: PLL_LOCKCNT[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKCNT[2] +: PLL_LOCKCNT[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKCNT[1] +: PLL_LOCKCNT[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_LOCKCNT[0] +: PLL_LOCKCNT[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[2] +: PLL_VCODIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[1] +: PLL_VCODIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[0] +: PLL_VCODIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[5] +: DELAY_LINE_SET[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[4] +: DELAY_LINE_SET[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[3] +: DELAY_LINE_SET[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[2] +: DELAY_LINE_SET[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[1] +: DELAY_LINE_SET[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (DELAY_LINE_SET[0] +: DELAY_LINE_SET[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMD[1] +: PLL_SSMD[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMD[0] +: PLL_SSMD[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMF[4] +: PLL_SSMF[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMF[3] +: PLL_SSMF[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMF[2] +: PLL_SSMF[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMF[1] +: PLL_SSMF[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_SSMF[0] +: PLL_SSMF[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_RANGE[3] +: PLL_RANGE[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_RANGE[2] +: PLL_RANGE[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_RANGE[1] +: PLL_RANGE[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_RANGE[0] +: PLL_RANGE[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[7] +: PLL_FBDIV[7])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[6] +: PLL_FBDIV[6])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[5] +: PLL_FBDIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[4] +: PLL_FBDIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[3] +: PLL_FBDIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[2] +: PLL_FBDIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[1] +: PLL_FBDIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_FBDIV[0] +: PLL_FBDIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[5] +: PLL_CLKDIV[5])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[4] +: PLL_CLKDIV[4])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[3] +: PLL_CLKDIV[3])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[2] +: PLL_CLKDIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[1] +: PLL_CLKDIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_CLKDIV[0] +: PLL_CLKDIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[2] +: PLL_VCODIV[2])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[1] +: PLL_VCODIV[1])) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (posedge PCLK => (PLL_VCODIV[0] +: PLL_VCODIV[0])) = (0.00:0.00:0.00, 0.00:0.00:0.00);



    $setup(posedge PSEL, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWRITE, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PENABLE, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[0], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[1], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[2], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[3], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[4], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[5], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[6], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PWDATA[7], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[2], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[3], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[4], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[5], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[6], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(posedge PADDR[7], posedge PCLK, 0.0, NOTIFY_REG);
    
    $setup(negedge PSEL, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWRITE, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PENABLE, posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[0], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[1], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[2], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[3], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[4], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[5], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[6], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PWDATA[7], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[2], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[3], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[4], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[5], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[6], posedge PCLK, 0.0, NOTIFY_REG);
    $setup(negedge PADDR[7], posedge PCLK, 0.0, NOTIFY_REG);
    
    $hold(posedge	PCLK, posedge	PSEL, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWRITE, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PENABLE, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[0], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[1], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[2], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[3], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[4], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[5], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[6], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PWDATA[7], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[2], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[3], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[4], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[5], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[6], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PADDR[7], 0.0, NOTIFY_REG);
                
    $hold(posedge	PCLK, negedge	PSEL, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWRITE, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PENABLE, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[0], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[1], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[2], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[3], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[4], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[5], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[6], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PWDATA[7], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[2], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[3], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[4], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[5], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[6], 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PADDR[7], 0.0, NOTIFY_REG);
    
    $recovery(posedge PRESET_N, posedge PCLK, 0.0, NOTIFY_REG);
    $recovery(negedge PRESET_N, posedge PCLK, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, posedge	PRESET_N, 0.0, NOTIFY_REG);
    $hold(posedge	PCLK, negedge	PRESET_N, 0.0, NOTIFY_REG);
    
    $width(posedge PCLK, 0.0, 0, NOTIFY_REG);
    $width(negedge PCLK, 0.0, 0, NOTIFY_REG);
    
  endspecify
endmodule
`timescale 1 ps/1 ps
module CCC_FB_MUX(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  XTLOSC, RCOSC_1MHZ, RCOSC_25_50MHZ,
                  SEL, INV,
                  CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input       XTLOSC, RCOSC_1MHZ, RCOSC_25_50MHZ;
  input [3:0] SEL;
  input       INV;
  output      CLKOUT;

  wire   [15:0] CLKS;
  wire          MUX_OUT;
    
  assign CLKS[ 0 ] = CLK0_PAD;
  assign CLKS[ 1 ] = CLK1_PAD;
  assign CLKS[ 2 ] = CLK2_PAD;
  assign CLKS[ 3 ] = CLK3_PAD;
  assign CLKS[ 4 ] = VCO135;            // Not supported by SW, issue a warning
  assign CLKS[ 5 ] = VCO90;             // Not supported by SW, issue a warning
  assign CLKS[ 6 ] = VCO45;             // Not supported by SW, issue a warning
  assign CLKS[ 7 ] = VCO0;
  assign CLKS[ 8 ] = 1'b0;
  assign CLKS[ 9 ] = XTLOSC;            // Not supported by SW, issue a warning
  assign CLKS[ 10 ] = RCOSC_1MHZ;       // Not supported by SW, issue a warning
  assign CLKS[ 11 ] = RCOSC_25_50MHZ;   // Not supported by SW, issue a warning
  assign CLKS[ 12 ] = CLK0;
  assign CLKS[ 13 ] = CLK1;
  assign CLKS[ 14 ] = CLK2;
  assign CLKS[ 15 ] = CLK3;

  assign MUX_OUT = CLKS[ SEL ];

  xor u0(CLKOUT, INV, MUX_OUT);

  always @( SEL ) begin
    case ( SEL )
      4,5,6,9,10,11:
          $display (" Warning: Unsupported selection applied to the FB MUX at time %0.1fps! Instance: %m", $realtime);
    endcase
  end
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[3:0] == 4'd0  ) ( CLK0_PAD        => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd1  ) ( CLK1_PAD        => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd2  ) ( CLK2_PAD        => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd3  ) ( CLK3_PAD        => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd12 ) ( CLK0            => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd13 ) ( CLK1            => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd14 ) ( CLK2            => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd15 ) ( CLK3            => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd11 ) ( RCOSC_25_50MHZ  => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd10 ) ( RCOSC_1MHZ      => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd9  ) ( XTLOSC          => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd7  ) ( VCO0            => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd6  ) ( VCO45           => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd5  ) ( VCO90           => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd4  ) ( VCO135          => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( INV             => CLKOUT    ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

////////////////////////////////////////////////////////////////////
`timescale 1 ps/1 ps
module CCC_FB_DIV(CLKIN, DIV, ARST_N, divq_reset, CLKOUT);

  input         CLKIN;
  input         ARST_N;
  input         divq_reset;
  input [13:0]  DIV;
  output        CLKOUT;

  Freq_Divider #(.DIV_LENGTH(14), .DIV_FORMAT(1), .RESET_POLARITY(0)) 
      u_fb_div (.CLKIN(CLKIN), .DIV(DIV), .CLKOUT(CLKOUT), .SYNC_RESET(ARST_N), .ASYNC_RESET(divq_reset));

  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( ARST_N        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule
/*********************************/
/*            CCC_NGMUX               */
/*********************************/
`timescale 1 ps/1 ps
module CCC_NGMUX (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, OUT_SEL, INV, NGMUX_ARST_N, NGMUX_SEL, NGMUX_HOLD_N,
                  Y, GL, BUSY);


  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;                         // Clock Inputs
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [9:0]   SEL;                                                            // Select lines for the pre-mux
  input         NGMUX_SEL;                                                      // Select for the NGMUX
  input         NGMUX_HOLD_N;                                                   // Sync active-low reset for the NGMUX output
  input         OUT_SEL;
  input         INV, NGMUX_ARST_N;
  output        Y, GL;
  output        BUSY;


  wire          CK1, CK2;
  wire          GLMUX_CLKOUT;
  reg           BUSY;
  reg           GLMUX_CLKOUT_en;
  reg           NGMUX_SEL_int;
  
  
  reg           NGMUX_HOLD_N_lat1, NGMUX_HOLD_N_lat2;
  integer       CLKOUT_neg_edges;
  integer       CK_neg_edges;


  
  assign phase1 = NGMUX_SEL ^ NGMUX_SEL_int;
  assign phase2 = !(NGMUX_SEL ^ NGMUX_SEL_int) & BUSY;
  assign GLMUX_CLKOUT_int = (NGMUX_SEL_int === 1'b0) ? CK1 : ( (NGMUX_SEL_int === 1'b1) ? CK2 : 1'bx );
  assign GLMUX_CLKOUT = NGMUX_HOLD_N_lat2 ? (GLMUX_CLKOUT_en ? GLMUX_CLKOUT_int : 1'b0) : 1'b0;
  
  // Implementation of the OUT_MUX
  assign Y = (OUT_SEL === 1'b1) ? GLMUX_CLKOUT : ( (OUT_SEL === 1'b0) ? CK1 : 1'bx );
  assign GL = (OUT_SEL === 1'b1) ? GLMUX_CLKOUT : ( (OUT_SEL === 1'b0) ? CK1 : 1'bx );

  always @( OUT_SEL ) begin
    if ( (OUT_SEL !== 1'b0) && (OUT_SEL !== 1'b1) )
      $display("Warning : OUT_SEL input went unknown at time %0.1fns. Instance: %m",$realtime);
  end
  
  always @( posedge GLMUX_CLKOUT_int or negedge NGMUX_ARST_N ) begin
    if( !NGMUX_ARST_N )
      NGMUX_HOLD_N_lat1 <= 1'b0;
    else
      NGMUX_HOLD_N_lat1 <= NGMUX_HOLD_N;
  end

  always @( negedge GLMUX_CLKOUT_int or negedge NGMUX_ARST_N ) begin
	 if( !NGMUX_ARST_N )
    NGMUX_HOLD_N_lat2 <= 1'b0;
	else
    NGMUX_HOLD_N_lat2 <= NGMUX_HOLD_N_lat1;
	end


  CCC_NGPREMUX u0(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                  .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                  .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                  .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135),
                  .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                  .GPDCLK0(GPDCLK0), .GPDCLK1(GPDCLK1), .GPDCLK2(GPDCLK2), .GPDCLK3(GPDCLK3),
                  .SEL_CK1(SEL[4:0]), .SEL_CK2(SEL[9:5]), .INV(INV), .CK1(CK1), .CK2(CK2));



  
 

  initial begin
    CLKOUT_neg_edges = 0;
    CK_neg_edges = 0;
    GLMUX_CLKOUT_en = 1'b1;
    BUSY = 1'b0;
    wait ( |NGMUX_SEL !== 1'bx );
    NGMUX_SEL_int = NGMUX_SEL;
  end

  

  always @( NGMUX_SEL ) begin
    if ( $time > 0 ) begin
      CLKOUT_neg_edges  = 0;
      BUSY = 1'b1;
      if ( (NGMUX_SEL !== 1'b0) && (NGMUX_SEL !== 1'b1) )
        $display("Warning : NGMUX_SEL input went unknown at time %0.1fns. Instance: %m",$realtime);
    end
  end


    
  always @( negedge GLMUX_CLKOUT_int ) begin
    if ( (phase2 === 1'b1) && (CLKOUT_neg_edges < 5) ) begin
      CLKOUT_neg_edges = CLKOUT_neg_edges + 1;

      if ( CLKOUT_neg_edges === 5 ) begin
        GLMUX_CLKOUT_en = 1'b1;             // Enable the output clock
        BUSY = 1'b0;
        CK_neg_edges = 0;
      end
    end
  end

  
  
  always @( negedge CK1 ) begin
    if ( (phase1 === 1'b1) && ( NGMUX_SEL_int === 1'b0) ) begin
      if ( CK_neg_edges < 5 ) begin
        CK_neg_edges = CK_neg_edges + 1;

        if ( CK_neg_edges === 5 ) begin
          GLMUX_CLKOUT_en = 1'b0;           // Disable the output clock
          NGMUX_SEL_int   = NGMUX_SEL;      // Update the selection for the NGMUX
        end
      end
    end
  end

  always @( negedge CK2 ) begin
    if ( (phase1 === 1'b1) && ( NGMUX_SEL_int === 1'b1) ) begin
      if ( CK_neg_edges < 5 ) begin
        CK_neg_edges = CK_neg_edges + 1;

        if ( CK_neg_edges === 5 ) begin
          GLMUX_CLKOUT_en = 1'b0;           // Disable the output clock
          NGMUX_SEL_int   = NGMUX_SEL;      // Update the selection for the NGMUX
        end
      end
    end
  end



  // Error Checking
  always @( SEL[4:0] ) begin
    case ( SEL[4:0] )
      12,13,14,15,28,29,30,31:
          $display (" Warning: Unsupported selection applied to the NGMUX at time %0.1fns! Instance: %m", $realtime);
    endcase
  end

  always @( SEL[9:5] ) begin
    case ( SEL[9:5] )
      12,13,14,15,28,29,30,31:
          $display (" Warning: Unsupported selection applied to the NGMUX at time %0.1fns! Instance: %m", $realtime);
    endcase
  end
endmodule


module CCC_NGPREMUX(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                    SEL_CK1, SEL_CK2, INV, CK1, CK2);

  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [4:0]   SEL_CK1;
  input [4:0]   SEL_CK2;
  input         INV;
  output        CK1, CK2;

  wire   [31:0] CLKS;

  assign CLKS[ 0 ] = VCO315;
  assign CLKS[ 1 ] = VCO270;
  assign CLKS[ 2 ] = VCO225;
  assign CLKS[ 3 ] = VCO180;
  assign CLKS[ 4 ] = VCO135;
  assign CLKS[ 5 ] = VCO90;
  assign CLKS[ 6 ] = VCO45;
  assign CLKS[ 7 ] = VCO0;
  assign CLKS[ 8 ] = GPDCLK0;
  assign CLKS[ 9 ] = GPDCLK1;
  assign CLKS[ 10 ] = GPDCLK2;
  assign CLKS[ 11 ] = GPDCLK3;
  // Selections 12 to 15 do not need to be supported by the SW. Issue a warning in this case
  assign CLKS[ 12 ] = 1'b0;
  assign CLKS[ 13 ] = 1'b0;
  assign CLKS[ 14 ] = 1'b1;
  assign CLKS[ 15 ] = 1'b1;
  assign CLKS[ 16 ] = CLK0_PAD;
  assign CLKS[ 17 ] = CLK1_PAD;
  assign CLKS[ 18 ] = CLK2_PAD;
  assign CLKS[ 19 ] = CLK3_PAD;
  assign CLKS[ 20 ] = CLK0;
  assign CLKS[ 21 ] = CLK1;
  assign CLKS[ 22 ] = CLK2;
  assign CLKS[ 23 ] = CLK3;
  assign CLKS[ 24 ] = 1'b0;
  assign CLKS[ 25 ] = XTLOSC;
  assign CLKS[ 26 ] = RCOSC_1MHZ;
  assign CLKS[ 27 ] = RCOSC_25_50MHZ;
  // Selections 28 to 31 do not need to be supported by the SW. Issue a warning in this case
  assign CLKS[ 28 ] = 1'b0;
  assign CLKS[ 29 ] = 1'b0;
  assign CLKS[ 30 ] = 1'b1;
  assign CLKS[ 31 ] = 1'b1;

  assign CK1 = CLKS[ SEL_CK1 ] ^ INV;
  assign CK2 = CLKS[ SEL_CK2 ] ^ INV;

endmodule


`timescale 1 ps/1 ps
module CCC_NGMUX0(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, OUT_SEL, INV, NGMUX_ARST_N, NGMUX_SEL, NGMUX_HOLD_N,
                  Y, GL, BUSY);


  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;                         // Clock Inputs
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [9:0]   SEL;                                                            // Select lines for the pre-mux
  input         NGMUX_SEL;                                                      // Select for the NGMUX
  input         NGMUX_HOLD_N;                                                   // Sync active-low reset for the NGMUX output
  input         OUT_SEL;
  input         INV, NGMUX_ARST_N;
  output        Y, GL;
  output        BUSY;
  
  CCC_NGMUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                .GPDCLK0(GPDCLK0), .GPDCLK1(GPDCLK1), .GPDCLK2(GPDCLK2), .GPDCLK3(GPDCLK3),
                .SEL(SEL), .NGMUX_SEL(NGMUX_SEL), .NGMUX_HOLD_N(NGMUX_HOLD_N), .OUT_SEL(OUT_SEL), 
                .INV(INV), .NGMUX_ARST_N(NGMUX_ARST_N),
                .GL(GL), .Y(Y), .BUSY(BUSY));
                
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => Y   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => GL   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[5]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[6]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[7]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[8]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[9]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
  endspecify
  
endmodule

`timescale 1 ps/1 ps
module CCC_NGMUX1(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, OUT_SEL, INV, NGMUX_ARST_N, NGMUX_SEL, NGMUX_HOLD_N,
                  Y, GL, BUSY);


  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;                         // Clock Inputs
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [9:0]   SEL;                                                            // Select lines for the pre-mux
  input         NGMUX_SEL;                                                      // Select for the NGMUX
  input         NGMUX_HOLD_N;                                                   // Sync active-low reset for the NGMUX output
  input         OUT_SEL;
  input         INV, NGMUX_ARST_N;
  output        Y, GL;
  output        BUSY;
  
  CCC_NGMUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                .GPDCLK0(GPDCLK0), .GPDCLK1(GPDCLK1), .GPDCLK2(GPDCLK2), .GPDCLK3(GPDCLK3),
                .SEL(SEL), .NGMUX_SEL(NGMUX_SEL), .NGMUX_HOLD_N(NGMUX_HOLD_N), .OUT_SEL(OUT_SEL), 
                .INV(INV), .NGMUX_ARST_N(NGMUX_ARST_N),
                .GL(GL), .Y(Y), .BUSY(BUSY));
                
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => Y   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => GL   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    ( SEL[0]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[5]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[6]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[7]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[8]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[9]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
  endspecify
  
endmodule

`timescale 1 ps/1 ps
module CCC_NGMUX2(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, OUT_SEL, INV, NGMUX_ARST_N, NGMUX_SEL, NGMUX_HOLD_N,
                  Y, GL, BUSY);


  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;                         // Clock Inputs
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [9:0]   SEL;                                                            // Select lines for the pre-mux
  input         NGMUX_SEL;                                                      // Select for the NGMUX
  input         NGMUX_HOLD_N;                                                   // Sync active-low reset for the NGMUX output
  input         OUT_SEL;
  input         INV, NGMUX_ARST_N;
  output        Y, GL;
  output        BUSY;
  
  CCC_NGMUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                .GPDCLK0(GPDCLK0), .GPDCLK1(GPDCLK1), .GPDCLK2(GPDCLK2), .GPDCLK3(GPDCLK3),
                .SEL(SEL), .NGMUX_SEL(NGMUX_SEL), .NGMUX_HOLD_N(NGMUX_HOLD_N), .OUT_SEL(OUT_SEL), 
                .INV(INV), .NGMUX_ARST_N(NGMUX_ARST_N),
                .GL(GL), .Y(Y), .BUSY(BUSY));
                
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => Y   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => GL   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    ( SEL[0]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[5]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[6]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[7]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[8]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[9]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
  endspecify
  
endmodule

`timescale 1 ps/1 ps
module CCC_NGMUX3(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, OUT_SEL, INV, NGMUX_ARST_N, NGMUX_SEL, NGMUX_HOLD_N,
                  Y, GL, BUSY);


  input         CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;                         // Clock Inputs
  input         CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input         VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input         GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [9:0]   SEL;                                                            // Select lines for the pre-mux
  input         NGMUX_SEL;                                                      // Select for the NGMUX
  input         NGMUX_HOLD_N;                                                   // Sync active-low reset for the NGMUX output
  input         OUT_SEL;
  input         INV, NGMUX_ARST_N;
  output        Y, GL;
  output        BUSY;
  
  CCC_NGMUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                .GPDCLK0(GPDCLK0), .GPDCLK1(GPDCLK1), .GPDCLK2(GPDCLK2), .GPDCLK3(GPDCLK3),
                .SEL(SEL), .NGMUX_SEL(NGMUX_SEL), .NGMUX_HOLD_N(NGMUX_HOLD_N), .OUT_SEL(OUT_SEL), 
                .INV(INV), .NGMUX_ARST_N(NGMUX_ARST_N),
                .GL(GL), .Y(Y), .BUSY(BUSY));
                
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => Y   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => Y   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd16) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd16) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0_PAD        => GL   ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd17) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd17) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd18) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd18) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd19) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd19) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3_PAD        => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    if ( ( (SEL[4:0] == 5'd20) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd20) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd21) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd21) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK1            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd22) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd22) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK2            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd23) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd23) && (NGMUX_SEL == 1'b1) )  ) 
      ( CLK3            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd27) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd27) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_25_50MHZ  => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd26) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd26) && (NGMUX_SEL == 1'b1) )  ) 
      ( RCOSC_1MHZ      => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd25) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd25) && (NGMUX_SEL == 1'b1) )  ) 
      ( XTLOSC          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd7) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd7) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO0            => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd6) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd6) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO45           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd5) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd5) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO90           => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd4) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd4) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO135          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd3) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd3) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO180          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd2) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd2) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO225          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd1) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd1) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO270          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd0) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd0) && (NGMUX_SEL == 1'b1) )  ) 
      ( VCO315          => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    if ( ( (SEL[4:0] == 5'd8) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd8) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK0         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd9) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd9) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK1         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd10) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd10) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK2         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( ( (SEL[4:0] == 5'd11) && (NGMUX_SEL == 1'b0) ) || ( (SEL[9:5] == 5'd11) && (NGMUX_SEL == 1'b1) )  ) 
      ( GPDCLK3         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
      
    ( SEL[0]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[5]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[6]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[7]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[8]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[9]          => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => Y    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_SEL       => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_HOLD_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( OUT_SEL         => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NGMUX_ARST_N    => GL   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
  endspecify
  
endmodule
`timescale 1 ps/1 ps
module CCC_RF_MUX(CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                  CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                  GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                  SEL, INV,
                  CLKOUT);
                  
  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [3:0] SEL;
  input       INV;
  output      CLKOUT;
  
  wire   [15:0] CLKS;
  wire          MUX_OUT;
  
  assign CLKS[ 0 ] = CLK0_PAD;
  assign CLKS[ 1 ] = CLK1_PAD;
  assign CLKS[ 2 ] = CLK2_PAD;
  assign CLKS[ 3 ] = CLK3_PAD;
  
  assign CLKS[ 4 ] = GPDCLK0;
  assign CLKS[ 5 ] = GPDCLK1;
  assign CLKS[ 6 ] = GPDCLK2;
  assign CLKS[ 7 ] = GPDCLK3;

  assign CLKS[ 8 ] = 1'b0;
  assign CLKS[ 9 ] = XTLOSC;
  assign CLKS[ 10 ] = RCOSC_1MHZ;
  assign CLKS[ 11 ] = RCOSC_25_50MHZ;
  
  assign CLKS[ 12 ] = CLK0;
  assign CLKS[ 13 ] = CLK1;
  assign CLKS[ 14 ] = CLK2;
  assign CLKS[ 15 ] = CLK3;
  
  assign MUX_OUT = CLKS[ SEL ];
  
  xor u0(CLKOUT, INV, MUX_OUT);
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[3:0] == 4'd0  ) ( CLK0_PAD        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd1  ) ( CLK1_PAD        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd2  ) ( CLK2_PAD        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd3  ) ( CLK3_PAD        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd12 ) ( CLK0            => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd13 ) ( CLK1            => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd14 ) ( CLK2            => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd15 ) ( CLK3            => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd11 ) ( RCOSC_25_50MHZ  => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd10 ) ( RCOSC_1MHZ      => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd9  ) ( XTLOSC          => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd4  ) ( GPDCLK0         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd5  ) ( GPDCLK1         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd6  ) ( GPDCLK2         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[3:0] == 4'd7  ) ( GPDCLK3         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( INV             => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

////////////////////////////////////////////////////////////////
`timescale 1 ps/1 ps
module CCC_RF_DIV(CLKIN, DIV, ARST_N, CLKOUT);
  input         CLKIN;
  input         ARST_N;
  input [7:0]   DIV;
  output        CLKOUT;

  Freq_Divider #(.DIV_LENGTH(8), .DIV_FORMAT(1), .RESET_POLARITY(0)) 
      u_rf_div (.CLKIN(CLKIN), .DIV(DIV), .CLKOUT(CLKOUT), .SYNC_RESET(ARST_N), .ASYNC_RESET(ARST_N));

  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN         => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( ARST_N        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule
`timescale 1 ps/1 ps
module CCC_DELAY(CLKIN, SETPLLDLINE, ENABLE,
                 CLKOUT);

  input       CLKIN, ENABLE;
  input [5:0] SETPLLDLINE;
  output      CLKOUT;
  
  parameter [150:0] ACT_CONFIG    = 150'h0;
  
  `define DELAY_STEP 100
  
  time DELAY;
  reg DELAYED_CLK;
  
  assign CLKOUT = DELAYED_CLK;
  
  always @( SETPLLDLINE ) begin
    DELAY = `DELAY_STEP * SETPLLDLINE;
  end
  
  always @( CLKIN or DELAY or ENABLE ) begin
    if ( ENABLE === 1'b1 )
      DELAYED_CLK <= # DELAY CLKIN;
    else
      DELAYED_CLK <= CLKIN;    
  end
  
endmodule


`timescale 1 ps/1 ps
module CCC_FB_DELAY(CLKIN, SETPLLDLINE, ENABLE,
                    CLKOUT);

  input       CLKIN, ENABLE;
  input [5:0] SETPLLDLINE;
  output      CLKOUT;
  
  parameter [150:0] ACT_CONFIG    = 150'h0;

  CCC_DELAY u_fb_delay (.CLKIN(CLKIN), .SETPLLDLINE(SETPLLDLINE), .ENABLE(ENABLE),
                        .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( ENABLE       => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_RF_DELAY(CLKIN, SETPLLDLINE, ENABLE,
                    CLKOUT);

  input       CLKIN, ENABLE;
  input [5:0] SETPLLDLINE;
  output      CLKOUT;
  
  parameter [150:0] ACT_CONFIG    = 150'h0;

  CCC_DELAY u_rf_delay (.CLKIN(CLKIN), .SETPLLDLINE(SETPLLDLINE), .ENABLE(ENABLE),
                        .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN        => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( ENABLE       => CLKOUT    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule
`timescale 1 ps/1 ps
module CCC_GPD_MUX (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3,
                    SEL, INV,
                    CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input       GPDCLK0, GPDCLK1, GPDCLK2, GPDCLK3;
  input [4:0] SEL;
  input       INV;
  output      CLKOUT;

  wire   [31:0] CLKS;
  wire          MUX_OUT;

  assign CLKS[ 0 ] = VCO315;
  assign CLKS[ 1 ] = VCO270;
  assign CLKS[ 2 ] = VCO225;
  assign CLKS[ 3 ] = VCO180;
  assign CLKS[ 4 ] = VCO135;
  assign CLKS[ 5 ] = VCO90;
  assign CLKS[ 6 ] = VCO45;
  assign CLKS[ 7 ] = VCO0;
  
  // Selections 8 to 15 do not need to be supported by the SW. Issue a warning in this case
  assign CLKS[ 8 ] = GPDCLK0;
  assign CLKS[ 9 ] = GPDCLK1;
  assign CLKS[ 10 ] = GPDCLK2;
  assign CLKS[ 11 ] = GPDCLK3;
  
  assign CLKS[ 12 ] = 1'b0;
  assign CLKS[ 13 ] = 1'b0;
  assign CLKS[ 14 ] = 1'b1;
  assign CLKS[ 15 ] = 1'b1;
  
  assign CLKS[ 16 ] = CLK0_PAD;
  assign CLKS[ 17 ] = CLK1_PAD;
  assign CLKS[ 18 ] = CLK2_PAD;
  assign CLKS[ 19 ] = CLK3_PAD;

  assign CLKS[ 20 ] = CLK0;
  assign CLKS[ 21 ] = CLK1;
  assign CLKS[ 22 ] = CLK2;
  assign CLKS[ 23 ] = CLK3;

  assign CLKS[ 24 ] = 1'b0;

  assign CLKS[ 25 ] = XTLOSC;
  assign CLKS[ 26 ] = RCOSC_1MHZ;
  assign CLKS[ 27 ] = RCOSC_25_50MHZ;
  // Selections 28 to 31 do not need to be supported by the SW. Issue a warning in this case
  assign CLKS[ 28 ] = 1'b0;
  assign CLKS[ 29 ] = 1'b0;
  assign CLKS[ 30 ] = 1'b1;
  assign CLKS[ 31 ] = 1'b1;


  assign MUX_OUT = CLKS[ SEL ];

  xor u0(CLKOUT, INV, MUX_OUT);

  always @( SEL ) begin
    case ( SEL )
      8,9,10,11,12,13,14,15,28,29,30,31:
          $display (" Warning: Unsupported selection applied to the GPD MUX at time %0.1fns! Instance: %m", $realtime);
    endcase
  end
endmodule

////////////////////////////////////////////////////////////////
`timescale 1 ps/1 ps
module CCC_GPD (CLKIN, DIV, RESET, SYNC_RESET, NOPIPERSTSYNC,
                CLKOUT);

  input         CLKIN;
  input         RESET, SYNC_RESET, NOPIPERSTSYNC;
  input [7:0]   DIV;
  output        CLKOUT;

  wire          SYNC_RESET_int, CLKOUT_int;
  reg           SYNC_RESET_stg;

  parameter [150:0] ACT_CONFIG    = 150'h0;

  assign SYNC_RESET_int = NOPIPERSTSYNC ? SYNC_RESET : SYNC_RESET_stg;
  assign CLKOUT = CLKOUT_int & RESET;

  Freq_Divider #(.DIV_LENGTH(8), .DIV_FORMAT(0), .RESET_POLARITY(0))
    u0 (.CLKIN(CLKIN), .DIV(DIV), .CLKOUT(CLKOUT_int), .SYNC_RESET(SYNC_RESET_int), .ASYNC_RESET(1'b1));

  always @( posedge CLKIN ) begin
    SYNC_RESET_stg <= SYNC_RESET;
  end

endmodule



///////////////////////////////////////////////////////////////////
`timescale 1 ps/1 ps
module CCC_GPD_MUX0 (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    SEL, INV,
                    CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input [4:0] SEL;
  input       INV;
  output      CLKOUT;
  
  CCC_GPD_MUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                  .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                  .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                  .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                  .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                  .GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                  .SEL(SEL), .INV(INV),
                  .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[4:0] == 5'd16 ) ( CLK0_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd17 ) ( CLK1_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd18 ) ( CLK2_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd19 ) ( CLK3_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd20 ) ( CLK0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd21 ) ( CLK1            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd22 ) ( CLK2            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd23 ) ( CLK3            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd27 ) ( RCOSC_25_50MHZ  => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd26 ) ( RCOSC_1MHZ      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd25 ) ( XTLOSC          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd7  ) ( VCO0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd6  ) ( VCO45           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd5  ) ( VCO90           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd4  ) ( VCO135          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd3  ) ( VCO180          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd2  ) ( VCO225          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd1  ) ( VCO270          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd0  ) ( VCO315          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD_MUX1 (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    SEL, INV,
                    CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input [4:0] SEL;
  input       INV;
  output      CLKOUT;
  
  CCC_GPD_MUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                  .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                  .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                  .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                  .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                  .GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                  .SEL(SEL), .INV(INV),
                  .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[4:0] == 5'd16 ) ( CLK0_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd17 ) ( CLK1_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd18 ) ( CLK2_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd19 ) ( CLK3_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd20 ) ( CLK0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd21 ) ( CLK1            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd22 ) ( CLK2            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd23 ) ( CLK3            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd27 ) ( RCOSC_25_50MHZ  => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd26 ) ( RCOSC_1MHZ      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd25 ) ( XTLOSC          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd7  ) ( VCO0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd6  ) ( VCO45           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd5  ) ( VCO90           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd4  ) ( VCO135          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd3  ) ( VCO180          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd2  ) ( VCO225          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd1  ) ( VCO270          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd0  ) ( VCO315          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD_MUX2 (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    SEL, INV,
                    CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input [4:0] SEL;
  input       INV;
  output      CLKOUT;
  
  CCC_GPD_MUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                  .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                  .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                  .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                  .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                  .GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                  .SEL(SEL), .INV(INV),
                  .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[4:0] == 5'd16 ) ( CLK0_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd17 ) ( CLK1_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd18 ) ( CLK2_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd19 ) ( CLK3_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd20 ) ( CLK0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd21 ) ( CLK1            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd22 ) ( CLK2            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd23 ) ( CLK3            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd27 ) ( RCOSC_25_50MHZ  => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd26 ) ( RCOSC_1MHZ      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd25 ) ( XTLOSC          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd7  ) ( VCO0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd6  ) ( VCO45           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd5  ) ( VCO90           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd4  ) ( VCO135          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd3  ) ( VCO180          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd2  ) ( VCO225          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd1  ) ( VCO270          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd0  ) ( VCO315          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD_MUX3 (CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
                    CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
                    VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315,
                    SEL, INV,
                    CLKOUT);

  input       CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input       CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input       VCO0, VCO45, VCO90, VCO135, VCO180, VCO225, VCO270, VCO315;
  input [4:0] SEL;
  input       INV;
  output      CLKOUT;
  
  CCC_GPD_MUX u0 (.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                  .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                  .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                  .VCO0(VCO0), .VCO45(VCO45), .VCO90(VCO90), .VCO135(VCO135), 
                  .VCO180(VCO180), .VCO225(VCO225), .VCO270(VCO270), .VCO315(VCO315),
                  .GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                  .SEL(SEL), .INV(INV),
                  .CLKOUT(CLKOUT));
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    if ( SEL[4:0] == 5'd16 ) ( CLK0_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd17 ) ( CLK1_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd18 ) ( CLK2_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd19 ) ( CLK3_PAD        => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd20 ) ( CLK0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd21 ) ( CLK1            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd22 ) ( CLK2            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd23 ) ( CLK3            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd27 ) ( RCOSC_25_50MHZ  => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd26 ) ( RCOSC_1MHZ      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd25 ) ( XTLOSC          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd7  ) ( VCO0            => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd6  ) ( VCO45           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd5  ) ( VCO90           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd4  ) ( VCO135          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd3  ) ( VCO180          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd2  ) ( VCO225          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd1  ) ( VCO270          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    if ( SEL[4:0] == 5'd0  ) ( VCO315          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( SEL[0]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[1]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[2]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[3]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SEL[4]          => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( INV             => CLKOUT ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

/////////////////////////////////////////////////
`timescale 1 ps/1 ps
module CCC_GPD0 (CLKIN, DIV, RESET, SYNC_RESET, NOPIPERSTSYNC,
                CLKOUT);

  input         CLKIN;
  input         RESET, SYNC_RESET, NOPIPERSTSYNC;
  input [7:0]   DIV;
  output        CLKOUT;
    
  CCC_GPD u0(.CLKIN(CLKIN), .DIV(DIV),
             .RESET(RESET), .SYNC_RESET(SYNC_RESET), .NOPIPERSTSYNC(NOPIPERSTSYNC),
             .CLKOUT(CLKOUT));
                  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[0]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[1]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[2]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[3]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[4]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[5]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[6]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[7]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RESET           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SYNC_RESET      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NOPIPERSTSYNC   => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD1 (CLKIN, DIV, RESET, SYNC_RESET, NOPIPERSTSYNC,
                CLKOUT);

  input         CLKIN;
  input         RESET, SYNC_RESET, NOPIPERSTSYNC;
  input [7:0]   DIV;
  output        CLKOUT;
    
  CCC_GPD u0(.CLKIN(CLKIN), .DIV(DIV),
             .RESET(RESET), .SYNC_RESET(SYNC_RESET), .NOPIPERSTSYNC(NOPIPERSTSYNC),
             .CLKOUT(CLKOUT));
                  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[0]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[1]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[2]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[3]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[4]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[5]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[6]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[7]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RESET           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SYNC_RESET      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NOPIPERSTSYNC   => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD2 (CLKIN, DIV, RESET, SYNC_RESET, NOPIPERSTSYNC,
                CLKOUT);

  input         CLKIN;
  input         RESET, SYNC_RESET, NOPIPERSTSYNC;
  input [7:0]   DIV;
  output        CLKOUT;
    
  CCC_GPD u0(.CLKIN(CLKIN), .DIV(DIV),
             .RESET(RESET), .SYNC_RESET(SYNC_RESET), .NOPIPERSTSYNC(NOPIPERSTSYNC),
             .CLKOUT(CLKOUT));
                  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[0]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[1]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[2]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[3]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[4]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[5]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[6]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[7]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RESET           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SYNC_RESET      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NOPIPERSTSYNC   => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

`timescale 1 ps/1 ps
module CCC_GPD3 (CLKIN, DIV, RESET, SYNC_RESET, NOPIPERSTSYNC,
                CLKOUT);

  input         CLKIN;
  input         RESET, SYNC_RESET, NOPIPERSTSYNC;
  input [7:0]   DIV;
  output        CLKOUT;
    
  CCC_GPD u0(.CLKIN(CLKIN), .DIV(DIV),
             .RESET(RESET), .SYNC_RESET(SYNC_RESET), .NOPIPERSTSYNC(NOPIPERSTSYNC),
             .CLKOUT(CLKOUT));
                  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[0]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[1]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[2]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[3]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[4]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[5]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[6]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( DIV[7]          => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RESET           => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( SYNC_RESET      => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( NOPIPERSTSYNC   => CLKOUT)= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule
`timescale 1fs/1fs

`define MIN_REF_FREQ 64'd1_050_000_000
`define MAX_REF_FREQ 64'd4_750_000

`define MIN_DREF_FREQ 64'd1_050_000_000
`define MAX_DREF_FREQ 64'd4_750_000
`define MIN_DREF32K_FREQ 64'd32_812_500_000
`define MAX_DREF32K_FREQ 64'd29_687_500_000

`define MIN_VCO_1V0_FREQ 64'd4_200_000
`define MAX_VCO_1V0_FREQ 64'd1_900_000
`define MIN_VCO_1V2_FREQ 64'd2_100_000
`define MAX_VCO_1V2_FREQ 64'd950_000

`define MIN_OUT_FREQ 64'd52_500_000
`define MAX_OUT_1V0_FREQ 30'd1_800_000
`define MAX_OUT_1V2_FREQ 30'd900_000

`define PULSE_MIN 64'd1_000_000
`define RESET_PULSE_MIN 64'd1_000_000_000

`define MIN_FREQ_MOD 64'd40_000_000
`define MAX_FREQ_MOD 64'd20_000_000


//
// This module covers up to the creation of the two VCO signals
//
module  ABI_PLL_FRONT (
		REFCK,
		FB,
		BYPASS,
		RESET,
		PD,

		FSE,
		MODE32K,
		MODE_1V2,
		MODE_3V3,
		SSE,

		DIVR5,
		DIVR4,
		DIVR3,
		DIVR2,
		DIVR1,
		DIVR0,

		RANGE3,
		RANGE2,
		RANGE1,
		RANGE0,

		DIVF9,
		DIVF8,
		DIVF7,
		DIVF6,
		DIVF5,
		DIVF4,
		DIVF3,
		DIVF2,
		DIVF1,
		DIVF0,
		
		DIVQ2,
		DIVQ1,
		DIVQ0,

		SSMD1,
		SSMD0,
		SSMF4,
		SSMF3,
		SSMF2,
		SSMF1,
		SSMF0,

		LOCKWIN2,
		LOCKWIN1,
		LOCKWIN0,
		LOCKCNT3,
		LOCKCNT2,
		LOCKCNT1,
		LOCKCNT0,

		LOCK,
		vco4x_normal,
		vco4x_alt,
		vco_000,
		vco_000_alt,
		vco_045,
		vco_045_alt,
		vco_090,
		vco_090_alt,
		vco_135,
		vco_135_alt,
		vco_180,
		vco_180_alt,
		vco_225,
		vco_225_alt,
		vco_270,
		vco_270_alt,
		vco_315,
		vco_315_alt,
		reset_reg,
    divq_reset
);

//----------------------------------------------------------------------
// Port Declarations
//----------------------------------------------------------------------

// Input
  input     REFCK;    // Reference Clock
  input     FB;
  input     BYPASS; // Bypass - Active HIGH
  input     RESET;  // Reset  - Active HIGH
  input     PD;

  input     FSE;
  input     MODE32K;
  input     MODE_1V2;
  input     MODE_3V3;
  input     SSE;

  input     DIVR5;  // Reference Divider Control
  input     DIVR4;
  input     DIVR3;
  input     DIVR2;
  input     DIVR1;
  input     DIVR0;

  input     RANGE3;
  input     RANGE2;
  input     RANGE1;
  input     RANGE0;

  input     DIVF9;  // Feedback Divider Control
  input     DIVF8;
  input     DIVF7;
  input     DIVF6;
  input     DIVF5;
  input     DIVF4;
  input     DIVF3;
  input     DIVF2;
  input     DIVF1;
  input     DIVF0;

  input 	DIVQ2;
  input 	DIVQ1;
  input 	DIVQ0;
  
  input     SSMD1; // Controls Modulation Depth
  input     SSMD0;
  input     SSMF4; // Controls Modulation Frequency
  input     SSMF3;
  input     SSMF2;
  input     SSMF1;
  input     SSMF0;

  input     LOCKWIN2;  //No function in verilog
  input     LOCKWIN1;
  input     LOCKWIN0;

  input     LOCKCNT3;  //Delays LOCK from appearing
  input     LOCKCNT2;
  input     LOCKCNT1;
  input     LOCKCNT0;

// Output
  output    LOCK;   // PLL locked when HIGH
  output    vco4x_normal;
  output    vco4x_alt;

  output    vco_000;
  output    vco_000_alt;
  output    vco_045;
  output    vco_045_alt;
  output    vco_090;
  output    vco_090_alt;
  output    vco_135;
  output    vco_135_alt;
  output    vco_180;
  output    vco_180_alt;
  output    vco_225;
  output    vco_225_alt;
  output    vco_270;
  output    vco_270_alt;
  output    vco_315;
  output    vco_315_alt;


  output    reset_reg; //accounts for RANGE=0000 type of bypass
                       //needs to go to other modules
  output divq_reset;
  
  parameter integer FB_MULTIPLIER = 1;
  parameter VCOFREQUENCY = 0.0;
  
  reg warning_flag, ref_freq_chg, on_vco, on_flag, ff_lock;
  reg vco_low_flag, vco_high_flag;
  reg rFreq_low_flag, rFreq_high_flag, drFreq_low_flag, drFreq_high_flag;
//  reg oFreq_low_flag, oFreq_high_flag;
  reg pos_pulse_flag, neg_pulse_flag;
  reg lock_enabled_flag, pll_lock_reg, delay_lock_reg;
  reg ref_warn_flag, fse_warn_flag;
  reg [3:0] lock_count_reg;
  reg [3:0] fb_count;
  reg divided_ref, divided_fb;
  reg vco4x_ck, vco1x_ck, vco4x_ck0;
  reg vco2x_000_ck, vco2x_090_ck, vco2x_180_ck, vco2x_270_ck;
  reg vco_000_ck, vco_090_ck, vco_180_ck, vco_270_ck;
  reg vco_045_ck, vco_135_ck, vco_225_ck, vco_315_ck;
  reg vco_000_ck0, vco_090_ck0;
  reg vco_045_ck0, vco_135_ck0, vco_180_ck0;
  reg vco_225_ck0, vco_270_ck0, vco_315_ck0;
  reg range_byp, range_warn, reset_init;
  reg reset_pulse_flag, pd_pulse_flag;
  reg input_missing;
  reg vco01x_divwarning, vco01x_modwarning, vco01x_waitflag;
  reg [31:0] low_time_vco_count;
  

  time last_posedge_ref, last_negedge_ref, period_ref, period_ref1, period_ref2;
  time last_posedge_fb, period_fb, period_fb1, period_fb2, period_fb3, period_fb4;
  time last_posedge_divfb, period_divfb, last_posedge_divref, period_divref;
  time last_posedge_vco, period_vco;
  time last_posedge_vco4x, period_vco4x;
  time last_posedge_vco4x0, period_vco4x0;

  time low_time_vco, high_time_vco;
  time low_time_vco0, high_time_vco0; 
  time time_vco0, vco1x_ck_space;
  time time_vco4x0, vco4x_ck_space;
  time low_time_vco4x, high_time_vco4x;
  time low_time_vco4x_reg, high_time_vco4x_reg;
  time low_time_vco4x_reg_1, low_time_vco4x_reg_2, low_time_vco4x_reg_3;



  time last_posedge_reset, last_posedge_pd;
  time ref_time_passed;

  integer mult_divr, divider_divf, divider_divf_ss;
  integer mult_divr_dly, divider_divf_dly;
  integer divider_external, divider_external_dly;
  integer nb_ref_cycles, nb_fb_cycles, nb_divref_cycles, nb_divfb_cycles;
  integer nb_vco_cycles;
  integer nb_vco4x_cycles;
  integer lock_delay;
  integer fccc_divider_external;
  
  integer vco1x_ck_modset, vco1x_ck_mod;
  integer vco4x_ck_modset, vco4x_ck_mod;

  integer ref_div_count;  //This counter tracks the toggles in the REF pin
  // and controls when the divided_ref signal will toggle in response
  //in this fashion, the phase of divided_ref responds and changes with
  //changed in the phase of the external REF
  integer divf_count;  //Same for producing divided FB signal

  integer POM; //Period of modulation
  integer FOM; //Freq. of modulation
//  real POM; //Period of modulation

  real period_ref_real, period_fb_real, inner_freq_margin;
  real period_fb1_real, period_fb2_real,period_fb3_real, period_fb4_real;
  real fb_compare, fb_compare1, fb_compare2, fb_comp_skip;
  real period_divfb_real, period_divref_real;

  //
  //additional signals for spread spectrum
  //
  reg alt_vco4x_ck; //4x faster, to provide phase shifting capablilities
  reg alt_vco2x_000_ck, alt_vco2x_090_ck, alt_vco2x_180_ck, alt_vco2x_270_ck; //2x faster
  reg alt_vco_000_ck, alt_vco_090_ck, alt_vco_180_ck, alt_vco_270_ck; //normal speed vco, all 8 phases
  reg alt_vco_045_ck, alt_vco_135_ck, alt_vco_225_ck, alt_vco_315_ck;
  reg down_flag_DS, up_flag_DS; //stores **direction** of modulation depth

//  reg calculation_enable;  //related to LOCK?
  time period_vco_max;
  time period_vco4x_max;

  realtime change_per_cycle;
  realtime change_per_cycle4x;
  real fmod_constant = 251658.24;  //might change?
  real ssmd_percent; //modulation depth percent
  real ssmod_var; //just to see what we're calculating
  integer uber_cycle, ss_period_count; //Period of Modulation
  integer ss_period_count4x;
  integer ss_cycle_count;
  integer nb_alt_vco_cycles;
  integer nb_alt_vco4x_cycles;
//  wire forced_off, reset_wire, enabled;
  wire no_MF, no_SS;
  //


  wire on_wire;
  wire bypassi;

  wire ref_ck, fb_ext, fbi;
  wire fsei, reseti, pdi, ssei, mode32ki;
  wire range3i, range2i, range1i, range0i;
  wire divf9i, divf8i, divf7i, divf6i, divf5i, divf4i, divf3i, divf2i, divf1i, divf0i;
  wire divr5i, divr4i, divr3i, divr2i, divr1i, divr0i;
  wire ssmd1i, ssmd0i;
  wire ssmf4i, ssmf3i, ssmf2i, ssmf1i, ssmf0i;
  wire lockcnt3i, lockcnt2i, lockcnt1i, lockcnt0i;
  
  integer MULT_DIVQ;
//
  wire vco4x_normal, vco4x_alt;
  wire vco_000, vco_000_alt;
  wire vco_045, vco_045_alt;
  wire vco_090, vco_090_alt;
  wire vco_135, vco_135_alt;
  wire vco_180, vco_180_alt;
  wire vco_225, vco_225_alt;
  wire vco_270, vco_270_alt;
  wire vco_315, vco_315_alt;


//Internal signals
  buf u0   (ref_ck,REFCK);
  buf u1   (fb_ext,FB);
  buf u2   (fsei,FSE);
  buf u3   (reseti,RESET);
  buf u4   (ssei,SSE);
//  buf u5   (bypassi, BYPASS);
  buf u6   (mode32ki, MODE32K);
  buf u7   (pdi,PD);

  buf u13  (range3i,RANGE3);
  buf u12  (range2i,RANGE2);
  buf u11  (range1i,RANGE1);
  buf u10  (range0i,RANGE0);

  buf u25  (divr5i,DIVR5);
  buf u24  (divr4i,DIVR4);
  buf u23  (divr3i,DIVR3);
  buf u22  (divr2i,DIVR2);
  buf u21  (divr1i,DIVR1);
  buf u20  (divr0i,DIVR0);

  buf u39  (divf9i,DIVF9);
  buf u38  (divf8i,DIVF8);
  buf u37  (divf7i,DIVF7);
  buf u36  (divf6i,DIVF6);
  buf u35  (divf5i,DIVF5);
  buf u34  (divf4i,DIVF4);
  buf u33  (divf3i,DIVF3);
  buf u32  (divf2i,DIVF2);
  buf u31  (divf1i,DIVF1);
  buf u30  (divf0i,DIVF0);

  buf u46  (ssmd1i, SSMD1);
  buf u45  (ssmd0i, SSMD0);
  buf u44  (ssmf4i, SSMF4);
  buf u43  (ssmf3i, SSMF3);
  buf u42  (ssmf2i, SSMF2);
  buf u41  (ssmf1i, SSMF1);
  buf u40  (ssmf0i, SSMF0);

  buf u53  (lockcnt3i, LOCKCNT3);
  buf u52  (lockcnt2i, LOCKCNT2);
  buf u51  (lockcnt1i, LOCKCNT1);
  buf u50  (lockcnt0i, LOCKCNT0);
  

  buf u91  (LOCK,delay_lock_reg);
//  buf u93  (vco_normal,vco_ck);
//  buf u94  (vco_alt,alt_vco_ck);

  assign bypassi = ( BYPASS | range_byp ) ;

//
//  These muxes are re-written to provide more testability in verilog.
//  If the user does not drive BYPASS or RESET, it will cause an unknown
//  on the output to direct the user's attention to the problem.
//
//  assign pllouti = bypassi ? ref_ck  :
//                    reseti ? 1'b0  : 
//                reset_init ? pllout_ck : 1'b0;  If reset_init has not gone high, output does not start toggling
//  reset_init is internal, initialized to zero, so can only be zero or one, never 'x'
//

  assign reset_reg = pdi | reseti | bypassi | input_missing; //these signals power down PLL, set VCO low
  assign reset_pd = pdi | reseti ; //for the most part these signals are the same

  assign vco4x_normal = (reset_reg === 1'b1) ? 1'b0 :
                     ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco4x_ck : 1'b0 ) : 1'bx );

  assign vco_000 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_000_ck : 1'b0 ) : 1'bx );
  assign vco_045 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_045_ck : 1'b0 ) : 1'bx );
  assign vco_090 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_090_ck : 1'b0 ) : 1'bx );
  assign vco_135 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_135_ck : 1'b0 ) : 1'bx );
  assign vco_180 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_180_ck : 1'b0 ) : 1'bx );
  assign vco_225 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_225_ck : 1'b0 ) : 1'bx );
  assign vco_270 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_270_ck : 1'b0 ) : 1'bx );
  assign vco_315 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b1) ? vco_315_ck : 1'b0 ) : 1'bx );

// if SSMF[4:0] is all zeros, then we assume normal operation, no freq-mod
  assign no_MF = !(SSMF4 || SSMF3 || SSMF2 || SSMF1 || SSMF0);
  assign no_SS = ( !(SSMF4 || SSMF3 || SSMF2 || SSMF1 || SSMF0) | !SSE | MODE32K );

  assign vco4x_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco4x_ck : alt_vco4x_ck ) : 1'bx ) : 1'bx );

  assign vco_000_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_000_ck : alt_vco_000_ck ) : 1'bx ) : 1'bx );
  assign vco_045_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_045_ck : alt_vco_045_ck ) : 1'bx ) : 1'bx );
  assign vco_090_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_090_ck : alt_vco_090_ck ) : 1'bx ) : 1'bx );
  assign vco_135_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_135_ck : alt_vco_135_ck ) : 1'bx ) : 1'bx );
  assign vco_180_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_180_ck : alt_vco_180_ck ) : 1'bx ) : 1'bx );
  assign vco_225_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_225_ck : alt_vco_225_ck ) : 1'bx ) : 1'bx );
  assign vco_270_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_270_ck : alt_vco_270_ck ) : 1'bx ) : 1'bx );
  assign vco_315_alt = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? ((reset_init === 1'b0) ? 1'b0 : 
                                           (reset_init === 1'b1) ? ((no_SS === 1'b1) ? vco_315_ck : alt_vco_315_ck ) : 1'bx ) : 1'bx );

//  assign on_wire = bypassi ? 1'b0  :
//                    reseti ? 1'b0  : on_flag;
//
  assign on_wire = (reset_reg === 1'b1) ? 1'b0  :
                  ((reset_reg === 1'b0) ? on_flag : 1'b0 ) ;

  assign fbi = (fsei == 1'b1) ? vco_000_ck : //using UNMODDED vco in all cases
              ((fsei == 1'b0) ? fb_ext : 1'bx ) ;

  initial begin
    range_byp <= 1'b0;
    range_warn <= 1'b0;
    reset_init <= 1'b0;

    warning_flag <= 1'b1;
    ref_freq_chg <= 1'b0;
    on_vco <= 1'b0;
    on_flag <= 1'b0;
    ff_lock <= 1'b0;
    vco_low_flag <= 1'b0;
    vco_high_flag <= 1'b0;
    rFreq_low_flag <= 1'b0;
    rFreq_high_flag <= 1'b0;
    drFreq_low_flag <= 1'b0;
    drFreq_high_flag <= 1'b0;
    pos_pulse_flag <= 1'b0;
    neg_pulse_flag <= 1'b0;
    lock_enabled_flag <= 1'b0;
    pll_lock_reg <= 1'b0;
    delay_lock_reg <= 1'b0;

    lock_count_reg <= 4'b0000;
    fb_count <= 4'b0000;
    last_posedge_ref <= 0;
    last_negedge_ref <= 0;
    period_ref <= 0;
    period_ref1 <= 0;
    period_ref2 <= 0;
    last_posedge_fb <= 0;
    period_fb <= 0;
    period_fb1 <= 0;
    period_fb2 <= 0;
    period_fb3 <= 0;
    period_fb4 <= 0;
    last_posedge_vco <= 0;
    period_vco <= 0;
    low_time_vco <= 0;
    high_time_vco <= 0;
	low_time_vco0 <= 0;
	time_vco0 <= 0;
	time_vco4x0 <= 0;
    high_time_vco0 <= 0;
    last_posedge_divfb <= 0;
    period_divfb <= 0;
    last_posedge_divref <= 0;
    period_divref <= 0;
    ref_div_count <= 0;
    divf_count <= 0;
	vco01x_divwarning <= 0; 
	vco01x_modwarning <= 0;
	vco01x_waitflag <= 1'b0; 
	low_time_vco_count <= 32'b0;
	

    last_posedge_vco4x <= 0;
    period_vco4x <= 0;
    low_time_vco4x <= 0;
    high_time_vco4x <= 0;


    period_ref_real <= 0;
    period_fb_real <= 0;
    inner_freq_margin <= 0;
    period_fb1_real <= 0;
    period_fb2_real <= 0;
    fb_compare <= 0;
    fb_compare1 <= 0;
    fb_compare2 <= 0;
    fb_comp_skip <=0;
    period_divref_real <= 0;
    period_divfb_real <= 0;

    mult_divr <= 0;
	MULT_DIVQ <= 0;
	
    divider_divf <= 0;
    divider_divf_ss <= 0;
    mult_divr_dly <= 0;
    divider_divf_dly <= 0;
    divider_external <= (fccc_divider_external === 32'bx) ? 1 : fccc_divider_external;
    divider_external_dly <= 1;
    nb_ref_cycles <= 0;
    nb_fb_cycles <= 0;
    nb_vco_cycles <= 0;
    nb_vco4x_cycles <= 0;
    nb_divref_cycles <= 0;
    nb_divfb_cycles <= 0;
	
	vco4x_ck0 <= 1'b0;

    vco4x_ck <= 1'b0;
	vco1x_ck <= 1'b0;
	vco1x_ck_modset <= 0;
	vco1x_ck_mod <= 0;
	vco1x_ck_space <= 0;
	vco4x_ck_modset <= 0;
	vco4x_ck_mod <= 0;
	vco4x_ck_space <= 0;
    vco2x_000_ck <= 1'b0;
    vco2x_090_ck <= 1'b0;
    vco2x_180_ck <= 1'b0;
    vco2x_270_ck <= 1'b0;
    vco_000_ck <= 1'b0;
    vco_045_ck <= 1'b0;
    vco_090_ck <= 1'b0;
    vco_135_ck <= 1'b0;
    vco_180_ck <= 1'b0;
    vco_225_ck <= 1'b0;
    vco_270_ck <= 1'b0;
    vco_315_ck <= 1'b0;
	vco_000_ck0 <= 1'b0;
    vco_045_ck0 <= 1'b0;
    vco_090_ck0 <= 1'b0;
    vco_135_ck0 <= 1'b0;
	vco_180_ck0 <= 1'b0;
    vco_225_ck0 <= 1'b0;
    vco_270_ck0 <= 1'b0;
    vco_315_ck0 <= 1'b0;
	

    divided_ref <= 1'b0;
    divided_fb <= 1'b0;
    ref_time_passed <= 0;
    ref_warn_flag <= 1'b0;
    fse_warn_flag <= 1'b0;
    last_posedge_reset <= 0;
    reset_pulse_flag <= 1'b0;
    last_posedge_pd <= 0;
    pd_pulse_flag <= 1'b0;

    change_per_cycle <= 0.0;
    ss_cycle_count <= 0;
    down_flag_DS <= 1'b1; //always start down from origin
    up_flag_DS <= 1'b0;
    nb_alt_vco_cycles <= 0;
    change_per_cycle4x <= 0.0;
    nb_alt_vco4x_cycles <= 0;
    alt_vco4x_ck <= 1'b0;
    alt_vco2x_000_ck <= 1'b0;
    alt_vco2x_090_ck <= 1'b0;
    alt_vco2x_180_ck <= 1'b0;
    alt_vco2x_270_ck <= 1'b0;
    alt_vco_000_ck <= 1'b0;
    alt_vco_045_ck <= 1'b0;
    alt_vco_090_ck <= 1'b0;
    alt_vco_135_ck <= 1'b0;
    alt_vco_180_ck <= 1'b0;
    alt_vco_225_ck <= 1'b0;
    alt_vco_270_ck <= 1'b0;
    alt_vco_315_ck <= 1'b0;
    input_missing <= 1'b0;
  end

//
// Calculate counter integer values
//
always @(divr5i or divr4i or divr3i or divr2i or divr1i or divr0i)
  begin
    mult_divr <= {divr5i,divr4i,divr3i,divr2i,divr1i,divr0i} + 1;
  end

always @(DIVQ2 or DIVQ1 or DIVQ0)
  begin
    case ({DIVQ2,DIVQ1,DIVQ0})
	  3'b000: MULT_DIVQ <= 1;
	  3'b001: MULT_DIVQ <= 2;
	  3'b010: MULT_DIVQ <= 4;
	  3'b011: MULT_DIVQ <= 8;
	  3'b100: MULT_DIVQ <= 16;
	  3'b101: MULT_DIVQ <= 32;
	endcase
  end


  
always @(divf9i or divf8i or divf7i or divf6i or divf5i or divf4i or divf3i or divf2i or divf1i or divf0i)
  begin 
    divider_divf <= {divf9i,divf8i,divf7i,divf6i,divf5i,divf4i,divf3i,divf2i,divf1i,divf0i} + 1;
    divider_divf_ss <= {divf6i,divf5i,divf4i,divf3i,divf2i,divf1i,divf0i} + 1;
  end

//
// Calculate 'Period of Modulation' and Modulation Depth for spread spectrum
//
always @(SSMF4 or SSMF3 or SSMF2 or SSMF1 or SSMF0)
  begin

   if (!no_MF)
   begin
    /*changed IRM 1/31 for circuit change, added (1+MODE1V2') to equations : */
    //ssmod_var <= {SSMF4,SSMF3,SSMF2,SSMF1,SSMF0};
    if (MODE_1V2) ssmod_var <= ( {SSMF4,SSMF3,SSMF2,SSMF1,SSMF0} );
    else ssmod_var <= ( {SSMF4,SSMF3,SSMF2,SSMF1,SSMF0}*2 );
    //Period of Modulation -> (fmod_constant*period_vco) / {SSMF4 or SSMF3 or SSMF2 or SSMF1 or SSMF0} ;
    // we want the number of VCO periods in this overal period though:
    //uber_cycle <= fmod_constant / {SSMF4,SSMF3,SSMF2,SSMF1,SSMF0} ;
    if (MODE_1V2) uber_cycle <= fmod_constant / ({SSMF4,SSMF3,SSMF2,SSMF1,SSMF0}) ;
    else uber_cycle <= fmod_constant / ({SSMF4,SSMF3,SSMF2,SSMF1,SSMF0}*2) ;
   end
    //error-checking for undriven inputs:
    if ( ((SSMF4 !== 1'b0) && (SSMF4 !== 1'b1)) ||
         ((SSMF3 !== 1'b0) && (SSMF3 !== 1'b1)) ||
         ((SSMF2 !== 1'b0) && (SSMF2 !== 1'b1)) ||
         ((SSMF1 !== 1'b0) && (SSMF1 !== 1'b1)) ||
         ((SSMF0 !== 1'b0) && (SSMF0 !== 1'b1)) )
      begin
        $display ("Warning: SSMF went unknown. The model will continue to operate, but simulation results will not be accurate!");
        $display ("         Instance: %m. Simulation time is %t", $time);
      end
  end

always @( SSMD1 or SSMD0 )
  begin
    case ({SSMD1,SSMD0})
      2'b00: ssmd_percent <= 0; //no modification
      2'b01: ssmd_percent <= 0.005;
      2'b10: ssmd_percent <= 0.01;
      2'b11: ssmd_percent <= 0.015;
      default: begin
               ssmd_percent <= 0; //to prevent model from crashing
               $display ("Warning: SSMD went unknown. The model will continue to operate, but simulation results will not be accurate!");
               $display ("         Instance: %m. Simulation time is %t", $time);
               end
    endcase
  end

 /*always @(posedge ref_ck)
  begin
	if (vco01x_modwarning && !vco01x_divwarning)
	 begin
		$display ("**********************Attention********************** ");
		$display ("Warning : The input clock frequency is not divisible by the division factors selected in this configuration.");
		$display ("The PLL might not lock during simulation %0.1fps. Instance: %m",$realtime);
		$display ("***************************************************** ");
		vco01x_divwarning <= 1'b1; 
	 end 
  end*/  
 
//
// Calculate change-per-cycle for spread spectrum
//
always @(ssmd_percent or ssmod_var or on_vco) //whenever SSMD or SSMF changes
  begin

    if ((on_vco == 1'b1) && (ssei == 1'b1))
      begin
//        period_vco_max <= period_vco * ( 1.0 + ssmd_percent) ;
        period_vco_max <= (high_time_vco + low_time_vco) * ( 1.0 + ssmd_percent) ;
        ss_period_count <= uber_cycle/2 ;
//        change_per_cycle <= (period_vco*ssmd_percent) / (uber_cycle/2) ;
        change_per_cycle <= ((high_time_vco+low_time_vco)*ssmd_percent) / (uber_cycle/2) ;
/* For 4x VCO!!! */
        period_vco4x_max <= (high_time_vco4x + low_time_vco4x) * ( 1.0 + ssmd_percent) ;
        ss_period_count4x <= (uber_cycle/2) *4 ;  //so really, uber_cycle*2
//        change_per_cycle4x <= ((high_time_vco4x+low_time_vco4x)*ssmd_percent) / (uber_cycle/2) ;
        change_per_cycle4x <= ((high_time_vco4x+low_time_vco4x)*ssmd_percent) / (uber_cycle*2) ;

    //error-checking for Frequency of Modulation
    // outside of 25-50kHz range
    // (40,000,000,000 fs - 20,000,000,000 fs)
    // shortly after RESET, the 'period_vco' might still be zero
    // need to use 'high/low' times instead
            POM = ((uber_cycle/1000) * (high_time_vco + low_time_vco)) ;
            FOM = (10**9)/((uber_cycle/1000) * (high_time_vco + low_time_vco)) ; //the 10^9 will put it in kHz range
        if ( ((uber_cycle/1000) * (high_time_vco + low_time_vco)) > `MIN_FREQ_MOD )
          begin
            $display ("************************Attention************************");
            $display ("   The Frequency Modulation of the PLL is out of Range!  ");
            $display ("   With the current PLL settings, the Frequency Modulation ");
            $display ("   is too low (less than 25 kHz). The model will continue  ");
            $display ("   to operate, but simulation results will not be accurate! ");
            $display ("   This is likely due to the SSMF[4:0] pins, or the fre-.  ");
            $display ("   quency of the VCO. Please review the settings of the   ");
            $display ("   SSMF[4:0] pins and the divider settings that control    ");
            $display ("   VCO frequency, and rerun the simulation!                ");
            $display ("   Instance: %m. Simulation time is %t", $time);
            $display ("   Period of Modulation is %d picoseconds", POM);
            $display ("   Freq of Modulation is %d kHz", FOM);
            $display ("******************************************************** ");
          end
        if ( ((uber_cycle/1000) * (high_time_vco + low_time_vco)) < `MAX_FREQ_MOD )
          begin
            $display ("************************Attention************************");
            $display ("   The Frequency Modulation of the PLL is out of Range!  ");
            $display ("   With the current PLL settings, the Frequency Modulation ");
            $display ("   is too high (greater than 50 kHz). The model will con- ");
            $display ("   tinue to operate, but simulation results will not be    ");
            $display ("   accurate!                                               ");
            $display ("   This is likely due to the SSMF[4:0] pins, or the fre-.  ");
            $display ("   quency of the VCO. Please review the settings of the   ");
            $display ("   SSMF[4:0] pins and the divider settings that control    ");
            $display ("   VCO frequency, and rerun the simulation!                ");
            $display ("   Instance: %m. Simulation time is %t", $time);
            $display ("   Period of Modulation is %d picoseconds", POM);
            $display ("   Freq of Modulation is %d kHz", FOM);
            $display ("******************************************************** ");
          end
      end

  end


//
// Check for RESET initialization
//  (If RESET does not go high, PLL output will not toggle
always @(posedge reset_pd or posedge bypassi)
  begin
    reset_init <= 1'b1;
  end


//
// Calculate REF period, divided_ref period, vco variables
//
always @( vco_000 ) begin
  if ( period_ref != 0 ) begin
    if ( ($time - last_posedge_ref) > (10 * period_ref) ) begin
      input_missing <= 1'b1;
      //$display ("");
      $display ("**********************Attention********************** ");
      $display ("       There may be a problem with the REFCLK path.   ");
      $display ("                It may be stuck at %b!                ", ref_ck);
      $display ("   Instance: %m. Simulation time is %t", $time);
      $display ("***************************************************** ");
    end
  end
end

time period_ref_actual, compensation_stg2;
always @(posedge ref_ck)
  begin
    if (last_posedge_ref !== 0) 
      begin
        divider_external_dly <= divider_external;
        divider_divf_dly <= divider_divf;
        mult_divr_dly <= mult_divr;
        
        
        period_ref_actual = $time - last_posedge_ref;
        period_ref <= (period_ref_actual > period_ref) ? ((period_ref_actual - period_ref) > 10 ? period_ref_actual : period_ref_actual) : ((period_ref - period_ref_actual) > 10 ? period_ref_actual : period_ref);
        //period_ref <= $time - last_posedge_ref;
        period_ref_real <= $time - last_posedge_ref;
        if (!reset_reg) nb_ref_cycles <= nb_ref_cycles + 1;

    if ( (period_ref !== 0) && (reset_reg === 1'b0) )
      begin
////	
		if ( (mode32ki !== 1'b1) && (mode32ki !== 1'b0) )//making sure we have a value
          begin //warn before crash
           $display ("Error: MODE32K went unknown. The PLL will not operate!");
           $display ("       Instance: %m. Simulation time is %t", $time);
//            low_time_vco <= x; //will cause zero-delay oscillation error
//            high_time_vco <= x;
          end //if ( (mode32ki !== 1'b1) && (mode32ki !== 1'b0) )
////
        else if (mode32ki == 1'b1) //highest precedence path
          begin //additional div-256 in path!
            //$display ("first path!");
            low_time_vco <= (period_ref * mult_divr) / (divider_divf * 256 * 2);
			low_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf * 256 * 2);
			if ((period_ref * mult_divr * MULT_DIVQ) % (divider_divf * 256 * 2) != 0) vco01x_modwarning <= 1'b1;
            if (low_time_vco !==0)  high_time_vco <= (period_ref * mult_divr) / (divider_divf * 256) - low_time_vco;
            else high_time_vco <= (period_ref * mult_divr) / (divider_divf * 256 * 2);
			if (low_time_vco0 !==0)  high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf * 256) - low_time_vco0;
            else high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf * 256 * 2);
            //
            low_time_vco4x <= (period_ref * mult_divr) / (divider_divf * 256 * 2 *4);
            if (low_time_vco4x !==0)  high_time_vco4x <= (period_ref * mult_divr) / (divider_divf * 256 *4) - low_time_vco4x;
            else high_time_vco4x <= (period_ref * mult_divr) / (divider_divf * 256 * 2 *4);
          end //(mode32ki == 1'b1)
        else if (fsei == 1'b0) //and mode32ki = 0, normal external path
          begin
            //$display ("second path!");
            low_time_vco <= (period_ref * mult_divr) / (divider_external * divider_divf * 2);
			low_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_external * divider_divf * 2);
			if (((period_ref * mult_divr * MULT_DIVQ) % (divider_external * divider_divf * 2)) != 0) vco01x_modwarning <= 1'b1;
            if (low_time_vco !== 0) high_time_vco <= (period_ref * mult_divr) / (divider_external * divider_divf) - low_time_vco;
            else high_time_vco <= (period_ref * mult_divr) / (divider_external * divider_divf * 2);
			if ( (low_time_vco0 !== 0) && ((period_ref * mult_divr * MULT_DIVQ) / (divider_external * divider_divf) > low_time_vco0) ) 
        high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_external * divider_divf) - low_time_vco0;
      else 
        high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_external * divider_divf * 2);
            //
            low_time_vco4x <= (period_ref * mult_divr) / (divider_external * divider_divf * 2 *4);
            if (low_time_vco4x !== 0) //high_time_vco4x <= (period_ref * mult_divr) / (divider_external * divider_divf *4) - low_time_vco4x;
            high_time_vco4x <= (period_ref * mult_divr) / (divider_external * divider_divf *4 *2);
            else high_time_vco4x <= (period_ref * mult_divr) / (divider_external * divider_divf * 2 *4);
			
          end //(fsei == 1'b0)
        else if (ssei == 1'b0) //and mode32ki=0, fsei=1, normal internal path
          begin
            //$display ("third path!");
            low_time_vco <= (period_ref * mult_divr) / (divider_divf * 2);
			low_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf * 2);
			if ((period_ref * mult_divr * MULT_DIVQ) % (divider_divf * 2) != 0) vco01x_modwarning <= 1'b1;
            if (low_time_vco !==0)  high_time_vco <= (period_ref * mult_divr) / (divider_divf) - low_time_vco;
            else high_time_vco <= (period_ref * mult_divr) / (divider_divf * 2);
			if (low_time_vco0 !==0)  high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf) - low_time_vco0;
            else high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf * 2);
            //
            low_time_vco4x <= (period_ref * mult_divr) / (divider_divf * 2 *4);
            if (low_time_vco4x !==0)  high_time_vco4x <= (period_ref * mult_divr) / (divider_divf *4) - low_time_vco4x;
            else high_time_vco4x <= (period_ref * mult_divr) / (divider_divf * 2 *4);

          end //if (ssei == 1'b0)
        else //mode32ki=0,fsei=1,ssei=1 : Spread Spectrum!!
          begin
            //$display ("SSE mode!!");
            //calculations for normal(starting) vco
            low_time_vco <= (period_ref * mult_divr) / (divider_divf_ss * 8 * 2);
			low_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf_ss * 8 * 2);
			if ((period_ref * mult_divr * MULT_DIVQ) % (divider_divf_ss * 8 * 2) != 0) vco01x_modwarning <= 1'b1;
            if (low_time_vco !==0)  high_time_vco <= (period_ref * mult_divr) / (divider_divf_ss * 8) - low_time_vco;
            else high_time_vco <= (period_ref * mult_divr) / (divider_divf_ss * 8 * 2);
			if (low_time_vco0 !==0)  high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf_ss * 8) - low_time_vco0;
            else high_time_vco0 <= (period_ref * mult_divr * MULT_DIVQ) / (divider_divf_ss * 8 * 2);
            //
            low_time_vco4x <= (period_ref * mult_divr) / (divider_divf_ss * 8 * 2 *4);
            if (low_time_vco4x !==0)  high_time_vco4x <= (period_ref * mult_divr) / (divider_divf_ss * 8 *4) - low_time_vco4x;
            else high_time_vco4x <= (period_ref * mult_divr) / (divider_divf_ss * 8 * 2 *4);
		
          end //if ((fsei == 1'b1) && (ssei == 1'b1))

        //Track minimum negative pulse width
        if ( (($time - last_negedge_ref) < `PULSE_MIN ) && !neg_pulse_flag && delay_lock_reg )
          begin
           //$display ("");
           $display ("************************Attention************************");
           $display ("   The negative pulse of the incoming REFCK clock is too   ");
           $display ("   small! The minimum acceptable pulse width is 1ns. ");
           $display ("   The PLL verilog model will continue to operate, but   ");
           $display ("   the current simulation results may not be accurate!   ");
           //$display ("");
           $display ("   Please check the REFCK input signal, and rerun the      ");
           $display ("   simulation.                                           ");
           //$display ("");
           $display ("   Instance: %m. Simulation time is %t", $time);
           $display ("******************************************************** ");
           //$display ("");
           neg_pulse_flag <= 1'b1;
          end

      end //if (period_ref !== 0)

      end //if (last_posedge_ref !== 0)

        if ((period_ref !== 0) && !reset_reg && (low_time_vco != 0)) 
        begin
          on_vco <= 1'b1;
          on_flag <= 1'b1;
        end

    last_posedge_ref <= $time;
    if (period_ref1 !== 0) begin
      //period_ref2 <= (period_ref2 > period_ref1) ? ((period_ref2 - period_ref1) > 10 ? period_ref1 : period_ref2) : ((period_ref1 - period_ref2) > 10 ? period_ref1 : period_ref2);
      period_ref2 <= period_ref1;
    end
    if (period_ref !== 0) begin
      //period_ref1 <= (period_ref1 > period_ref) ? ((period_ref1 - period_ref) > 10 ? period_ref : period_ref1) : ((period_ref - period_ref1) > 10 ? period_ref : period_ref1);
      period_ref1 <= period_ref;
    end

    //
    // ERROR CHECKING to detect possible problems with the FB path
    //
    //for possible problems with feedback path
    if ( (fbi !== 1'b0) && (fbi !== 1'b1) )
      begin
        if (warning_flag == 1'b1)
          begin
            //$display ("");
            $display ("**********************Attention********************** ");
            $display ("The Feedback path (pin FB) is not properly connected. ");
            $display ("        Current results may not be accurate!!         ");
            //$display ("");
            $display ("   Simulation time is %t", $time);
            $display ("***************************************************** ");
            //$display ("");
            warning_flag <= 1'b0;	//warned, so turn it off
          end
      end
    if ( (nb_ref_cycles == 300) && (period_fb == 0) && (!reset_reg) && (fsei == 1'b0) )
      begin
        //$display ("");
        $display ("**********************Attention********************** ");
        $display ("       There may be a problem with the FB pin.        ");
        $display ("                It may be stuck at %b                 ", FB);
        $display (" The pulse coming out of the PLL VCO is taking a long ");
        $display ("      time to show up on the FB input of the PLL.     ");
        $display ("  Please check the feedback path and ensure that the  ");
        $display ("          simulation results are accurate.            ");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("***************************************************** ");
      end

    //check if frequency of incoming REF clock is out of spec
    if ( (period_ref !== 0) && !MODE32K )
      begin
        if ( (period_ref>`MIN_REF_FREQ) && !rFreq_low_flag && pll_lock_reg && delay_lock_reg )
          begin
           //$display ("");
           $display ("************************Attention************************");
           $display ("   The frequency of the incoming REFCK clock is too slow!  ");
           $display ("   The frequency is below 1MHz.                          ");
           $display ("   The PLL is operating out of spec, therefore the       ");
           $display ("   current simulation results may not be accurate!       ");
           //$display ("");
           $display ("   Please check the REFCK input signal, and rerun the      ");
           $display ("   simulation.                                           ");
           //$display ("");
           $display ("   Instance: %m. Simulation time is %t", $time);
           $display ("******************************************************** ");
           //$display ("");
           rFreq_low_flag <= 1'b1;
          end
        if ( (period_ref < `MAX_REF_FREQ) && !rFreq_high_flag && pll_lock_reg && delay_lock_reg )
          begin
           //$display ("");
           $display ("************************Attention************************");
           $display ("   The frequency of the incoming REFCK clock is too fast!  ");
           $display ("   The frequency is above 200MHz.                        ");
           $display ("   The PLL is operating out of spec, therefore the       ");
           $display ("   current simulation results may not be accurate!       ");
           //$display ("");
           $display ("   Please check the REFCK input signal, and rerun the      ");
           $display ("   simulation.                                           ");
           //$display ("");
           $display ("   Instance: %m. Simulation time is %t", $time);
           $display ("******************************************************** ");
           //$display ("");
           rFreq_high_flag <= 1'b1;
          end
      end //if ( (period_ref !== 0) && !MODE32K )

    //check to make sure RESET is initialized at some point, warn user if not
    if ( (nb_ref_cycles == 100) && (reset_init == 1'b0) ) begin
      //$display ("");
      $display ("**********************Attention**********************");
      $display ("   The verilog model has not been initialized yet!   ");
      $display ("   Neither the RESET, PD nor BYPASS pins have been   ");
      $display ("   asserted. Please check the RESET, PD and BYPASS   ");
      $display ("   pins.                                             ");
      //$display ("");
      $display ("  The PLL verilog model will not produce an output   ");
      $display ("  signal until RESET or PD is asserted and de-asserted,");
      $display ("  or BYPASS is asserted!                             ");
      //$display ("");
      $display ("   Instance: %m. Simulation time is %t", $time);
      $display ("*****************************************************");
      //$display ("");
    end
  end //always @(posedge ref_ck)

//
// Track minimum positive pulse width
//
always @(negedge ref_ck)
    begin
	if (last_posedge_ref !== 0)
	  begin
	    if ( (($time - last_posedge_ref) < `PULSE_MIN ) && !pos_pulse_flag && delay_lock_reg )
	          begin
	           //$display ("");
	           $display ("************************Attention************************");
	           $display ("   The positive pulse of the incoming REFCK clock is too   ");
	           $display ("   small!  The minimum acceptable pulse width is 1ns.");
	           $display ("   The PLL verilog model will continue to operate, but   ");
	           $display ("   the current simulation results may not be accurate!   ");
	           //$display ("");
	           $display ("   Please check the REFCK input signal, and rerun the      ");
	           $display ("   simulation.                                           ");
	           //$display ("");
	           $display ("   Instance: %m. Simulation time is %t", $time);
	           $display ("******************************************************** ");
	           //$display ("");
	           pos_pulse_flag <= 1'b1;
	          end
	  end
	last_negedge_ref <= $time;
    end

//
//DIVR block: either edge of REFCK
// this is where we do the dividing
always @(ref_ck)
// IRM 2011.02.11 : Need to use reset_reg instead of reset_pd to be consistent
//                  with what happens to REFCK variables getting cleared
//                  This will prevent false RANGE warnings, with bypass
  begin
    if ((last_posedge_ref == 0)&&(period_ref == 0)&&(ref_ck==1'b1) && !reset_reg)
    //This is the first REFCK cycle - above condition is only true
    // if this is the first time we enter this procedural block
      begin
        if (mult_divr == 1) divided_ref <= ref_ck; //unique case
        else divided_ref <= 1'b1; //start signal high
        ref_div_count <= #1 ref_div_count + 1;
      end
    else if ((ref_div_count < mult_divr) && (ref_div_count !== 0)&& !reset_reg)
      ref_div_count <= #1 ref_div_count +1; //dont toggle, increase the count
    else if ((ref_div_count == mult_divr)&& !reset_reg)
      begin
       divided_ref <= !divided_ref; //toggle!
       ref_div_count <= #1 1; //reset divider count, not to 0 or count is off
      end
  end

//
//Calculate divided-REFCK period
//
  always@(posedge divided_ref) begin
    if (last_posedge_divref !== 0) begin
      period_divref <= $time - last_posedge_divref;
      period_divref_real <=  $time - last_posedge_divref;
      nb_divref_cycles <= nb_divref_cycles + 1;
    end
    //error checking: to see if frequency of
    //divided_ref is out of spec
    if ( (period_divref !== 0) && MODE32K ) begin //32KHz mode - 31,250,000,000 fs, +/- 5%
      if ( (period_divref > `MIN_DREF32K_FREQ) && !drFreq_low_flag && pll_lock_reg && delay_lock_reg ) begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The frequency of the divided REFCK clock is too slow!   ");
        $display ("   The frequency is below 32KHz.                         ");
        $display ("   The PLL is operating out of spec, therefore the       ");
        $display ("   current simulation results may not be accurate!       ");
        //$display ("");
        $display ("   This is likely due to either the setting of MODE32K,  ");
        $display ("   DIVR, or the frequency of REFCK. Please check these     ");
        $display ("   values and rerun the simulation.                      ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("******************************************************** ");
        //$display ("");
        drFreq_low_flag <= 1'b1;
      end
      if ( (period_divref < `MAX_DREF32K_FREQ) && !drFreq_high_flag && pll_lock_reg && delay_lock_reg ) begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The frequency of the divided REFCK clock is too fast!   ");
        $display ("   The frequency is above 32KHz.                         ");
        $display ("   The PLL is operating out of spec, therefore the       ");
        $display ("   current simulation results may not be accurate!       ");
        //$display ("");
        $display ("   This is likely due to either the setting of MODE32K,  ");
        $display ("   DIVR, or the frequency of REFCK. Please check these     ");
        $display ("   values and rerun the simulation.                      ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("******************************************************** ");
        //$display ("");
        drFreq_high_flag <= 1'b1;
      end
    end //if ( (period_divref !== 0) && MODE32K )

    if ( (period_divref !== 0) && !MODE32K ) begin
	    if ( (period_divref > `MIN_DREF_FREQ) && !drFreq_low_flag && pll_lock_reg && delay_lock_reg ) begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The frequency of the divided REFCK clock is too slow!   ");
        $display ("   The frequency is below 1MHz.                          ");
        $display ("   The PLL is operating out of spec, therefore the       ");
        $display ("   current simulation results may not be accurate!       ");
        //$display ("");
        $display ("   This is likely due to either the setting of DIVR, or  ");
        $display ("   the frequency of REFCK. Please check these values and   ");
        $display ("   rerun the simulation.                                 ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("******************************************************** ");
        //$display ("");
        drFreq_low_flag <= 1'b1;
      end
	    if ( (period_divref < `MAX_DREF_FREQ) && !drFreq_high_flag && pll_lock_reg && delay_lock_reg ) begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The frequency of the divided REFCK clock is too fast!   ");
        $display ("   The frequency is above 200MHz.                        ");
        $display ("   The PLL is operating out of spec, therefore the       ");
        $display ("   current simulation results may not be accurate!       ");
        //$display ("");
        $display ("   This is likely due to either the setting of DIVR, or  ");
        $display ("   the frequency of REFCK. Please check these values and   ");
        $display ("   rerun the simulation.                                 ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("******************************************************** ");
        //$display ("");
        drFreq_high_flag <= 1'b1;
      end //if ( (period_divref !== 0) && !MODE32K )
	  end
    last_posedge_divref <= $time;
  end

//
// Calculate lock delay
//
always @(lockcnt3i or lockcnt2i or lockcnt1i or lockcnt0i)
  begin
    //lock_delay <= 2**({lockcnt3i,lockcnt2i,lockcnt1i,lockcnt0i}+5);
    // To speed up the PLL lock (SAR54180).
    lock_delay <= 0;
  end

// need to have this in a separate block so that LOCK goes low when needed.
always@(nb_divref_cycles or reset_reg)
  begin
    if (lock_enabled_flag === 1'b1)
     begin
      if (nb_divref_cycles >= lock_delay) delay_lock_reg <= 1'b1;
      else delay_lock_reg <= 1'b0;
     end
    else // !lock_enabled_flag
     delay_lock_reg <= 1'b0;
  end

//
// RANGE bit functionality check
//  The RANGE bits are analog, but this will give the user
//  a warning if the RANGE bits do not appear to be set
//  appropriately
//
always @(posedge divided_ref)
  begin
    case({range3i,range2i,range1i,range0i})
      4'b0000:  range_byp <= 1'b1;
      4'b0001:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > `MIN_DREF_FREQ) || (period_divref < 625_000_000) )
                    begin //1-1.6MHz
               //$display ("");
                     if (fccc_divider_external !== 32'bx) begin
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0010:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 625_000_000) || (period_divref < 384_615_000) )
                    begin //1.6-2.6MHz
                      if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0011:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 384_616_000) || (period_divref < 238_095_000) )
                    begin //2.6-4.2MHz
                     if (fccc_divider_external !== 32'bx) begin
                        //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0100:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 238_096_000) || (period_divref < 147_058_000) )
                    begin //4.2-6.8MHz
                     if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0101:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 147_059_000) || (period_divref < 90_908_000) )
                    begin //6.8-11MHz
                     if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0110:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 90_910_000) || (period_divref < 55_555_000) )
                    begin //11-18MHz
                      if (fccc_divider_external !== 32'bx) begin
                         //$display ("");
                         $display ("************************Attention************************");
                         $display ("   The frequency of the Post-divider Reference Clock is  ");
                         $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                         $display ("   grammed correctly, or the DIVR divider is not program-");
                         $display ("   med correctly. The model will continue to operate, but");
                         $display ("   simulation results may not be accuate!                ");
                         $display ("   Instance: %m. Simulation time is %t", $time);
                         $display ("******************************************************** ");
                         //$display ("");
                       end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b0111:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 55_556_000) || (period_divref < 34_482_000) )
                    begin //18-29MHz
                     if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b1000:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                    if ( (period_divref > 34_483_000) || (period_divref < 21_738_500) )
                    begin //29-46MHz
                      if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b1001:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 21_740_000) || (period_divref < 13_333_000) )
                    begin //46-75MHz
                      if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                     end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b1010:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 13_334_000) || (period_divref < 8_333_000) )
                    begin //75-120MHz
                      if (fccc_divider_external !== 32'bx) begin
                       //$display ("");
                       $display ("************************Attention************************");
                       $display ("   The frequency of the Post-divider Reference Clock is  ");
                       $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                       $display ("   grammed correctly, or the DIVR divider is not program-");
                       $display ("   med correctly. The model will continue to operate, but");
                       $display ("   simulation results may not be accuate!                ");
                       $display ("   Instance: %m. Simulation time is %t", $time);
                       $display ("******************************************************** ");
                       //$display ("");
                      end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b1011:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
                   if ( (period_divref > 8_334_000) || (period_divref < `MAX_DREF_FREQ) )
                    begin //120-200MHz
                      if (fccc_divider_external !== 32'bx) begin
                         //$display ("");
                         $display ("************************Attention************************");
                         $display ("   The frequency of the Post-divider Reference Clock is  ");
                         $display ("   out of range! Either the RANGE[3:0] pins are not pro- ");
                         $display ("   grammed correctly, or the DIVR divider is not program-");
                         $display ("   med correctly. The model will continue to operate, but");
                         $display ("   simulation results may not be accuate!                ");
                         $display ("   Period = %fps  %f", period_divref, 8_334_000);
                         $display ("   Instance: %m. Simulation time is %t", $time);
                         $display ("******************************************************** ");
                         //$display ("");
                       end
               range_warn <= 1'b1;
                       end
                  end
                end
      4'b1100:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
               //$display ("");
               $display ("************************Attention************************");
               $display ("   Invalid Range. Either the RANGE[3:0] pins are not pro- ");
               $display ("   grammed correctly, or the DIVR divider is not program-");
               $display ("   med correctly. The model will continue to operate, but");
               $display ("   simulation results may not be accuate!                ");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
               range_warn <= 1'b1;
                  end
                end
      4'b1101:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
               //$display ("");
               $display ("************************Attention************************");
               $display ("   Invalid Range. Either the RANGE[3:0] pins are not pro- ");
               $display ("   grammed correctly, or the DIVR divider is not program-");
               $display ("   med correctly. The model will continue to operate, but");
               $display ("   simulation results may not be accuate!                ");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
               range_warn <= 1'b1;
                  end
                end
      4'b1110:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
               //$display ("");
               $display ("************************Attention************************");
               $display ("   Invalid Range. Either the RANGE[3:0] pins are not pro- ");
               $display ("   grammed correctly, or the DIVR divider is not program-");
               $display ("   med correctly. The model will continue to operate, but");
               $display ("   simulation results may not be accuate!                ");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
               range_warn <= 1'b1;
                  end
                end
      4'b1111:  begin
                 range_byp <= 1'b0;
                 if ( (period_divref !== 0) && (range_warn == 1'b0) && !reset_reg && !mode32ki && delay_lock_reg)
                  begin
               //$display ("");
               $display ("************************Attention************************");
               $display ("   Invalid Range. Either the RANGE[3:0] pins are not pro- ");
               $display ("   grammed correctly, or the DIVR divider is not program-");
               $display ("   med correctly. The model will continue to operate, but");
               $display ("   simulation results may not be accuate!                ");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
               range_warn <= 1'b1;
                  end
                end
    endcase
  end


//
// Calculate FB period (external FB mode only)
//	also checks for FB consistency
//
  always @(posedge fbi)
    begin
	if (fsei == 1'b0)
	    begin
	    if (reset_pd)
		begin
		  fb_count <= 4'b0000;
		  ff_lock <= 1'b0;
		end
	    else
		begin
		  if ( (period_fb2 !== 0) && (period_fb1 !== 0) && (period_fb !== 0) )
			fb_compare = period_fb1_real / period_fb2_real;
		  if ( (period_fb3 !== 0) && (period_fb2 !== 0) && (period_fb1 !== 0) )
			fb_compare1 <= period_fb2_real / period_fb3_real;
		  if ( (period_fb4 !== 0) && (period_fb3 !== 0) && (period_fb2 !== 0) )
			fb_compare2 <= period_fb3_real / period_fb4_real;
		  if (period_fb4 !== 0)
			fb_comp_skip <= period_fb1_real / period_fb4_real;

		  if( ff_lock == 1'b0)
		    //if we havent locked a frequency yet
		    begin
			if ( (fb_compare < 0.99) || (fb_compare > 1.01) )
			//out of acceptable range
			    begin
				fb_count <= 4'b0000;
				ff_lock <= 1'b0;
			    end		
			else				//w-in range, count accordingly
			    begin
				//if (fb_count < 6'b1010)
        if (fb_count < 6'b1)
				    begin
					fb_count <= fb_count + 1'b1;
					ff_lock <= 1'b0;
				    end
				else
					if ((period_divfb !==0) && (period_divref !== 0)) ff_lock <=1'b1;
					//lock signal ONLY goes high when we have non-zero number
					//to calculate external divider
			    end
		    end
		  else //ff_lock = 1
		    //we've locked freq, so we want to make sure we dont unlock for unwanted reasons
		    begin
			if ( ((fb_compare < 0.99) || (fb_compare > 1.01)) &&
			    ((fb_compare1 < 0.99) || (fb_compare1 > 1.01)) &&
			    ((fb_compare2 < 0.99) || (fb_compare2 > 1.01)) )
			//if fb_compare is out of spec for 3 cycles,
			//go ahead and unlock
			    begin
				fb_count <= 4'b0000;
				ff_lock <= 1'b0;
			    end
			else if ( ((fb_compare1 < 0.99) || (fb_compare1 > 1.01)) &&
			          ((fb_compare2 < 0.99) || (fb_compare2 > 1.01)) &&
			          ((fb_comp_skip < 0.99) || (fb_comp_skip > 1.01)) )
			    begin
				fb_count <= 6'b0000;
				ff_lock <= 1'b0;
			    end
		    end
		end
	    end

	if (last_posedge_fb !== 0 && !bypassi) 
	    begin
		period_fb <= $time - last_posedge_fb;
		period_fb_real <=  $time - last_posedge_fb;
		nb_fb_cycles <= nb_fb_cycles +1;
	    end

	last_posedge_fb <= $time;

    //To detect any change in FB period:
	if (period_fb3 !== 0)
	    begin
		period_fb4 <= period_fb3;
		period_fb4_real <= period_fb3_real;
	    end
	if (period_fb2 !== 0)
	    begin
		period_fb3 <= period_fb2;
		period_fb3_real <= period_fb2_real;
	    end
	if (period_fb1 !== 0)
	    begin
		period_fb2 <= period_fb1;
		period_fb2_real <= period_fb1_real;
	    end
	if (period_fb !== 0)
	    begin
		period_fb1 <= period_fb;
		period_fb1_real <= period_fb_real;
	    end

//For external FB, drive divided_fb
	if ( (divider_divf > 1) && (fsei == 0) ) begin
	if ((divf_count == 0) && !bypassi && !reset_pd)
	    begin
		divided_fb <= 1'b1;
		divf_count <= divider_divf - 1;
	    end
	if ((divf_count !== 0) && !bypassi && !reset_pd) 
	    begin
		divided_fb <= 1'b0;
		divf_count <= divf_count - 1;
	    end
	if (bypassi || reset_pd) 
	    begin
		divided_fb <= 1'b0;
		divf_count <= 0;
	    end
	end

    end

//
//For external FB, drive divided_fb
//
always@(fbi)
  begin
    if ((divider_divf == 1) && (fsei == 0))
         divided_fb <= fbi;
  end

//
//Calculate FB and REFCK periods post-dividers
//
always@(posedge divided_fb)
  begin
    if (last_posedge_divfb !== 0) 
      begin
        period_divfb <= $time - last_posedge_divfb;
        period_divfb_real <=  $time - last_posedge_divfb;
      end
   last_posedge_divfb <= $time;
  end


//
// Check for any external dividers/multipliers 
//
always @(posedge ff_lock)
  begin
    if (reset_pd)
      divider_external = (fccc_divider_external === 32'bx) ? 1 : fccc_divider_external;
    else
      begin
        if (fsei == 1'b0)
          begin
            if ((period_divref !== 0) && (period_divfb !==0))
              begin
                if ( ((period_divfb_real / period_divref_real) < 0.99 ) || ((period_divfb_real / period_divref_real) > 1.01 ) ) begin
                  divider_external = (period_divfb_real > period_divref_real) ? ( (period_divfb_real / period_divref_real) ) : 1;
                end
              end
          end
      end
  end

//
//Get post-divider measurements for LOCK
//
always @(posedge divided_ref or posedge divided_fb)
  begin
    if ((period_divref) != 0)
      inner_freq_margin <= ((period_divfb_real)/(period_divref_real));
    else
      inner_freq_margin <= 0;
  end

always @(posedge ref_ck)
  begin
    if (!on_wire)	//resetting
      begin
        lock_count_reg <= 4'b0000;
        lock_enabled_flag <= 1'b0;
      end
      else if (fsei == 1'b0)
        begin
          if ( ((inner_freq_margin >= 0.99) || (inner_freq_margin <= 1.01)) && (lock_count_reg == 4'h4) )
            begin
             //count remains at 10
             lock_enabled_flag <= 1'b1;
            end
          if ( ((inner_freq_margin >= 0.99) || (inner_freq_margin <= 1.01)) && (lock_count_reg < 4'h4) )
            begin
              lock_count_reg <= lock_count_reg + 4'b0001;	//count increments
              lock_enabled_flag <= 1'b0;
            end
          if ( ((inner_freq_margin < 0.99) || (inner_freq_margin > 1.01)) )	//out of range
            begin
              lock_count_reg <= 4'b0000;	//count resets to zero
              lock_enabled_flag <= 1'b0;
            end
        end
      else if (fsei == 1'b1)
        begin
          if (nb_ref_cycles > 2)
            lock_enabled_flag <= 1'b1;
        end
  end

//
// Drive LOCK
//
always @ (lock_enabled_flag or on_flag or ref_warn_flag or fse_warn_flag)
  begin
    if (on_flag && lock_enabled_flag && reset_init && !ref_warn_flag && !fse_warn_flag)
      //if not in reset, bypass, or REFCK stops toggling
      pll_lock_reg <= 1'b1;
    else
      //either reset, or not locked
      pll_lock_reg <= 1'b0;
  end

//
// Drive vco_ck4x (NORMAL)
//
time phase_shift, phase_shift_low;
real last_posedge_ref_real, last_posedge_fb_real, last_negedge_ref_real, last_negedge_fb_real;
reg divq_reset;

always @(posedge ref_ck) begin
  last_posedge_ref_real = $realtime;
end
always @(posedge fbi) begin
  last_posedge_fb_real = $realtime;
end
always @(negedge ref_ck) begin
  last_negedge_ref_real = $realtime;
end
always @(negedge fbi) begin
  last_negedge_fb_real = $realtime;
end

always @(negedge ref_ck) begin
  if ( (lock_count_reg > 0) && (last_posedge_fb_real != 0) )
    phase_shift = (last_posedge_fb_real-last_posedge_ref_real)/50;
  else
    phase_shift = 0;
end
always @(posedge ref_ck) begin
  if ( (lock_count_reg > 0) && (last_negedge_fb_real != 0) )
    phase_shift_low = (last_negedge_fb_real-last_negedge_ref_real)/50;
  else
    phase_shift_low = 0;
end

integer count_edges;
time compensate_neg;
integer count_limit;

always begin

  if (on_vco & !divq_reset) begin
	vco1x_ck_mod <= period_ref % (low_time_vco0 + high_time_vco0); //period/output remainder 
	vco1x_ck_space <= (period_ref - (period_ref % (low_time_vco0 + high_time_vco0)))/(period_ref % (low_time_vco0 + high_time_vco0) + 1); //Spacing between added remainders 
	if (period_ref % (low_time_vco0 + high_time_vco0) != 0) //Odd division of reference clock 
	begin
		vco1x_ck <= 1'b1 & !divq_reset;
		if ((time_vco0 + low_time_vco0) < (period_ref - (period_ref % (low_time_vco0 + high_time_vco0)))/(period_ref % (low_time_vco0 + high_time_vco0) + 1))
		begin
			time_vco0 <= time_vco0 + low_time_vco0;
			vco01x_waitflag <= 1'b1;
			#(low_time_vco0);
			vco01x_waitflag <= 1'b0;
		end 
		else if ((time_vco0 + low_time_vco0) >= vco1x_ck_space &&	vco1x_ck_modset != vco1x_ck_mod)
		begin 
			time_vco0 <= (time_vco0 + low_time_vco0 + 1) - vco1x_ck_space; 
			vco1x_ck_modset <= vco1x_ck_modset + 1;
			vco01x_waitflag <= 1'b1;
			#(low_time_vco0 + 1);
			vco01x_waitflag <= 1'b0;
		end
		else if ((time_vco0 + low_time_vco0) >= vco1x_ck_space &&	vco1x_ck_modset == vco1x_ck_mod)
		begin
			time_vco0 <= 0; 
			vco1x_ck_modset <= 0;
			vco01x_waitflag <= 1'b1;
			#(low_time_vco0);
			vco01x_waitflag <= 1'b0;
		end 
		vco1x_ck <= 1'b0 & !divq_reset;
		if (high_time_vco0 > (low_time_vco0*3/2)) 
		 begin
		  vco01x_waitflag <= 1'b1;
		  #low_time_vco0;
		  vco01x_waitflag <= 1'b0;
		 end 
		else 
		begin
		  if (time_vco0 + high_time_vco0 < vco1x_ck_space)
			begin
				time_vco0 <= time_vco0 + high_time_vco0; 
				#(high_time_vco0);
			end 
		  else if ((time_vco0 + high_time_vco0 >= vco1x_ck_space) && 
			vco1x_ck_modset != vco1x_ck_mod) 
			begin 
				time_vco0 <= (time_vco0 + low_time_vco0 + 1) - vco1x_ck_space; 
				vco1x_ck_modset <= vco1x_ck_modset + 1;
				#(high_time_vco0 + 1);
			end
	       else if ((time_vco0 + high_time_vco0 >= vco1x_ck_space) && 
			vco1x_ck_modset == vco1x_ck_mod) 
			begin
				time_vco0 <= 0; 
				vco1x_ck_modset <= 0;
				#(high_time_vco0);
			end 
		end 
  end 
	else //Even division of reference clock 
	begin
		vco1x_ck <= 1'b1 & !divq_reset;
		vco01x_waitflag <= 1'b1;
    #(low_time_vco0);
		vco01x_waitflag <= 1'b0;
		vco1x_ck <= 1'b0 & !divq_reset;
		if (high_time_vco0 > (low_time_vco0*3/2)) 
		  #low_time_vco0;
		else
		  #(high_time_vco0);
	end 
  end
  else  begin
    vco1x_ck <= 1'b0;
    vco1x_ck_modset <= 0;
    vco_000_ck0 <= 1'b0;
    vco_045_ck0 <= 1'b0;
    vco_090_ck0 <= 1'b0;
    vco_135_ck0 <= 1'b0;
    vco_180_ck0 <= 1'b0;
    vco_225_ck0 <= 1'b0;
    vco_270_ck0 <= 1'b0;
    vco_315_ck0 <= 1'b0;
    time_vco0 <= 0; 
    wait (on_vco & !divq_reset);
  end
end

always @(posedge ref_ck) begin
  if ( divq_reset ) begin
    count_edges <= count_limit;
    compensate_neg <= 0;
    if ( (divider_external * divider_divf) > (mult_divr * MULT_DIVQ) )
      count_limit = ( (mult_divr * MULT_DIVQ) / GCD((divider_external * divider_divf), (mult_divr * MULT_DIVQ)) - 1 ) ;
    else
      count_limit = ( (mult_divr * MULT_DIVQ) / GCD((mult_divr * MULT_DIVQ), (divider_external * divider_divf)) - 1 ) ;
  end
  else begin
    if ( fccc_divider_external === 32'bx ) begin
      if (count_edges == 0)
      begin
        count_edges = count_limit;
        vco1x_ck = 1'b1;
        compensate_neg <= $time;
      end
      else 
        count_edges = count_edges - 1;
    end
  end
end

/*always @(negedge ref_ck) begin
  if ( !divq_reset ) begin
    if ( fccc_divider_external === 32'bx ) begin
      if ( ((period_ref / (low_time_vco0 + high_time_vco0)) % 3) == 1 )
        vco1x_ck = 1'b0;
      else if ( ((period_ref / (low_time_vco0 + high_time_vco0)) % 2) == 1 )
        vco1x_ck = 1'b1;
    end
  end
end*/

always begin
  if (on_vco & !divq_reset) begin
    vco4x_ck <= 1'b1 & !divq_reset;
		#(low_time_vco4x);
		vco4x_ck <= 1'b0 & !divq_reset;
		if (high_time_vco4x > (low_time_vco4x*3/2)) 
      #low_time_vco4x;
		else 
      #(high_time_vco4x);


  end
	else begin
		vco4x_ck <= 1'b0;


		wait (on_vco & !divq_reset);
  end
end

//
// Create the vco2x clocks, 0/90/180/270 phase shifts
//

always@(vco1x_ck) begin
	if ( (!divq_reset) && (fccc_divider_external !== 32'bx) ) begin
		vco_045_ck0 <= #((low_time_vco0 + high_time_vco0)/8)	 vco1x_ck;
		vco_090_ck0 <= #((low_time_vco0 + high_time_vco0)/4) 	 vco1x_ck;
		vco_135_ck0 <= #((low_time_vco0 + high_time_vco0)*3/8)   vco1x_ck;
		vco_180_ck0 <= #((low_time_vco0 + high_time_vco0)/2)     vco1x_ck;
		vco_225_ck0 <= #((5*(low_time_vco0 + high_time_vco0))/8) vco1x_ck;
		vco_270_ck0 <= #((6*(low_time_vco0 + high_time_vco0))/8) vco1x_ck;
		vco_315_ck0 <= #((7*(low_time_vco0 + high_time_vco0))/8) vco1x_ck;
 end
 else begin
  vco_045_ck0 <= 1'b0;
		vco_090_ck0 <= 1'b0;
		vco_135_ck0 <= 1'b0;
		vco_180_ck0 <= 1'b0;
		vco_225_ck0 <= 1'b0;
		vco_270_ck0 <= 1'b0;
		vco_315_ck0 <= 1'b0;
 end
end 
  
initial begin
  divq_reset = 1'b0;
  low_time_vco4x_reg = 0;
  low_time_vco4x_reg_1 = 0;
  low_time_vco4x_reg_2 = 0;
  low_time_vco4x_reg_3 = 0;
end

always @(*) divq_reset <= (low_time_vco4x_reg == low_time_vco4x) ? 1'b0 : 1'b1;
always @(posedge ref_ck) begin
  if (low_time_vco4x != 0) begin
    // [HH] SAR60107 Had to increase the width of divq_reset to handle changes in low_time_vco while divq_reset being active.
    divq_reset <= (low_time_vco4x_reg !== low_time_vco4x) ? 1'b1 : 1'b0;
    high_time_vco4x_reg = low_time_vco4x;
    if (low_time_vco_count != 0) begin
      low_time_vco4x_reg_1 <= low_time_vco4x;
      low_time_vco_count <= low_time_vco_count - 1; 
    end 
    else low_time_vco4x_reg <= low_time_vco4x_reg_1;
  end
end

time period_ref_chg, period_ref_prev;
always @(period_ref) begin
  period_ref_chg = (period_ref_prev > period_ref) ? (period_ref_prev - period_ref) : (period_ref - period_ref_prev);
  period_ref_prev <= period_ref;
end

time low_time_vco0_chg, low_time_vco0_prev;
always @(low_time_vco0) begin
  low_time_vco0_chg = (low_time_vco0_prev > low_time_vco0) ? (low_time_vco0_prev - low_time_vco0) : (low_time_vco0 - low_time_vco0_prev);
  low_time_vco0_prev <= low_time_vco0;
end

always @(*)
begin
	if ( (period_ref != 0) )
	 begin
		// [HH] SAR60952
    // To sync the divq_reset with the 2 clocks we need to find the LCD of the 2 frequencies:
    //  - This is mainly needed for IP PLL, not the fabric PLL.
    low_time_vco_count <= ( (fccc_divider_external === 32'bx) && ((divider_external * divider_divf) > 2) ) ? (divider_external * divider_divf) : 2;
	 end 
end 

/*  always begin
	if (on_vco) begin
		vco4x_ck <= 1'b1;
		#(low_time_vco4x);
		vco4x_ck <= 1'b0;
		if (high_time_vco4x > (low_time_vco4x*3/2)) #low_time_vco4x;
		//else #(high_time_vco4x-phase_shift);
    else #(high_time_vco4x);
		nb_vco4x_cycles <= nb_vco4x_cycles + 1;
		if (bypassi) last_posedge_vco4x <= 0;
	    end
	else
	    begin
		vco4x_ck <= 1'b0;
		wait (on_vco);
	    end
    end
  */

//
// Create the vco2x clocks, 0/90/180/270 phase shifts
//
always@(posedge vco4x_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco2x_000_ck <= 1'b0;
        vco2x_180_ck <= 1'b0;
        last_posedge_vco4x <= 0;
        period_vco4x <= 0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco2x_000_ck <= !vco2x_000_ck;
        vco2x_180_ck <= vco2x_000_ck;  //stale value of 000_ck, so will be 180-deg shifted
        last_posedge_vco4x <= $time;
        if (last_posedge_vco4x !== 0)  period_vco4x <= $time - last_posedge_vco4x;
      end
  end

always@(negedge vco4x_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco2x_090_ck <= 1'b0;
        vco2x_270_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco2x_090_ck <= !vco2x_090_ck;
        vco2x_270_ck <= vco2x_090_ck;  //stale value of 090_ck, so will be 180-deg shifted
      end
  end

//
// Create the regular speed vco clocks, 0/45/90/135/180/225/270/315 phase shifts
//
always@(posedge vco2x_000_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco_000_ck <= 1'b0;
        vco_180_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco_000_ck <= !vco_000_ck;
        vco_180_ck <= vco_000_ck; //stale value of 000_ck, so will be 180-deg shifted
      end
  end
always@(posedge vco2x_090_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco_045_ck <= 1'b0;
        vco_225_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco_045_ck <= !vco_045_ck;
        vco_225_ck <= vco_045_ck; //stale value of 045_ck, so will be 180-deg shifted
      end
  end
always@(posedge vco2x_180_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco_090_ck <= 1'b0;
        vco_270_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco_090_ck <= !vco_090_ck;
        vco_270_ck <= vco_090_ck; //stale value of 090_ck, so will be 180-deg shifted
      end
  end
always@(posedge vco2x_270_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        vco_135_ck <= 1'b0;
        vco_315_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        vco_135_ck <= !vco_135_ck;
        vco_315_ck <= vco_135_ck; //stale value of 135_ck, so will be 180-deg shifted
      end
  end

/* SAVE FOR REFERENCE
//
// Drive vco_ck (NORMAL)
//
always
    begin
	if (on_vco)
	    begin
		vco_ck <= 1'b1;
		#low_time_vco;
		vco_ck <= 1'b0;
		if (high_time_vco > (low_time_vco*3/2)) #low_time_vco;
		else #high_time_vco;
		nb_vco_cycles <= nb_vco_cycles + 1;
		if (bypassi) last_posedge_vco <= 0;
	    end
	else
	    begin
		vco_ck <= 1'b0;
		wait (on_vco);
	    end
    end
 */

//
//  Check frequency of VCO and flag any errors
//  (warning message will display, but simulation will not stop)
//  NOTE - always checking frequency of normal VCO!
//

always @(posedge vco_000_ck)
    begin
	if (last_posedge_vco !== 0) 
	  begin
	    period_vco <= $time - last_posedge_vco;
	    nb_vco_cycles <= nb_vco_cycles + 1;

	    if ( (period_vco !== 0) && !MODE32K && delay_lock_reg )
	      begin
	        if ( !MODE_1V2 && !vco_low_flag && pll_lock_reg )
	          begin
	           if (period_vco > `MIN_VCO_1V0_FREQ) begin
	           //$display ("");
             if (fccc_divider_external !== 32'bx) begin
               $display ("************************Attention************************");
               $display ("           The frequency of the VCO is too slow!         ");
               $display ("   The output frequencies may appear to be within spec,  ");
               $display ("   but the VCO frequency is below 250MHz. The PLL is     ");
               $display ("   operating out of spec, therefore the current simula-  ");
               $display ("   tion results may not be accurate!                     ");
               //$display ("");
               $display ("   This is likely due to the setting of the dividers,    ");
               $display ("   or the frequency of REFCK. Please check these values    ");
               $display ("   and rerun the simulation.                             ");
               $display ("   period: %fps,   Max Period: %fps", period_vco, `MIN_VCO_1V0_FREQ);
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
             end
               vco_low_flag <= 1'b1;
	           end
	          end
	        if ( !MODE_1V2 && !vco_high_flag && pll_lock_reg )
	          begin
	           if (period_vco < `MAX_VCO_1V0_FREQ) begin
	           //$display ("");
             if (fccc_divider_external !== 32'bx) begin
               $display ("************************Attention************************");
               $display ("           The frequency of the VCO is too fast!         ");
               $display ("   The output frequencies may appear to be within spec,  ");
               $display ("   but the VCO frequency is above 500MHz. The PLL is     ");
               $display ("   operating out of spec, therefore the current simula-  ");
               $display ("   tion results may not be accurate!                     ");
               //$display ("");
               $display ("   This is likely due to the setting of the dividers,    ");
               $display ("   or the frequency of REFCK. Please check these values    ");
               $display ("   and rerun the simulation.                             ");
               //$display ("");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
             end
	           vco_high_flag <= 1'b1;
	           end
	          end
	        if ( MODE_1V2 && !vco_low_flag && pll_lock_reg )
	          begin
	           if (period_vco > `MIN_VCO_1V2_FREQ) begin
	           //$display ("");
             if (fccc_divider_external !== 32'bx) begin
               $display ("************************Attention************************");
               $display ("           The frequency of the VCO is too slow!         ");
               $display ("   The output frequencies may appear to be within spec,  ");
               $display ("   but the VCO frequency is below 500MHz. The PLL is     ");
               $display ("   operating out of spec, therefore the current simula-  ");
               $display ("   tion results may not be accurate!                     ");
               //$display ("");
               $display ("   This is likely due to the setting of the dividers,    ");
               $display ("   or the frequency of REFCK. Please check these values    ");
               $display ("   and rerun the simulation.                             ");
               $display ("   period: %fps,   Max Period: %fps", period_vco, `MIN_VCO_1V2_FREQ);
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
             end
	           vco_low_flag <= 1'b1;
	           end
	          end
	        if ( MODE_1V2 && !vco_high_flag && pll_lock_reg )
	          begin
	           if (period_vco < `MAX_VCO_1V2_FREQ) begin
	           //$display ("");
             if (fccc_divider_external !== 32'bx) begin
               $display ("************************Attention************************");
               $display ("           The frequency of the VCO is too fast!         ");
               $display ("   The output frequencies may appear to be within spec,  ");
               $display ("   but the VCO frequency is above 1GHz. The PLL is       ");
               $display ("   operating out of spec, therefore the current simula-  ");
               $display ("   tion results may not be accurate!                     ");
               //$display ("");
               $display ("   This is likely due to the setting of the dividers,    ");
               $display ("   or the frequency of REFCK. Please check these values    ");
               $display ("   and rerun the simulation.                             ");
               //$display ("");
               $display ("   Instance: %m. Simulation time is %t", $time);
               $display ("******************************************************** ");
               //$display ("");
             end
	           vco_high_flag <= 1'b1;
	           end
	          end
	      end

	  end
	last_posedge_vco <= $time;
    end

//
// Drive alt_vco4x_ck
//
always
  begin
    if(on_vco)
      begin

        if (down_flag_DS)
          begin
            alt_vco4x_ck <= 1'b1;
            #high_time_vco4x;
            alt_vco4x_ck <= 1'b0;
            if (no_MF) #low_time_vco4x;
            else #(low_time_vco4x + (change_per_cycle4x*ss_cycle_count));

            if (ss_cycle_count < ss_period_count4x)
              ss_cycle_count <= ss_cycle_count + 1;
            else //(ss_cycle_count = ss_period_count), time to switch direction
              begin
                ss_cycle_count <= ss_cycle_count - 1;
                down_flag_DS =1'b0;
                up_flag_DS = 1'b1;
              end
          end
        else if (up_flag_DS)
          begin
            alt_vco4x_ck <= 1'b1;
            #high_time_vco4x;
            alt_vco4x_ck <= 1'b0;
            if (no_MF) #low_time_vco4x;
            else #(low_time_vco4x + (change_per_cycle4x*ss_cycle_count));

            if (ss_cycle_count > 0)
              ss_cycle_count <= ss_cycle_count - 1;
            else //(ss_cycle_count = 0), time to switch direction
              begin
                ss_cycle_count <= ss_cycle_count + 1;
                down_flag_DS = 1'b1;
                up_flag_DS = 1'b0;
              end
          end

        nb_alt_vco4x_cycles <= nb_alt_vco4x_cycles + 1;
      end

    else // !enabled
      begin
        alt_vco4x_ck <= 1'b0;
        wait (on_vco);
      end
  end

//
// Create the alt_vco2x clocks, 0/90/180/270 phase shifts
//
always@(posedge alt_vco4x_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco2x_000_ck <= 1'b0;
        alt_vco2x_180_ck <= 1'b0;
      end
    else
      begin
        alt_vco2x_000_ck <= !alt_vco2x_000_ck;
        alt_vco2x_180_ck <= alt_vco2x_000_ck;
      end
  end
always@(negedge alt_vco4x_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco2x_090_ck <= 1'b0;
        alt_vco2x_270_ck <= 1'b0;
      end
    else
      begin
        alt_vco2x_090_ck <= !alt_vco2x_090_ck;
        alt_vco2x_270_ck <= alt_vco2x_090_ck;
      end
  end

//
// Create the regular speed vco clocks, 0/45/90/135/180/225/270/315 phase shifts
//
always@(posedge alt_vco2x_000_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco_000_ck <= 1'b0;
        alt_vco_180_ck <= 1'b0;
      end
    else
      begin
        alt_vco_000_ck <= !alt_vco_000_ck;
        alt_vco_180_ck <= alt_vco_000_ck;
      end
  end
always@(posedge alt_vco2x_090_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco_045_ck <= 1'b0;
        alt_vco_225_ck <= 1'b0;
      end
    else
      begin
        alt_vco_045_ck <= !alt_vco_045_ck;
        alt_vco_225_ck <= alt_vco_045_ck;
      end
  end
always@(posedge alt_vco2x_180_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco_090_ck <= 1'b0;
        alt_vco_270_ck <= 1'b0;
      end
    else
      begin
        alt_vco_090_ck <= !alt_vco_090_ck;
        alt_vco_270_ck <= alt_vco_090_ck;
      end
  end
always@(posedge alt_vco2x_270_ck  or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        alt_vco_135_ck <= 1'b0;
        alt_vco_315_ck <= 1'b0;
      end
    else
      begin
        alt_vco_135_ck <= !alt_vco_135_ck;
        alt_vco_315_ck <= alt_vco_135_ck;
      end
  end

/* SAVE FOR REFERENCE
//
// Drive alt_vco_ck
//
always
  begin
    if(on_vco)
      begin

        if (down_flag_DS)
          begin
            alt_vco_ck <= 1'b1;
            #high_time_vco;
            alt_vco_ck <= 1'b0;
            if (no_MF) #low_time_vco;
            else #(low_time_vco + (change_per_cycle*ss_cycle_count));

            if (ss_cycle_count < ss_period_count)
              ss_cycle_count <= ss_cycle_count + 1;
            else //(ss_cycle_count = ss_period_count), time to switch direction
              begin
                ss_cycle_count <= ss_cycle_count - 1;
                down_flag_DS =1'b0;
                up_flag_DS = 1'b1;
              end
          end
        else if (up_flag_DS)
          begin
            alt_vco_ck <= 1'b1;
            #high_time_vco;
            alt_vco_ck <= 1'b0;
            if (no_MF) #low_time_vco;
            else #(low_time_vco + (change_per_cycle*ss_cycle_count));

            if (ss_cycle_count > 0)
              ss_cycle_count <= ss_cycle_count - 1;
            else //(ss_cycle_count = 0), time to switch direction
              begin
                ss_cycle_count <= ss_cycle_count + 1;
                down_flag_DS = 1'b1;
                up_flag_DS = 1'b0;
              end
          end

        nb_alt_vco_cycles <= nb_alt_vco_cycles + 1;
      end

    else // !enabled
      begin
        alt_vco_ck <= 1'b0;
        wait (on_vco);
      end
  end
*/

//
// Check for inactive REFCK input clock
//
always @(posedge divided_ref)
  begin
    ref_time_passed <= $time - last_posedge_ref;
    // The next section checks if REFCK has stopped toggling for 400ns 
    // a warning message will appear, PLLOUT and LOCK will be pulled 
    // LOW 
    if ((ref_time_passed > 400_000) && !ref_warn_flag && on_wire && delay_lock_reg )
      begin
      //$display ("");
      $display ("**********************Attention**********************    ");
      $display ("There may be a problem with the selected reference clock ");
      $display ("                It may be stuck at %b!                   ", ref_ck);
      $display ("           Please check the reference clock.             ");
      $display ("        Current results may not be accurate!!            ");
      //$display ("");
      $display ("   Instance: %m. Simulation time is %t", $time);
      $display ("*****************************************************    ");
      //$display ("");
      ref_warn_flag <= 1'b1;
      end
  end

//
// Track minimum RESET pulse width
//
always @(posedge reseti)
  begin
    last_posedge_reset <= $time;
//    ref_div_count <= 0;
  end

/*always @(negedge reseti)
  begin
    if( last_posedge_reset !== 1'b1 )
      begin
        if( (($time - last_posedge_reset) < `RESET_PULSE_MIN ) && !reset_pulse_flag )
          begin
            //$display ("");
            $display ("************************Attention************************");
            $display ("   The pulse of the RESET signal is too small!           ");
            $display ("   The minimum acceptable pulse width is 1us. The PLL    ");
            $display ("   verilog model will continue to operate, but the cur-  ");
            $display ("   rent simulation results may not be accurate!          ");
            //$display ("");
            $display ("   Please check the REFCK input signal, and rerun the      ");
            $display ("   simulation.                                           ");
            //$display ("");
            $display ("   Simulation time is %t", $time);
            $display ("******************************************************** ");
            //$display ("");
            reset_pulse_flag <= 1'b1;
          end
      end
  end*/

//
// Track minimum PD pulse width
//
always @(posedge pdi)
  begin
    last_posedge_pd <= $time;
  end

always @(negedge pdi)
  begin
    if( last_posedge_pd !== 1'b1 )
      begin
        if( (($time - last_posedge_pd) < `RESET_PULSE_MIN ) && !pd_pulse_flag && delay_lock_reg )
          begin
            //$display ("");
            $display ("************************Attention************************");
            $display ("   The pulse of the PD signal is too small!           ");
            $display ("   The minimum acceptable pulse width is 1us. The PLL    ");
            $display ("   verilog model will continue to operate, but the cur-  ");
            $display ("   rent simulation results may not be accurate!          ");
            //$display ("");
            $display ("   Please check the REFCK input signal, and rerun the      ");
            $display ("   simulation.                                           ");
            //$display ("");
            $display ("   Instance: %m. Simulation time is %t", $time);
            $display ("******************************************************** ");
            //$display ("");
            pd_pulse_flag <= 1'b1;
          end
      end
  end


//
// Check for REFCK period consistency
//   Internal variables are reset when REFCK period changes
//
always@(vco_000_ck)
  begin
    if ( (period_ref1 !== 0) && (period_ref2 !== 0) && (period_ref !== 0) && 
        ((period_ref1 !== period_ref) || (period_ref !== period_ref2) || (period_ref1 !== period_ref2)) )
          ref_freq_chg <= 1'b1;
  end

//
// Reset warning flags if necessary
//
always @(negedge lock_enabled_flag)
  begin
    vco_low_flag <= 1'b0;
    vco_high_flag <= 1'b0;
    rFreq_low_flag <= 1'b0;
    rFreq_high_flag <= 1'b0;
    drFreq_low_flag <= 1'b0;
    drFreq_high_flag <= 1'b0;
    pos_pulse_flag <= 1'b0;
    neg_pulse_flag <= 1'b0;
    reset_pulse_flag <= 1'b0;
    pd_pulse_flag <= 1'b0;
  end

//
//Check for changing operating conditions
//	input REFCK frequency changes
//	any of the dividers change value
//
always@(ref_freq_chg or divider_divf or mult_divr)
  begin
    ref_freq_chg <= 1'b0;
    nb_ref_cycles <= 0;
    nb_divref_cycles <= 0;
    ff_lock <= 1'b0;
    fb_count <= 4'b0000;
    lock_count_reg <= 4'b0000;
    vco_low_flag <= 1'b0;
    vco_high_flag <= 1'b0;
    rFreq_low_flag <= 1'b0;
    rFreq_high_flag <= 1'b0;
    drFreq_low_flag <= 1'b0;
    drFreq_high_flag <= 1'b0;
    pos_pulse_flag <= 1'b0;
    neg_pulse_flag <= 1'b0;
    range_warn <= 1'b0;
    lock_enabled_flag <= 1'b0;
    last_posedge_divfb <= 0;
    period_divfb <= 0;
    last_posedge_divref <= 0;
    period_divref <= 0;
    divider_external <= (fccc_divider_external === 32'bx) ? 1 : fccc_divider_external;
    //divider_external <= 1;
    reset_pulse_flag <= 1'b0;
    pd_pulse_flag <= 1'b0;
  end
  
always@(posedge divq_reset)
  begin
    last_posedge_divfb <= 0;
    period_divfb <= 0;
    last_posedge_divref <= 0;
    period_divref <= 0;
  end

//
// Reset RANGE warning flags to run RANGE checks again
//
always @(range3i or range2i or range1i or range0i or posedge ref_freq_chg)
  begin
    range_warn <= 1'b0;
    if ({range3i,range2i,range1i,range0i} === 3'b000)
      range_byp <= 1'b1;
    else range_byp <= 1'b0;
  end

//
// VCO turns off with RESET, BYPASS, or change in fsei or ssei
//
//always@(posedge reseti or posedge bypassi or fsei or ssei or mode32ki)
always@(posedge reset_reg or fsei or ssei or mode32ki)
  begin
        ref_freq_chg <= 1'b0;
        on_vco <= 1'b0;
        on_flag <= 1'b0;
        ff_lock <= 1'b0;
        fb_count <= 4'b0000;
        vco_low_flag <= 1'b0;
        vco_high_flag <= 1'b0;
        rFreq_low_flag <= 1'b0;
        rFreq_high_flag <= 1'b0;
        drFreq_low_flag <= 1'b0;
        drFreq_high_flag <= 1'b0;
        pos_pulse_flag <= 1'b0;
        neg_pulse_flag <= 1'b0;
        range_warn <= 1'b0;
        lock_enabled_flag <= 1'b0;
        last_posedge_ref <= 0;
        last_negedge_ref <= 0;
        period_ref <= 0;
        period_ref1 <= 0;
        period_ref2 <= 0;
        last_posedge_fb <= 0;
        period_fb <= 0;
        period_fb1 <= 0;
        period_fb2 <= 0;
        period_fb3 <= 0;
        period_fb4 <= 0;
        last_posedge_divfb <= 0;
        period_divfb <= 0;
        last_posedge_divref <= 0;
        period_divref <= 0;
        last_posedge_vco <= 0;
        period_vco <= 0;
        low_time_vco <= 0;
        high_time_vco <= 0;
    last_posedge_vco4x <= 0;
    period_vco4x <= 0;
    low_time_vco4x <= 0;
    high_time_vco4x <= 0;
        period_ref_real <= 0;
        period_fb_real <= 0;
        period_divref_real <= 0;
        period_divfb_real <= 0;
        inner_freq_margin <=0;
        period_fb1_real <= 0;
        period_fb2_real <= 0;
        period_fb3_real <= 0;
        period_fb4_real <= 0;
        fb_comp_skip <= 0;
        divider_external <= (fccc_divider_external === 32'bx) ? 1 : fccc_divider_external;
        nb_ref_cycles <= 0;
        nb_divref_cycles <= 0;
        nb_fb_cycles <= 0;
        nb_divref_cycles <= 0;
        nb_divfb_cycles <= 0;
        nb_vco_cycles <= 0;
    nb_vco4x_cycles <= 0;
        last_posedge_reset <= 0;
        reset_pulse_flag <= 1'b0;
        last_posedge_pd <= 0;
        pd_pulse_flag <= 1'b0;
    change_per_cycle <= 0.0;
    ss_cycle_count <= 0;
    down_flag_DS <= 1'b1; //always start down from origin
    up_flag_DS <= 1'b0;
    nb_alt_vco_cycles <= 0;
    period_vco_max <= 0;
    change_per_cycle4x <= 0.0;
    nb_alt_vco4x_cycles <= 0;
    period_vco4x_max <= 0;
    input_missing <= 1'b0;
  end

//always @(posedge reseti or negedge bypassi)
always @(posedge reset_pd or negedge bypassi)
  begin
    ref_time_passed <= 0;
  end

//always @(negedge reseti or negedge bypassi)
always @(negedge reset_reg)
  begin
    nb_ref_cycles <= 0;
    nb_divref_cycles <= 0;
    ref_div_count <= 1'b0;
    //
    last_posedge_ref <= 0;
    last_negedge_ref <= 0;
    period_ref <= 0;
    period_ref1 <= 0;
    period_ref2 <= 0;
  end

//always @(posedge reseti or posedge bypassi)
always @(posedge reset_reg)
  begin
    fse_warn_flag <= 1'b0;
//
		divided_fb <= 1'b0;
		divf_count <= 0;
    ref_div_count <= 1'b0;
  end

function automatic integer GCD;
  input integer a, b;
  begin
    if(b == 0) 
      GCD = a;
    else
      GCD = GCD(b, (a%b));
  end 
endfunction

endmodule // ABI_PLL_FRONT


//
// DIVQ divider block
//
module  ABI_DIVQ (
		vco_in,

//		BYPASS,
//		RESET,
		reset_reg,

		DIVQ2,
		DIVQ1,
		DIVQ0,

		divq_out
);

//----------------------------------------------------------------------
// Port Declarations
//----------------------------------------------------------------------

// Input
  input		vco_in;	// input from VCO, 4x faster
  input		reset_reg;	// Bypass/Reset/Powerdown - Active HIGH
  input		DIVQ2;	// Divider Control
  input		DIVQ1;
  input		DIVQ0;

// Output
  output	divq_out;	// output of divider


//Internal signals

  //flags
  reg reset_init;

  //clocks
  reg divq_reg;

  time last_posedge_in, period_in;
  time last_posedge_out, period_out;

  integer mult_divq;

  integer nb_in_cycles, nb_out_cycles;


  integer divq_count;  //This counter tracks the toggles in the vco_in pin
  // and controls when the output signal will toggle in response
  //In this fashion, the phase of output responds and changes with
  //changed in the phase of the modulated vco

  wire vco_ck, reset_reg;
  wire divq2i, divq1i, divq0i;
  wire divq_out;

  buf u0   (vco_ck,vco_in);
//  buf u3   (bypassi,BYPASS);
//  buf u4   (reseti,RESET);

  buf u30  (divq0i,DIVQ0);
  buf u31  (divq1i,DIVQ1);
  buf u32  (divq2i,DIVQ2);

//  buf u90  (divq_out,divq_reg);


//
//  This mux is written to provide more testability in verilog.
//  If the user does not drive BYPASS or RESET, it will cause an unknown
//  on the output to direct the user's attention to the problem.
//
//  assign divided_ref = bypass ? 1'b0  :
//                    reset ? 1'b0  : 
//                reset_init ? divref_reg : 1'b0;  If reset_init has not gone high, output does not start toggling
//  reset_init is internal, initialized to zero, so can only be zero or one, never 'x'
//
  assign divq_out = (reset_reg === 1'b1) ? 1'b0  :
                    (reset_reg === 1'b0) ? ((reset_init == 1'b1) ? divq_reg : 1'b0 ) : 1'bx ;

  initial
     begin
	reset_init <= 1'b0;

	last_posedge_in <= 0;
	period_in <= 0;
	last_posedge_out <= 0;
	period_out <= 0;

	mult_divq <= 0;
	divq_count <= 1;
	nb_in_cycles <= 0;
	nb_out_cycles <= 0;

	divq_reg <= 1'b0;
     end

//
// Calculate counter value
// 
always @(divq2i or divq1i or divq0i or reset_reg)
   begin
	case ({divq2i,divq1i,divq0i})
	  3'b000: mult_divq <= 1;
	  3'b001: mult_divq <= 2;
	  3'b010: mult_divq <= 4;
	  3'b011: mult_divq <= 8;
	  3'b100: mult_divq <= 16;
	  3'b101: mult_divq <= 32;
	  3'b110: begin
			mult_divq <= 32;
			//$display ("");
			$display ("**********************Attention************************* ");
			$display ("The setting on DIVQ is not valid (cannot divide by 64)  ");
			$display ("DIVQ is being treated as 101 (divide by 32) for the rest ");
			$display ("of the simulation. ");
			//$display ("");
			$display ("   Instance: %m. Simulation time is %t", $time);
			$display ("***************************************************** ");
			//$display ("");
		  end
	  3'b111: begin
			mult_divq <= 32;
			//$display ("");
			$display ("**********************Attention************************* ");
			$display ("The setting on DIVQ is not valid (cannot divide by 128)  ");
			$display ("DIVQ is being treated as 101 (divide by 32) for the rest ");
			$display ("of the simulation. ");
			//$display ("");
			$display ("   Instance: %m. Simulation time is %t", $time);
			$display ("***************************************************** ");
			//$display ("");
		  end
	endcase
    end

//
// Check for RESET initialization
//  (If RESET does not go high, DIVQ output will not toggle
always @(posedge reset_reg)
    begin
	reset_init <= 1'b1;
    end


//
// Info for  possible error-checking
//
always @(posedge vco_ck)
    begin
	if ((last_posedge_in !== 0) && !reset_reg)
	   begin
		period_in <= $time - last_posedge_in;
//		low_time_out <= (period_in * mult_divq) / 2;
//		high_time_out <= (period_in * mult_divq) / 2;
	   end
	if (!reset_reg) last_posedge_in <= $time;
    end

//either edge of input
// this is where we do the dividing
always @(vco_ck)
    begin
	if ((last_posedge_in == 0)&&(period_in == 0)&&(vco_ck==1'b1) && !reset_reg) 
	//This is the first REFCK cycle - above condition is only true
	// if this is the first time we enter this procedural block
	  begin
	    //mult_divq cannot be 1, but we'll leave this in case that part of spec changes
	    if (mult_divq == 1) divq_reg <= vco_ck; //unique case
	    else divq_reg <= 1'b1; //start signal high
	    divq_count <= #1 divq_count + 1;
	  end
	else if ((divq_count < mult_divq) && (divq_count !== 0)&& !reset_reg)
	    divq_count <= #1 divq_count +1; //dont toggle, increase the count
	else if ((divq_count == mult_divq)&& !reset_reg)
	  begin
	    divq_reg <= !divq_reg; //toggle!
	    divq_count <= #1 1; //reset divider count, not to 0 or count is off
	  end
    end

always@(posedge divq_reg)
    begin
	if (last_posedge_out !== 0) 
		period_out <= $time - last_posedge_out;
	last_posedge_out <= $time;
    end

//
// Divider RESET
//
always@(posedge reset_reg)
    begin
	last_posedge_in <= 0;
	period_in <= 0;
	last_posedge_out <= 0;
	period_out <= 0;

	nb_in_cycles <= 0;
	nb_out_cycles <= 0;
	divq_count <= 1;
	divq_reg <= 1'b0;
    end

endmodule //ABI_DIVQ


//
// Phase-shifter block
//
module  ABI_PHASE (
		pllout4x_in,
//		out_000_new_in,

//		BYPASS,
//		RESET,
		reset_reg,

		out_000,
		out_045,
		out_090,
		out_135,
		out_180,
		out_225,
		out_270,
		out_315
);

//----------------------------------------------------------------------
// Port Declarations
//----------------------------------------------------------------------

// Input
  input		pllout4x_in;	// input from VCO, 4x faster
  input		reset_reg;	// Bypass/Reset/Powerdown - Active HIGH

// Output
  output	out_000;	// Normal output
  output	out_045;	// 45-degrees shifted
  output	out_090;	// 90-degrees shifted
  output	out_135;	// 135-degrees shifted
  output	out_180;	// 180-degrees shifted
  output	out_225;	// 225-degrees shifted
  output	out_270;	// 270-degrees shifted
  output	out_315;	// 315-degrees shifted



//Internal signals

  wire pllout4x_ck;

  reg pllout2x_000_ck, pllout2x_090_ck, pllout2x_180_ck, pllout2x_270_ck;
  reg pllout_000_ck, pllout_045_ck, pllout_090_ck, pllout_135_ck;
  reg pllout_180_ck, pllout_225_ck, pllout_270_ck, pllout_315_ck;

  wire out_000, out_045, out_090, out_135, out_180, out_225, out_270, out_315;

  time last_posedge_pllout4x, period_pllout4x;


  buf u0   (pllout4x_ck,pllout4x_in);


  assign out_000 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_000_ck : 1'bx );
  assign out_045 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_045_ck : 1'bx );
  assign out_090 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_090_ck : 1'bx );
  assign out_135 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_135_ck : 1'bx );
  assign out_180 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_180_ck : 1'bx );
  assign out_225 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_225_ck : 1'bx );
  assign out_270 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_270_ck : 1'bx );
  assign out_315 = (reset_reg === 1'b1) ? 1'b0 :
                  ((reset_reg === 1'b0) ? pllout_315_ck : 1'bx );



//
// Create the vco2x clocks, 0/90/180/270 phase shifts
//
always@(posedge pllout4x_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout2x_000_ck <= 1'b0;
        pllout2x_180_ck <= 1'b0;
        last_posedge_pllout4x <= 0;
        period_pllout4x <= 0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout2x_000_ck <= !pllout2x_000_ck;
        pllout2x_180_ck <= pllout2x_000_ck;  //stale value of 000_ck, so will be 180-deg shifted
        last_posedge_pllout4x <= $time;
        if (last_posedge_pllout4x !== 0)  period_pllout4x <= $time - last_posedge_pllout4x;
      end
  end


always@(negedge pllout4x_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout2x_090_ck <= 1'b0;
        pllout2x_270_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout2x_090_ck <= pllout2x_000_ck; //should always follow 2x_000
        pllout2x_270_ck <= pllout2x_180_ck;
      end
  end


//
// Create the regular speed vco clocks, 0/45/90/135/180/225/270/315 phase shifts
//
always@(posedge pllout2x_000_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout_000_ck <= 1'b0;
        pllout_180_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout_000_ck <= !pllout_000_ck;
        pllout_180_ck <= pllout_000_ck; //stale value of 000_ck, so will be 180-deg shifted
      end
  end
always@(posedge pllout2x_090_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout_045_ck <= 1'b0;
        pllout_225_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout_045_ck <= !pllout_045_ck;
        pllout_225_ck <= pllout_045_ck; //stale value of 045_ck, so will be 180-deg shifted
      end
  end
always@(negedge pllout2x_000_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout_090_ck <= 1'b0;
        pllout_270_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout_090_ck <= pllout_000_ck; //should always follow 000
        pllout_270_ck <= pllout_180_ck; 
      end
  end
always@(negedge pllout2x_090_ck or posedge reset_reg)
  begin
    if (reset_reg === 1'b1)
      begin
        pllout_135_ck <= 1'b0;
        pllout_315_ck <= 1'b0;
      end
    else //not in reset/bypass/powerdown
      begin
        pllout_135_ck <= pllout_045_ck;
        pllout_315_ck <= pllout_225_ck; //stale value of 135_ck, so will be 180-deg shifted
      end
  end

endmodule  //ABI_PHASE 


//
// Top level - stitch it all together!
//
module  ABISCB82 (
		REFCK,
		FB,
		BYPASS,
		RESET,
		PD,

		FSE,
		MODE32K,
		MODE_1V2,
		MODE_3V3,
		SSE,

		DIVR5,
		DIVR4,
		DIVR3,
		DIVR2,
		DIVR1,
		DIVR0,

		RANGE3,
		RANGE2,
		RANGE1,
		RANGE0,

		DIVF9,
		DIVF8,
		DIVF7,
		DIVF6,
		DIVF5,
		DIVF4,
		DIVF3,
		DIVF2,
		DIVF1,
		DIVF0,

		SSMD1,
		SSMD0,
		SSMF4,
		SSMF3,
		SSMF2,
		SSMF1,
		SSMF0,

		LOCKWIN2,
		LOCKWIN1,
		LOCKWIN0,
		LOCKCNT3,
		LOCKCNT2,
		LOCKCNT1,
		LOCKCNT0,

		DIVQ2,
		DIVQ1,
		DIVQ0,

		LOCK,
		PLLOUT_0,
		PLLOUT_45,
		PLLOUT_90,
		PLLOUT_135,
		PLLOUT_180,
		PLLOUT_225,
		PLLOUT_270,
		PLLOUT_315,
    
    divq_reset
);

//----------------------------------------------------------------------
// Port Declarations
//----------------------------------------------------------------------

// Input
  input     REFCK;    // Reference Clock
  input     FB;
  input     BYPASS; // Bypass - Active HIGH
  input     RESET;  // Reset  - Active HIGH
  input     PD;

  input     FSE;
  input     MODE32K;
  input     MODE_1V2;
  input     MODE_3V3;  // No function in verilog
  input     SSE;

  input     DIVR5;  // Reference Divider Control
  input     DIVR4;
  input     DIVR3;
  input     DIVR2;
  input     DIVR1;
  input     DIVR0;

  input     RANGE3;
  input     RANGE2;
  input     RANGE1;
  input     RANGE0;

  input     DIVF9;  // Feedback Divider Control
  input     DIVF8;
  input     DIVF7;
  input     DIVF6;
  input     DIVF5;
  input     DIVF4;
  input     DIVF3;
  input     DIVF2;
  input     DIVF1;
  input     DIVF0;

  input     SSMD1;
  input     SSMD0;
  input     SSMF4;
  input     SSMF3;
  input     SSMF2;
  input     SSMF1;
  input     SSMF0;

  input     LOCKWIN2;
  input     LOCKWIN1;
  input     LOCKWIN0;
  input     LOCKCNT3;
  input     LOCKCNT2;
  input     LOCKCNT1;
  input     LOCKCNT0;

  input     DIVQ2; // Output Divider Control for PLLOUT
  input     DIVQ1;
  input     DIVQ0;

// Output
  output    LOCK;   // PLL locked when HIGH
  output    PLLOUT_0;
  output    PLLOUT_45;
  output    PLLOUT_90;
  output    PLLOUT_135;
  output    PLLOUT_180;
  output    PLLOUT_225;
  output    PLLOUT_270;
  output    PLLOUT_315;
  
  output    divq_reset;
  
  parameter integer FB_MULTIPLIER = 1;
  parameter VCOFREQUENCY = 0.0;

// signals
  wire vco4x_wire, vco4x_normal, vco4x_alt;
// Useful for debugging, so keep?
  wire vco_000_wire, vco_000, vco_000_alt;
  wire vco_045_wire, vco_045, vco_045_alt;
  wire vco_090_wire, vco_090, vco_090_alt;
  wire vco_135_wire, vco_135, vco_135_alt;
  wire vco_180_wire, vco_180, vco_180_alt;
  wire vco_225_wire, vco_225, vco_225_alt;
  wire vco_270_wire, vco_270, vco_270_alt;
  wire vco_315_wire, vco_315, vco_315_alt;

  wire reset_all; //for RESET/PD/BYPASS/RANGE=0000

  wire pllout4x_wire;
  wire n_0, n_45, n_90, n_135, n_180, n_225, n_270, n_315;

// for frequency error checking
  reg oFreq_low_flag, oFreq_high_flag;
  time last_posedge_out, period_out;

// Instantiations

ABI_PLL_FRONT   #(.FB_MULTIPLIER(FB_MULTIPLIER), .VCOFREQUENCY(VCOFREQUENCY)) MAIN(
		.REFCK(REFCK),
		.FB(FB),
		.BYPASS(BYPASS),
		.RESET(RESET),
		.PD(PD),

		.FSE(FSE),
		.MODE32K(MODE32K),
		.MODE_1V2(MODE_1V2),
		.MODE_3V3(MODE_3V3),
		.SSE(SSE),

		.DIVR5(DIVR5),
		.DIVR4(DIVR4),
		.DIVR3(DIVR3),
		.DIVR2(DIVR2),
		.DIVR1(DIVR1),
		.DIVR0(DIVR0),

		.RANGE3(RANGE3),
		.RANGE2(RANGE2),
		.RANGE1(RANGE1),
		.RANGE0(RANGE0),

		.DIVF9(DIVF9),
		.DIVF8(DIVF8),
		.DIVF7(DIVF7),
		.DIVF6(DIVF6),
		.DIVF5(DIVF5),
		.DIVF4(DIVF4),
		.DIVF3(DIVF3),
		.DIVF2(DIVF2),
		.DIVF1(DIVF1),
		.DIVF0(DIVF0),
		
		.DIVQ2(DIVQ2),
		.DIVQ1(DIVQ1),
		.DIVQ0(DIVQ0),
		
		.SSMD1(SSMD1),
		.SSMD0(SSMD0),
		.SSMF4(SSMF4),
		.SSMF3(SSMF3),
		.SSMF2(SSMF2),
		.SSMF1(SSMF1),
		.SSMF0(SSMF0),

		.LOCKWIN2(LOCKWIN2),
		.LOCKWIN1(LOCKWIN1),
		.LOCKWIN0(LOCKWIN0),
		.LOCKCNT3(LOCKCNT3),
		.LOCKCNT2(LOCKCNT2),
		.LOCKCNT1(LOCKCNT1),
		.LOCKCNT0(LOCKCNT0),

		.LOCK(LOCK),
		.vco4x_normal(vco4x_normal),
		.vco4x_alt(vco4x_alt),
		.vco_000(vco_000),
		.vco_000_alt(vco_000_alt),
		.vco_045(vco_045),
		.vco_045_alt(vco_045_alt),
		.vco_090(vco_090),
		.vco_090_alt(vco_090_alt),
		.vco_135(vco_135),
		.vco_135_alt(vco_135_alt),
		.vco_180(vco_180),
		.vco_180_alt(vco_180_alt),
		.vco_225(vco_225),
		.vco_225_alt(vco_225_alt),
		.vco_270(vco_270),
		.vco_270_alt(vco_270_alt),
		.vco_315(vco_315),
		.vco_315_alt(vco_315_alt),
		.reset_reg(reset_all),
    .divq_reset(divq_reset)
);
wire [2:0] mult_divq;
assign mult_divq = {DIVQ2,DIVQ1,DIVQ0};

//
// Calculate counter value
// 
  always @(DIVQ2 or DIVQ1 or DIVQ0 or reset_all) begin
    case ({DIVQ2,DIVQ1,DIVQ0})
      3'b110: begin
                $display ("**********************Attention************************* ");
                $display ("The setting on DIVQ is not valid (cannot divide by 64)  ");
                $display ("DIVQ is being treated as 101 (divide by 32) for the rest ");
                $display ("of the simulation. ");
                $display ("   Instance: %m. Simulation time is %t", $time);
                $display ("***************************************************** ");
                end
      3'b111: begin
                $display ("**********************Attention************************* ");
                $display ("The setting on DIVQ is not valid (cannot divide by 128)  ");
                $display ("DIVQ is being treated as 101 (divide by 32) for the rest ");
                $display ("of the simulation. ");
                $display ("   Instance: %m. Simulation time is %t", $time);
                $display ("***************************************************** ");
              end
    endcase
  end
    
Divide_2 #(.DIV_LENGTH(1)) u_clk_a_div2(.CLKIN(vco4x_wire), .CLKOUT(clk_a_div2), .DIV(2'b10), .RESET(divq_reset | reset_all));
Divide_2 #(.DIV_LENGTH(1)) u_clk_a_div4(.CLKIN(clk_a_div2), .CLKOUT(clk_a_div4), .DIV(2'b10), .RESET(divq_reset | reset_all));
Divide_2 #(.DIV_LENGTH(1)) u_clk_a_div8(.CLKIN(clk_a_div4), .CLKOUT(clk_a_div8), .DIV(2'b10), .RESET(divq_reset | reset_all));
Divide_2 #(.DIV_LENGTH(1)) u_clk_a_div16(.CLKIN(clk_a_div8), .CLKOUT(clk_a_div16), .DIV(2'b10), .RESET(divq_reset | reset_all));
Divide_2 #(.DIV_LENGTH(1)) u_clk_a_div32(.CLKIN(clk_a_div16), .CLKOUT(clk_a_div32), .DIV(2'b10), .RESET(divq_reset | reset_all));


assign pllout4x_wire = (mult_divq === 3'b000) ? vco4x_wire : 
                      ((mult_divq === 3'b001) ? clk_a_div2 :
                      ((mult_divq === 3'b010) ? clk_a_div4 :
                      ((mult_divq === 3'b011) ? clk_a_div8 :
                      ((mult_divq === 3'b100) ? clk_a_div16 :
                      ((mult_divq === 3'b101) ? clk_a_div32 : 1'bx)))));


  reg vco4x_wire_div2, vco4x_wire_div4, vco4x_wire_div8, vco4x_wire_div16, vco4x_wire_div32;
  always@(posedge vco4x_wire or posedge reset_all) begin
    if (reset_all === 1'b1)
      vco4x_wire_div2 <= 1'b0;
    else
      vco4x_wire_div2 <= !vco4x_wire_div2;
  end
  always@(posedge vco4x_wire_div2 or posedge reset_all) begin
    if (reset_all === 1'b1)
      vco4x_wire_div4 <= 1'b0;
    else
      vco4x_wire_div4 <= !vco4x_wire_div4;
  end
  always@(posedge vco4x_wire_div4 or posedge reset_all) begin
    if (reset_all === 1'b1)
      vco4x_wire_div8 <= 1'b0;
    else
      vco4x_wire_div8 <= !vco4x_wire_div8;
  end
  always@(posedge vco4x_wire_div8 or posedge reset_all) begin
    if (reset_all === 1'b1)
      vco4x_wire_div16 <= 1'b0;
    else
      vco4x_wire_div16 <= !vco4x_wire_div16;
  end
  always@(posedge vco4x_wire_div16 or posedge reset_all) begin
    if (reset_all === 1'b1)
      vco4x_wire_div32 <= 1'b0;
    else
      vco4x_wire_div32 <= !vco4x_wire_div32;
  end
      
/*ABI_DIVQ        DIVQ_4x(
		.vco_in(vco4x_wire),
		.reset_reg(reset_all),
		.DIVQ2(DIVQ2),
		.DIVQ1(DIVQ1),
		.DIVQ0(DIVQ0),
		.divq_out(pllout4x_wire)
);*/

ABI_PHASE       PHASE(
		.pllout4x_in(pllout4x_wire),
		.reset_reg(reset_all | divq_reset),
		.out_000(pllout_000_wire),
		.out_045(pllout_045_wire),
		.out_090(pllout_090_wire),
		.out_135(pllout_135_wire),
		.out_180(pllout_180_wire),
		.out_225(pllout_225_wire),
		.out_270(pllout_270_wire),
		.out_315(pllout_315_wire)
);

//
// Specify block for Bypass path
//
  specify
     specparam t_rise = 0:0:0, t_fall = 0:0:0;  //fake numbers, to allow SDF annotation
     if (BYPASS) (REFCK => PLLOUT_0) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_45) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_90) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_135) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_180) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_225) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_270) = (t_rise, t_fall);
     if (BYPASS) (REFCK => PLLOUT_315) = (t_rise, t_fall);
  endspecify

//
// connections between instantiations
//
// mux between vco, alt_vco to go to dividers
  assign vco4x_wire = (SSE == 1'b0) ? vco4x_normal :
                     ((SSE == 1'b1) ? vco4x_alt : 1'bx ) ;

  assign vco_000_wire = (SSE == 1'b0) ? vco_000 :
                       ((SSE == 1'b1) ? vco_000_alt : 1'bx ) ;
  assign vco_045_wire = (SSE == 1'b0) ? vco_045 :
                       ((SSE == 1'b1) ? vco_045_alt : 1'bx ) ;
  assign vco_090_wire = (SSE == 1'b0) ? vco_090 :
                       ((SSE == 1'b1) ? vco_090_alt : 1'bx ) ;
  assign vco_135_wire = (SSE == 1'b0) ? vco_135 :
                       ((SSE == 1'b1) ? vco_135_alt : 1'bx ) ;
  assign vco_180_wire = (SSE == 1'b0) ? vco_180 :
                       ((SSE == 1'b1) ? vco_180_alt : 1'bx ) ;
  assign vco_225_wire = (SSE == 1'b0) ? vco_225 :
                       ((SSE == 1'b1) ? vco_225_alt : 1'bx ) ;
  assign vco_270_wire = (SSE == 1'b0) ? vco_270 :
                       ((SSE == 1'b1) ? vco_270_alt : 1'bx ) ;
  assign vco_315_wire = (SSE == 1'b0) ? vco_315 :
                       ((SSE == 1'b1) ? vco_315_alt : 1'bx ) ;

// Enable/Bypass gates

  wire bypassi, range_byp;

  assign range_byp = ( (RANGE3 == 1'b0) && (RANGE2 == 1'b0) && (RANGE1 == 1'b0) && (RANGE0 == 1'b0) ) ;
  assign bypassi = ( BYPASS | range_byp ) ;


  assign n_0 = !RESET && pllout_000_wire ;
  assign PLLOUT_0 = (PD == 1'b1) ? 1'b0 :
                   ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                    (bypassi == 1'b0) ?  u_pll.MAIN.vco1x_ck : 1'bx) : 1'bx) ;					


  assign n_45 = !RESET && pllout_045_wire ;
  assign PLLOUT_45 = (PD == 1'b1) ? 1'b0 :
                    ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                     (bypassi == 1'b0) ? u_pll.MAIN.vco_045_ck0 : 1'bx) : 1'bx) ;


  assign n_90 = !RESET && pllout_090_wire ;
  assign PLLOUT_90 = (PD == 1'b1) ? 1'b0 :
                    ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                     (bypassi == 1'b0) ? u_pll.MAIN.vco_090_ck0 : 1'bx) : 1'bx) ;


  assign n_135 = !RESET && pllout_135_wire ;
  assign PLLOUT_135 = (PD == 1'b1) ? 1'b0 :
                     ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                      (bypassi == 1'b0) ? u_pll.MAIN.vco_135_ck0 : 1'bx) : 1'bx) ;

  assign n_180 = !RESET && pllout_180_wire ;
  assign PLLOUT_180 = (PD == 1'b1) ? 1'b0 :
                     ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                      (bypassi == 1'b0) ? u_pll.MAIN.vco_180_ck0 : 1'bx) : 1'bx) ;

  assign n_225 = !RESET && pllout_225_wire ;
  assign PLLOUT_225 = (PD == 1'b1) ? 1'b0 :
                     ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                      (bypassi == 1'b0) ? u_pll.MAIN.vco_225_ck0 : 1'bx) : 1'bx) ;

  assign n_270 = !RESET && pllout_270_wire ;
  assign PLLOUT_270 = (PD == 1'b1) ? 1'b0 :
                     ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                      (bypassi == 1'b0) ? u_pll.MAIN.vco_270_ck0 : 1'bx) : 1'bx) ;

  assign n_315 = !RESET && pllout_315_wire ;
  assign PLLOUT_315 = (PD == 1'b1) ? 1'b0 :
                     ((PD == 1'b0) ? ((bypassi == 1'b1) ? REFCK : 
                                      (bypassi == 1'b0) ? u_pll.MAIN.vco_315_ck0 : 1'bx) : 1'bx) ;

//
// Frequency error checking for PLLOUT signals
//
  initial begin
    oFreq_low_flag <= 1'b0;
    oFreq_high_flag <= 1'b0;
    last_posedge_out <= 0;
    period_out <= 0;
  end

//
// Check frequency of PLL output and flag any errors
//  (warning message will display, but simulation will not stop)
  always@(posedge PLLOUT_0)
    begin
      if (last_posedge_out !== 0) 
        begin
          period_out <= $time - last_posedge_out;
          if ( (period_out !== 0) && !MODE32K )
            begin
              if ( (period_out > `MIN_OUT_FREQ) && !oFreq_low_flag && LOCK )
                begin
                 //$display ("");
                 $display ("************************Attention************************");
                 $display ("   The output frequency of PLLOUT_0 is too slow!           ");
                 $display ("   The frequency on the output is below 20MHz. The PLL   ");
                 $display ("   is operating out of spec, therefore the current sim-  ");
                 $display ("   ulation results may not be accurate!                  ");
                 //$display ("");
                 $display ("   This is likely due to the setting of the DIVR, DIVF,  ");
                 $display ("   DIVQ, or the frequency of REF. Please check these     ");
                 $display ("   values and rerun the simulation.                      ");
                 //$display ("");
                 $display ("   Instance: %m. Simulation time is %t", $time);
                 $display ("*********************************************************");
                 //$display ("");
                 oFreq_low_flag <= 1'b1;
                end  //if ( (period_out > `MIN_OUT_FREQ)
              if ( !MODE_1V2 && !oFreq_high_flag && LOCK )
                begin
                 if (period_out < `MAX_OUT_1V0_FREQ) begin
                  //$display ("");
                  $display ("************************Attention************************");
                  $display ("   The output frequency of PLLOUT_0 is too fast!         ");
                  $display ("   The frequency on the output is above 500MHz. The PLL  ");
                  $display ("   is operating out of spec, therefore the current sim-  ");
                  $display ("   ulation results may not be accurate!                  ");
                  //$display ("");
                  $display ("   This is likely due to the setting of the DIVR, DIVF,  ");
                  $display ("   DIVQ, or the frequency of REFCK. Please check these     ");
                  $display ("   values and rerun the simulation.                      ");
                  //$display ("");
                  $display ("   Instance: %m. Simulation time is %t", $time);
                  $display ("*********************************************************");
                  //$display ("");
                  oFreq_high_flag <= 1'b1;
                 end
                end  //if ( !MODE_1V2 && !oFreq_high_flag && LOCK )
              if ( MODE_1V2 && !oFreq_high_flag && LOCK )
                begin
                 if (period_out < `MAX_OUT_1V2_FREQ) begin
                  //$display ("");
                  $display ("************************Attention************************");
                  $display ("   The output frequency of PLLOUT_0 is too fast!         ");
                  $display ("   The frequency on the output is above 1GHz. The PLL  ");
                  $display ("   is operating out of spec, therefore the current sim-  ");
                  $display ("   ulation results may not be accurate!                  ");
                  //$display ("");
                  $display ("   This is likely due to the setting of the DIVR, DIVF,  ");
                  $display ("   DIVQ, or the frequency of REFCK. Please check these     ");
                  $display ("   values and rerun the simulation.                      ");
                  //$display ("");
                  $display ("   Instance: %m. Simulation time is %t", $time);
                  $display ("*********************************************************");
                  //$display ("");
                  oFreq_high_flag <= 1'b1;
                 end
                end  //if ( MODE_1V2 && !oFreq_high_flag && LOCK )
            end  //if ( (period_out !== 0) && !MODE32K )
        end  //if (last_posedge_out !== 0) 
      last_posedge_out <= $time;
    end  //  always@

  always@(posedge RESET or posedge BYPASS or posedge PD) //clear for frequency warning
    begin
      last_posedge_out <= 0;
      period_out <= 0;
    end

//
// For DIVF[9:7] when SSE=1
//
  always@(DIVF7 or DIVF8 or DIVF7)
   begin
    if (SSE === 1'b1) //we're in spread-spectrum mode
     begin
      if ( (RESET === 1'b0) && (PD === 1'b0) && (BYPASS === 1'b0) )
       begin //DIV[9:7] should be low when in this mode
        if ( DIVF7 === 1'b1 )
         begin
          //$display ("");
          $display ("************************Attention************************");
          $display ("   The DIVF7 input pin is high, but it should be low.    ");
          $display ("   When the PLL is in Spread-spectrum mode, the DIVF[9:7]");
          $display ("   input pins should be held low.                        ");
          //$display ("");
          $display ("   The PLL will continue to operate, but please re-check ");
          $display ("   the DIVF7 input pin and rerun the simulation.         ");
          //$display ("");
          $display ("   Instance: %m. Simulation time is %t", $time);
          $display ("*********************************************************");
          //$display ("");
         end //if ( DIVF7 === 1'b1 )
        if ( DIVF8 === 1'b1 )
         begin
          //$display ("");
          $display ("************************Attention************************");
          $display ("   The DIVF8 input pin is high, but it should be low.    ");
          $display ("   When the PLL is in Spread-spectrum mode, the DIVF[9:7]");
          $display ("   input pins should be held low.                        ");
          //$display ("");
          $display ("   The PLL will continue to operate, but please re-check ");
          $display ("   the DIVF8 input pin and rerun the simulation.         ");
          //$display ("");
          $display ("   Instance: %m. Simulation time is %t", $time);
          $display ("*********************************************************");
          //$display ("");
         end //if ( DIVF8 === 1'b1 )
        if ( DIVF9 === 1'b1 )
         begin
          //$display ("");
          $display ("************************Attention************************");
          $display ("   The DIVF9 input pin is high, but it should be low.    ");
          $display ("   When the PLL is in Spread-spectrum mode, the DIVF[9:7]");
          $display ("   input pins should be held low.                        ");
          //$display ("");
          $display ("   The PLL will continue to operate, but please re-check ");
          $display ("   the DIVF9 input pin and rerun the simulation.         ");
          //$display ("");
          $display ("   Instance: %m. Simulation time is %t", $time);
          $display ("*********************************************************");
          //$display ("");
         end //if ( DIVF9 === 1'b1 )
       end //if ( (RESET === 1'b0) && (PD === 1'b0) && (BYPASS === 1'b0) )
     end //if (SSE === 1'b1)
   end

//
// Error checking for control signals changing
// outside of RESET/PD or BYPASS assertion
//
  always@(MODE32K)
    begin
//      if ( (RESET == 1'b0) && (BYPASS == 1'b0) );
      if ( (RESET == 1'b0) && (BYPASS == 1'b0) && (PD == 1'b0) )
        begin
          if ($time > 0)
            begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The MODE32K control pin has changed in the middle of  ");
        $display ("   the simulation! This pin should NOT be changed except ");
        $display ("   when RESET or PD or BYPASS is asserted. The current   ");
        $display ("   simulation results may not be accurate!               ");
        //$display ("");
        $display ("   Please check the RESET, PD, BYPASS, and FSE control   ");
        $display ("   pins, and rerun the simulation.                       ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("*********************************************************");
        //$display ("");
            end
        end
    end

  always@(FSE)
    begin
//      if ( (RESET == 1'b0) && (BYPASS == 1'b0) );
      if ( (RESET == 1'b0) && (BYPASS == 1'b0) && (PD == 1'b0) )
        begin
          if ($time > 0)
            begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The FSE control pin has changed in the middle of the  ");
        $display ("   simulation! This pin should NOT be changed except when");
        $display ("   RESET or PD or BYPASS is asserted. The current simula-");
        $display ("   tion results may not be accurate!                     ");
        //$display ("");
        $display ("   Please check the RESET, PD, BYPASS, and FSE control   ");
        $display ("   pins, and rerun the simulation.                       ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("*********************************************************");
        //$display ("");
            end
        end
    end

  always@(SSE)
    begin
//      if ( (RESET == 1'b0) && (BYPASS == 1'b0) );
      if ( (RESET == 1'b0) && (BYPASS == 1'b0) && (PD == 1'b0) )
        begin
          if ($time > 0)
            begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The SSE control pin has changed in the middle of the  ");
        $display ("   simulation! This pin should NOT be changed except when ");
        $display ("   RESET or PD or BYPASS is asserted. The current simula-");
        $display ("   tion results may not be accurate!                     ");
        //$display ("");
        $display ("   Please check the RESET, PD, BYPASS, and SSE control   ");
        $display ("   pins, and rerun the simulation.                       ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("*********************************************************");
        //$display ("");
            end
        end
    end

  always@(SSMD1 or SSMD0)
    begin
//      if ( (RESET == 1'b0) && (BYPASS == 1'b0) );
      if ( (RESET == 1'b0) && (BYPASS == 1'b0) && (PD == 1'b0) )
        begin
          if ($time > 0)
            begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The SSMD[1:0] control bus has changed in the middle of ");
        $display ("   the simulation! These pins should NOT be changed except");
        $display ("   RESET or PD or BYPASS is asserted. The current simula-");
        $display ("   tion results may not be accurate!                     ");
        //$display ("");
        $display ("   Please check the RESET, PD, BYPASS, and SSMD[1:0]     ");
        $display ("   control bus, and rerun the simulation.                ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("*********************************************************");
        //$display ("");
            end
        end
    end

  always@(SSMF4 or SSMF3 or SSMF2 or SSMF1 or SSMF0)
    begin
//      if ( (RESET == 1'b0) && (BYPASS == 1'b0) );
      if ( (RESET == 1'b0) && (BYPASS == 1'b0) && (PD == 1'b0) )
        begin
          if ($time > 0)
            begin
        //$display ("");
        $display ("************************Attention************************");
        $display ("   The SSMF[4:0] control bus has changed in the middle of ");
        $display ("   the simulation! These pins should NOT be changed except");
        $display ("   RESET or PD or BYPASS is asserted. The current simula-");
        $display ("   tion results may not be accurate!                     ");
        //$display ("");
        $display ("   Please check the RESET, PD, BYPASS, and SSMF[4:0]     ");
        $display ("   control bus, and rerun the simulation.                ");
        //$display ("");
        $display ("   Instance: %m. Simulation time is %t", $time);
        $display ("*********************************************************");
        //$display ("");
            end
        end
    end

  always@(posedge RESET or PD or BYPASS or FSE or SSE)
    begin
	oFreq_low_flag <= 1'b0;
	oFreq_high_flag <= 1'b0;
	last_posedge_out <= 0;
	period_out <= 0;
    end

endmodule // ABISCB82


module CCC_PLL (input       CLKIN,   // Reference clock
                input       FBIN,    // Feedback clock
                input       BYPASS,   // Pll bypass - Active HIGH
                input       RESET,    // Pll reset  - Active HIGH
                input       POWERDOWN,       //
                input [1:0] SSMD,     // Spread-spectrum modulation depth
                input [4:0] SSMF,     // Spread-spectrum modulation frequency
                input       SSE,      // Spread-spectrum enable
                input [5:0] CLKDIV,     // Reference divider value
                input [9:0] FBDIV,     // Feedback divider value
                input [2:0] VCODIV,     // Output divider value
                input       FBSEL,    // Feedback select
                input       MODE_32K, // 32kHz select
                input [3:0] PLL_RANGE,    // PLL filter range
                input       MODE_1V2, // Core votage select
                input       MODE_3V3, // Analog votage select
                input [2:0] LOCKWIN,  // Lock window
                input [3:0] LOCKCNT,  // Lock count

                output      LOCK,     // PLL locked when HIGH
                output      VCO0,
                output      VCO45,
                output      VCO90,
                output      VCO135,
                output      VCO180,
                output      VCO225,
                output      VCO270,
                output      VCO315,
                
                output      divq_reset
               );
               
  parameter  real TPD  = 0;
  parameter integer FB_MULTIPLIER = 1;
  parameter VCOFREQUENCY = 0.0;
  
  wire #TPD VCO0_int;
  wire #TPD VCO45_int;
  wire #TPD VCO90_int;
  wire #TPD VCO135_int;
  wire #TPD VCO180_int;
  wire #TPD VCO225_int;
  wire #TPD VCO270_int;
  wire #TPD VCO315_int;
  


  





  assign VCO0 = VCO0_int;
  assign VCO45 = VCO45_int;
  assign VCO90 = VCO90_int;
  assign VCO135 = VCO135_int;
  assign VCO180 = VCO180_int;
  assign VCO225 = VCO225_int;
  assign VCO270 = VCO270_int;
  assign VCO315 = VCO315_int;

  
  

  ABISCB82 #(.VCOFREQUENCY(VCOFREQUENCY)) 
           u_pll (.REFCK(CLKIN), .FB(FBIN), .BYPASS(BYPASS), .RESET(RESET), .PD(POWERDOWN), .FSE(FBSEL), 
                  .MODE32K(MODE_32K), .MODE_1V2(MODE_1V2), .MODE_3V3(MODE_3V3), .SSE(SSE),
                  .DIVR5(CLKDIV[5]), .DIVR4(CLKDIV[4]), .DIVR3(CLKDIV[3]), .DIVR2(CLKDIV[2]), .DIVR1(CLKDIV[1]), .DIVR0(CLKDIV[0]),
                  .RANGE3(PLL_RANGE[3]), .RANGE2(PLL_RANGE[2]), .RANGE1(PLL_RANGE[1]), .RANGE0(PLL_RANGE[0]),
                  .DIVF9(FBDIV[9]), .DIVF8(FBDIV[8]), .DIVF7(FBDIV[7]), .DIVF6(FBDIV[6]), .DIVF5(FBDIV[5]),
                  .DIVF4(FBDIV[4]), .DIVF3(FBDIV[3]), .DIVF2(FBDIV[2]), .DIVF1(FBDIV[1]), .DIVF0(FBDIV[0]),
                  .SSMD1(SSMD[1]), .SSMD0(SSMD[0]),
                  .SSMF4(SSMF[4]), .SSMF3(SSMF[3]), .SSMF2(SSMF[2]), .SSMF1(SSMF[1]), .SSMF0(SSMF[0]),
                  .LOCKWIN2(LOCKWIN[2]), .LOCKWIN1(LOCKWIN[1]), .LOCKWIN0(LOCKWIN[0]),
                  .LOCKCNT3(LOCKCNT[3]), .LOCKCNT2(LOCKCNT[2]), .LOCKCNT1(LOCKCNT[1]), .LOCKCNT0(LOCKCNT[0]),
                  .DIVQ2(VCODIV[2]), .DIVQ1(VCODIV[1]), .DIVQ0(VCODIV[0]),
                  .LOCK(LOCK),
                  .PLLOUT_0(VCO0_int), .PLLOUT_45(VCO45_int), .PLLOUT_90(VCO90_int),
                  .PLLOUT_135(VCO135_int), .PLLOUT_180(VCO180_int), .PLLOUT_225(VCO225_int),
                  .PLLOUT_270(VCO270_int), .PLLOUT_315(VCO315_int), .divq_reset(divq_reset));
                  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    
    ( CLKIN        => VCO0    )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO45   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO90   )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO135  )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO180  )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO225  )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO270  )= (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLKIN        => VCO315  )= (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
endmodule

/*********************************/
/*         CCC_SYNCB_GEN           */
/*********************************/
`timescale 1 ps/1 ps
module CCC_SYNCB_GEN (VCO0,  FBIN, LOCK, RESET_N, SWRESYNC, FB_DIV,
                      CORE_LOCK, RSTSYNC_N,
                      GPD0_G3STYLE_N, GPD0_SRESETGENEN, GPD0_RESETGENEN,
                      GPD1_G3STYLE_N, GPD1_SRESETGENEN, GPD1_RESETGENEN,
                      GPD2_G3STYLE_N, GPD2_SRESETGENEN, GPD2_RESETGENEN,
                      GPD3_G3STYLE_N, GPD3_SRESETGENEN, GPD3_RESETGENEN);
  
  input         VCO0,  FBIN, LOCK, RESET_N, SWRESYNC;
  input  [13:0] FB_DIV;
  output        CORE_LOCK;
  output [3:0]  RSTSYNC_N;
  input         GPD0_G3STYLE_N, GPD0_SRESETGENEN, GPD0_RESETGENEN;
  input         GPD1_G3STYLE_N, GPD1_SRESETGENEN, GPD1_RESETGENEN;
  input         GPD2_G3STYLE_N, GPD2_SRESETGENEN, GPD2_RESETGENEN;
  input         GPD3_G3STYLE_N, GPD3_SRESETGENEN, GPD3_RESETGENEN;


  reg rstsync_b_g3, sw_rstsync_b_g3;
  wire [13:0] sync_count;
  reg start_sync_count;
  reg lock_pll_g3, sw_lock_pll_g3;
  reg sync_match;
  reg rstsync_b_nong3; 
  wire reset_int_b; 
  reg locked0, locked1;
  reg resync0, resync1, resync;
  wire reset_sync_int_b = ~SWRESYNC;
  reg rst_cnt, en_cnt;
  wire reset_int_cnt14_b = (~rst_cnt & reset_int_b);

  assign RSTSYNC_N[3] = (GPD3_G3STYLE_N == 1'b0 ) ? ((~GPD3_RESETGENEN | rstsync_b_g3) && (~GPD3_SRESETGENEN | sw_rstsync_b_g3)) : (~GPD3_RESETGENEN | rstsync_b_nong3);
  assign RSTSYNC_N[2] = (GPD2_G3STYLE_N == 1'b0 ) ? ((~GPD2_RESETGENEN | rstsync_b_g3) && (~GPD2_SRESETGENEN | sw_rstsync_b_g3)) : (~GPD2_RESETGENEN | rstsync_b_nong3);
  assign RSTSYNC_N[1] = (GPD1_G3STYLE_N == 1'b0 ) ? ((~GPD1_RESETGENEN | rstsync_b_g3) && (~GPD1_SRESETGENEN | sw_rstsync_b_g3)) : (~GPD1_RESETGENEN | rstsync_b_nong3);
  assign RSTSYNC_N[0] = (GPD0_G3STYLE_N == 1'b0 ) ? ((~GPD0_RESETGENEN | rstsync_b_g3) && (~GPD0_SRESETGENEN | sw_rstsync_b_g3)) : (~GPD0_RESETGENEN | rstsync_b_nong3);
  
  assign CORE_LOCK =  lock_pll_g3 & sw_lock_pll_g3;
  
  RSTN_SYNC u_rstn_sync(.rstn_out(reset_int_b), .rstn_in(RESET_N), .clk(VCO0));
  SYNCGEN_CNT14 u_syncgen_cnt14 (.clkin(VCO0), .arst_b(reset_int_cnt14_b), .en_cnt(en_cnt), .cnt(sync_count) );

  always @(*) begin
    if( (FB_DIV== 14'b0 || FB_DIV== 14'b1 ) ) 
      sync_match = start_sync_count;
    else 
      sync_match = (sync_count == (FB_DIV - 1));
  end

  always @(negedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b )
      locked0 <= 1'b0;
    else begin 
      if(!LOCK || resync)
        locked0 <= 1'b0;
      else begin
        if( lock_pll_g3 && sw_lock_pll_g3 ) 
          locked0 <= 1'b0;
        else 
          locked0 <= 1'b1;
      end
    end
  end

  always @(posedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b )
      rstsync_b_g3 <= 1'b1;
    else begin 
      if(!LOCK | lock_pll_g3 )
        rstsync_b_g3 <= 1'b1;
      else begin
        if( locked1 ) 
          rstsync_b_g3 <= sync_match;
      end
    end
  end

  always @(posedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b )
      sw_rstsync_b_g3 <= 1'b1;
    else begin 
      if( sw_lock_pll_g3 )
        sw_rstsync_b_g3 <= 1'b1;
      else begin
        if( locked1 ) 
          sw_rstsync_b_g3 <= sync_match;
      end
    end
  end

  always @(posedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b )
      locked1 <= 1'b0;
    else begin 
      if(!LOCK | ( lock_pll_g3 && sw_lock_pll_g3) )
        locked1 <= 1'b0;
      else
        locked1 <= locked0;
    end
  end

  always @(posedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b )
      lock_pll_g3 <= 1'b0;
    else begin 
      if(!LOCK) 
        lock_pll_g3 <= 1'b0;
      else begin
        if( lock_pll_g3 == 1'b0 ) 
          lock_pll_g3 <= sync_match & rstsync_b_g3;
      end
    end	
  end


  always @(*) begin   
    if(!LOCK || SWRESYNC ) begin 
      rst_cnt = 1'b1;
      en_cnt = 1'b0;
    end 
    else begin
      if( start_sync_count && !sync_match ) begin
        rst_cnt = 1'b0;	
        en_cnt = 1'b1;
      end 
      else begin
        rst_cnt = 1'b0;
        en_cnt = 1'b0;
      end	
    end
  end



  always @(posedge VCO0 or negedge reset_sync_int_b) begin
    if( !reset_sync_int_b ) begin 
      resync0 <= 1'b1;
      resync1 <= 1'b1;
      resync <= 1'b1;
    end 
    else begin
      resync0 <= 1'b0;
      resync1 <= resync0;
      resync <= resync1;
    end
  end

  always @(posedge VCO0 or negedge reset_int_b) begin
    if( !reset_int_b ) 
      sw_lock_pll_g3 <= 1'b1;
    else begin 
      if( resync )
        sw_lock_pll_g3 <= 1'b0;
      else begin
        if( sw_lock_pll_g3 == 1'b0 ) 
          sw_lock_pll_g3 <= sync_match & sw_rstsync_b_g3;
      end
    end	
  end

  always @(posedge FBIN or negedge reset_int_b) begin
    if( !reset_int_b ) 
      start_sync_count <= 1'b0;
    else begin
      if( LOCK == 1'b0 )
        start_sync_count <= 1'b0;
      else begin
        if( (rstsync_b_g3 == 1'b0) || (sw_rstsync_b_g3 == 1'b0) ) 
          start_sync_count <= 1'b1;
        else
          start_sync_count <= 1'b0;
      end
    end
  end

  always @(posedge FBIN or negedge reset_int_b) begin
    if( !reset_int_b )
      rstsync_b_nong3 = 1'b0;
    else begin
      if( LOCK == 1'b0 )
        rstsync_b_nong3 = 1'b0;
      else begin
        if( start_sync_count == 1'b1 ) 
          rstsync_b_nong3 = 1'b1;
      end
    end
  end
  
  specify
    specparam PATHPULSE$ = (1.0, 1.0);
    ( VCO0          => CORE_LOCK )    = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( VCO0          => RSTSYNC_N[0] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( VCO0          => RSTSYNC_N[1] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( VCO0          => RSTSYNC_N[2] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( VCO0          => RSTSYNC_N[3] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( FBIN          => RSTSYNC_N[0] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( FBIN          => RSTSYNC_N[1] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( FBIN          => RSTSYNC_N[2] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( FBIN          => RSTSYNC_N[3] ) = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify

endmodule


module SYNCGEN_CNT14 (clkin, arst_b, en_cnt, cnt);

  input clkin, arst_b, en_cnt;
  output [13:0] cnt;

  reg [13:0] cnt;
  wire carry0, carry1, carry2, carry3;

  assign carry0 = (cnt[3:0] == 4'hf);
  assign carry1 = carry0 && (cnt[7:4] == 4'hf);
  assign carry2 = carry1 && (cnt[11:8] == 4'hf);

  always @(posedge clkin or negedge arst_b) begin
    if( !arst_b )
      cnt[13:0] <= 14'b0;
    else 
      if( en_cnt )
        cnt[13:0] <= cnt[13:0] + 1'b1;
  end
endmodule


`timescale 1ns / 1ps
module RSTN_SYNC (output rstn_out,
                  input rstn_in,
                  input clk);

  reg ff2, ff1, ff0;
  assign rstn_out = ff2;

  always @(posedge clk or negedge rstn_in) begin	
    if( !rstn_in ) begin
      ff2 <= 1'b0;
      ff1 <= 1'b0;
      ff0 <= 1'b0;
    end 
    else begin
      ff2 <= ff1;
      ff1 <= ff0;
      ff0 <= 1'b1;
    end
  end

endmodule


`timescale 1 ps/1 ps
module Freq_Divider(CLKIN, CLKOUT, DIV, SYNC_RESET, ASYNC_RESET);
  
  parameter DIV_LENGTH      = 2;
  parameter DIV_FORMAT      = 0;        // 1--> Division factor = DIV+1
  parameter RESET_POLARITY  = 1;        // 0--> active low, 1--> active high
  
  input                   CLKIN;        // Input clock
  input                   SYNC_RESET;   // Synchronous Reset
  input                   ASYNC_RESET;  // Asynchronous Reset
  input [DIV_LENGTH-1:0]  DIV;          // Division Factor
  output                  CLKOUT;       // Divided output clock
  
  wire                    CLKOUT_odd, CLKOUT_even;
  wire  [DIV_LENGTH:0]    DIV_FACTOR;

  assign divider_ASYNC_RESET = RESET_POLARITY ^ ASYNC_RESET;
  assign CLKOUT         = ((CLKOUT_odd & DIV_FACTOR[0]) | (CLKOUT_even & !DIV_FACTOR[0])) && divider_ASYNC_RESET;
  assign divider_SYNC_RESET  = ~(RESET_POLARITY ^ SYNC_RESET);
  assign DIV_increment  = DIV_FORMAT | (~(|DIV));
  
  assign DIV_FACTOR = DIV + DIV_increment;
  
  
  
  // Even divider
  Even_Divider #(.DIV_LENGTH(DIV_LENGTH)) 
        u_even (.CLKIN(CLKIN), 
                .CLKOUT(CLKOUT_even), 
                .DIV(DIV_FACTOR), 
                .SYNC_RESET(divider_SYNC_RESET),
                .ASYNC_RESET(divider_ASYNC_RESET)
               );
  
  // Odd divider
  Odd_Divider #(.DIV_LENGTH(DIV_LENGTH)) 
        u_odd(.CLKIN(CLKIN), 
              .CLKOUT(CLKOUT_odd), 
              .DIV(DIV_FACTOR), 
              .SYNC_RESET(divider_SYNC_RESET),
              .ASYNC_RESET(divider_ASYNC_RESET)
              );
endmodule

`timescale 1 ps/1 ps
module Even_Divider(CLKIN, CLKOUT, DIV, SYNC_RESET, ASYNC_RESET);
  parameter       DIV_LENGTH = 2;
  input           CLKIN;
  input           SYNC_RESET;
  input           ASYNC_RESET;
  output reg      CLKOUT;
  input [DIV_LENGTH:0] DIV;

  reg   [DIV_LENGTH:0]  counter;
  wire  [DIV_LENGTH:0]  div_2;
  wire            EN;
  reg             rst_pulse;
  
  assign div_2 = {1'b0, DIV[DIV_LENGTH:1]};
  assign EN = ~DIV[0];

  initial begin
    rst_pulse   <= 1'b1;
    CLKOUT      <= 1'b0;
  end
  
  always @( posedge CLKIN or negedge ASYNC_RESET ) begin
    if ( !ASYNC_RESET | SYNC_RESET | rst_pulse ) begin
      counter     <= 1;
      CLKOUT      <= 1'b0;
      rst_pulse   <= 1'b0;
    end
    else begin
      if ( EN === 1'b1 ) begin
        if( counter == 1 ) begin
          counter <= div_2;
          CLKOUT <= ~CLKOUT;
        end
        else  begin
          counter <= counter-1;
        end
      end
    end
  end
  
  always @( posedge EN ) begin
    counter = div_2;
    CLKOUT = CLKIN;
  end
endmodule


`timescale 1 ps/1 ps
module Odd_Divider(CLKIN, CLKOUT, SYNC_RESET, ASYNC_RESET, DIV);
  parameter DIV_LENGTH = 2;
  input                 CLKIN;
  input                 SYNC_RESET;
  input                 ASYNC_RESET;
  output                CLKOUT;
  input [DIV_LENGTH:0]  DIV;

	wire EN = DIV[0];

	// These 2 counters are used for non-overlapping signals
  reg [DIV_LENGTH-1:0]  counter_pos;
	reg [DIV_LENGTH-1:0]  counter_neg;
	reg                   CLKOUT_pos;			  // positive edge triggered output
	reg                   CLKOUT_neg;			  // negative edge triggered output
	reg                   rst_pulse;				// pulse generated when DIV changes
	reg [DIV_LENGTH-1:0]  old_DIV;		      // gets set to old DIV when DIV changes
  
  reg [DIV_LENGTH-1:0]  delay_neg;		    // this is used to offset the negative edge counter
	wire [DIV_LENGTH:0]   offset_neg;			  // from the positive edge counter in order to
	assign offset_neg = {1'b0,DIV} + 2'b11;		// guarante 50% duty cycle.
  
  reg                   first_cycle_pos, first_cycle_neg;


	assign CLKOUT = CLKOUT_neg ^ CLKOUT_pos;	// xor to generate 50% duty, half-period
                                            // waves of final output

	initial begin
    first_cycle_pos   <= 1'b1;
    first_cycle_neg   <= 1'b1;
    CLKOUT_neg        <= 1'b1;
    CLKOUT_pos        <= 1'b1;
  end
  
  // positive edge counter/divider
	always @( posedge CLKIN or negedge ASYNC_RESET )	begin
		if( SYNC_RESET | rst_pulse ) begin
			counter_pos     <= 1;
      CLKOUT_pos  <= 1'b1;
      CLKOUT_neg  <= 1'b1;
      first_cycle_pos <= 1'b0;
		end
    else if( !ASYNC_RESET ) begin
      first_cycle_pos <= 1'b1;
		end
		else if ( EN ) begin
			if( counter_pos == 1 ) begin
				counter_pos <= DIV;
				CLKOUT_pos  <= ~CLKOUT_pos;
			end
			else begin
				counter_pos <= counter_pos - 1'b1;
			end
		end
	end
  
  always @( negedge SYNC_RESET ) begin
    if ( CLKIN === 1'b0 )
      delay_neg <= delay_neg - 1;
  end
	// counter driven by negative edge of clock.
	always @( negedge CLKIN or negedge ASYNC_RESET ) begin
		if( SYNC_RESET | rst_pulse ) begin
			counter_neg <= 1;
			delay_neg   <= offset_neg[DIV_LENGTH:1];
      CLKOUT_neg  <= 1'b1;
      CLKOUT_pos  <= 1'b1;
			//CLKOUT_neg  <= CLKOUT_pos;
      first_cycle_neg <= 1'b0;
		end
    else if( !ASYNC_RESET ) begin
      first_cycle_neg <= 1'b1;
		end
		else begin
      if( delay_neg <= 1 && EN ) begin
        // Do normal logic after odd calibration
        if(counter_neg == 1) begin
          counter_neg <= DIV;
          CLKOUT_neg  <= ~CLKOUT_neg;
        end
        else begin
          counter_neg <= counter_neg - 1'b1;
        end
      end
      else 
        if( EN ) begin
          delay_neg <= delay_neg - 1'b1;
        end
    end
  end

	// This block generates an internal SYNC_RESET for the odd divider in the
	// form of a single pulse signal when the odd divider is enabled.
	always @( posedge CLKIN or posedge SYNC_RESET ) begin
		if( SYNC_RESET )
			rst_pulse <= 0;
		else begin
      if( EN ) begin
        if( DIV != old_DIV )
          rst_pulse <= 1;
        else begin
          if ( first_cycle_pos | first_cycle_neg )
            rst_pulse <= 1;
          else
            rst_pulse <= 0;
        end
      end
    end
	end
  
 
	always @( posedge CLKIN )	begin
		old_DIV <= DIV;	// always save the old DIV value to guarante SYNC_RESET from an even-to-odd transition.
	end

endmodule


`timescale 1 fs/1 fs
module Divide_2(CLKIN, CLKOUT, DIV, RESET);
  parameter DIV_LENGTH = 2;
  input           CLKIN;
  input           RESET;
  output          CLKOUT;
  input [DIV_LENGTH:0] DIV;

  reg   [DIV_LENGTH:0]  counter;
  wire  [DIV_LENGTH:0]  div_2;
  wire            EN;
  reg             rst_pulse;
  reg             CLKOUT_int;
  
  assign div_2 = {1'b0, DIV[DIV_LENGTH:1]};
  assign EN = !DIV[0] & !RESET;
  assign CLKOUT = CLKOUT_int & !RESET;

  initial begin
    rst_pulse   <= 1'b1;
  end
  
  always @( posedge RESET ) begin
    counter     <= 1;
    CLKOUT_int  <= 1'b0;
    rst_pulse   <= 1'b0;
  end
  
  always @( posedge CLKIN ) begin
    if ( rst_pulse ) begin
      counter     <= 1;
      CLKOUT_int  <= 1'b0;
      rst_pulse   <= 1'b0;
    end
    else begin
      if ( EN === 1'b1 ) begin
        if( counter == 1 ) begin
          counter <= div_2;
          CLKOUT_int <= ~CLKOUT_int;
        end
        else  begin
          counter <= counter-1;
        end
      end
    end
  end
  
  always @( posedge EN ) begin
    counter = div_2;
    CLKOUT_int = CLKIN;
  end
endmodule
`timescale 1 fs/1 fs
module CCC ( // Hardwired ports to IOs
             CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD,
             // Routed CLK Inputs
             CLK0, CLK1, CLK2, CLK3,
             // Hardwired Oscillators ports
             RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC,
             // NGMUXs Controls
             NGMUX0_SEL, NGMUX1_SEL, NGMUX2_SEL, NGMUX3_SEL,
             NGMUX0_HOLD_N, NGMUX1_HOLD_N, NGMUX2_HOLD_N, NGMUX3_HOLD_N,
             NGMUX0_ARST_N, NGMUX1_ARST_N, NGMUX2_ARST_N, NGMUX3_ARST_N,
             // PLL Controls
             PLL_BYPASS_N, PLL_ARST_N, PLL_POWERDOWN_N,
             // GPDs Controls
             GPD0_ARST_N, GPD1_ARST_N, GPD2_ARST_N, GPD3_ARST_N,
             // Outputs
             LOCK, BUSY, GL0, GL1, GL2, GL3, Y0, Y1, Y2, Y3,
             // APB Bus Interface
             PCLK, PRESET_N, PSEL, PWRITE, PENABLE, PWDATA, PADDR, PRDATA);

  input   CLK0_PAD, CLK1_PAD, CLK2_PAD, CLK3_PAD;
  input   CLK0, CLK1, CLK2, CLK3, RCOSC_25_50MHZ, RCOSC_1MHZ, XTLOSC;
  input   NGMUX0_SEL, NGMUX1_SEL, NGMUX2_SEL, NGMUX3_SEL;
  input   NGMUX0_HOLD_N, NGMUX1_HOLD_N, NGMUX2_HOLD_N, NGMUX3_HOLD_N;
  input   NGMUX0_ARST_N, NGMUX1_ARST_N, NGMUX2_ARST_N, NGMUX3_ARST_N;
  input   PLL_BYPASS_N, PLL_ARST_N, PLL_POWERDOWN_N;
  input   GPD0_ARST_N, GPD1_ARST_N, GPD2_ARST_N, GPD3_ARST_N;
  output  LOCK, BUSY, GL0, GL1, GL2, GL3, Y0, Y1, Y2, Y3;
  input   PCLK, PRESET_N, PSEL, PWRITE, PENABLE;
  input   [7:0] PWDATA;
  input   [7:2] PADDR;
  output  [7:0] PRDATA;

  // Static CPC Bits
  parameter [209:0] INIT          = 210'h0;
  parameter         VCOFREQUENCY  = 0.0;

  wire        ccc_pll_fbclk, ccc_pll_rfclk;
  wire        fbclk_in, rfclk_in;
  wire [5:0]  sel_pll_dline;
  wire        rf_dline, _rf_dline;
  wire [13:0] fbdiv;
  wire [7:0]  rfdiv;
  wire        fbclk, rfclk;
  wire        gbclk_0, gbclk_1, gbclk_2, gbclk_3;

  wire [3:0]  selfb;
  wire [3:0]  selrf;
  wire        invfb, invrf;
  wire [3:0]  gpd_out_clk;
  wire        glmux_out;
  wire        selout_0, selout_1, selout_2, selout_3;
  wire [7:0]  gbdiv_0;
  wire [7:0]  gbdiv_1;
  wire [7:0]  gbdiv_2;
  wire [7:0]  gbdiv_3;
  wire        nopipe_rstsync_0, nopipe_rstsync_1, nopipe_rstsync_2, nopipe_rstsync_3;
  wire        rstsync_b_0, rstsync_b_1, rstsync_b_2, rstsync_b_3;
  wire        ccc_pll_lock, sw_resync_gpd, ccc_core_lock;
  wire [3:0]  g3_style_b;
  wire [3:0]  sreset_genen;
  wire [3:0]  reset_genen;
  wire [4:0]  sel_gpd_0;
  wire [4:0]  sel_gpd_1;
  wire [4:0]  sel_gpd_2;
  wire [4:0]  sel_gpd_3;
  wire        invgpd_0, invgpd_1, invgpd_2, invgpd_3;
  
  wire [9:0]  selglmux0;
  wire [9:0]  selglmux1;
  wire [9:0]  selglmux2;
  wire [9:0]  selglmux3;
  wire        invgl0, invgl1, invgl2, invgl3;
  wire        glmux0_busy, glmux1_busy, glmux2_busy, glmux3_busy;
  wire        selout0, selout1, selout2, selout3;
  
  wire [2:0]  ccc_pll_lockwin;                                    // source: CCC_CONFIG.lockwin
  wire [3:0]  ccc_pll_lockcnt;                                    // source: CCC_CONFIG.lockcnt
  wire        ccc_pll_reset, ccc_pll_powerdown, ccc_pll_bypass;   // Inverted input signals
  wire [5:0]  ccc_pll_clkdiv;                                     // source: CCC_CONFIG.divr
  wire [7:0]  ccc_pll_fbdiv;                                      // source: CCC_CONFIG.divf
  wire [2:0]  ccc_pll_vcodiv;                                     // source: CCC_CONFIG.divq
  wire [3:0]  ccc_pll_range;                                      // source: CCC_CONFIG.range
  wire [1:0]  ccc_pll_ssmd;                                       // source: CCC_CONFIG.ssmd
  wire [4:0]  ccc_pll_ssmf;                                       // source: CCC_CONFIG.ssmf
  wire        ccc_pll_sse;                                        // source: CCC_CONFIG.sse
  wire        ccc_pll_fbsel;                                      // source: CCC_CONFIG.fse
  wire        ccc_pll_mode32k;                                    // source: CCC_CONFIG.mode32k
  wire        ccc_pll_mode1v2;                                    // source: CCC_CONFIG.mode_1v2
  wire        ccc_pll_mode3v3;                                    // source: CCC_CONFIG.mode_3v3
  wire [7:0]  ccc_pll_clk;                                        // outputs of the PLL

  reg         powerup_reset;
  integer     rfclk_count;
  reg[31:0]   pll_external_divider;
  
  always @(ccc_pll_vcodiv or fbdiv or selfb) begin
    pll_external_divider = (fbdiv+1) * 2**ccc_pll_vcodiv;
    // [HH] SAR61501 We should set the external divider only in internal feedback cases.
    u_pll.u_pll.MAIN.fccc_divider_external = (selfb == 4'h7) ? pll_external_divider : 1;    
    //u_pll.u_pll.MAIN.fccc_divider_external = 1;
  end
  
  initial begin
    rfclk_count = 0;
    powerup_reset = 1'b0;
    wait (rfclk_count > 10);
    powerup_reset = 1'b1;
  end
  
  always @(posedge rfclk) begin
    rfclk_count = rfclk_count + 1;
  end
  
  assign _rf_dline =~ rf_dline;
  assign LOCK = ccc_core_lock;
  assign ARST_N = PLL_ARST_N & PLL_POWERDOWN_N & powerup_reset;

  assign ccc_pll_powerdown = ~PLL_POWERDOWN_N;
  assign ccc_pll_reset     = !(PLL_ARST_N & powerup_reset);
  assign ccc_pll_bypass    = ~PLL_BYPASS_N;

  CCC_PLL #(.VCOFREQUENCY(VCOFREQUENCY))
          u_pll(.FBIN(ccc_pll_fbclk), .CLKIN(ccc_pll_rfclk),
                .RESET(ccc_pll_reset), .BYPASS(ccc_pll_bypass), .POWERDOWN(ccc_pll_powerdown),
                .SSMD(ccc_pll_ssmd), .SSMF(ccc_pll_ssmf), .SSE(ccc_pll_sse),
                .CLKDIV(ccc_pll_clkdiv), .FBDIV({2'b00,ccc_pll_fbdiv}), .VCODIV(ccc_pll_vcodiv),
                .FBSEL(ccc_pll_fbsel),  .PLL_RANGE(ccc_pll_range),
                .MODE_32K(ccc_pll_mode32k), .MODE_1V2(ccc_pll_mode1v2), .MODE_3V3(ccc_pll_mode3v3),
                .LOCKWIN(ccc_pll_lockwin), .LOCKCNT(ccc_pll_lockcnt),
                .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                .LOCK(ccc_pll_lock), .divq_reset(divq_reset));

  CCC_FB_DELAY u_fb_delay (.CLKIN(fbclk_in), .SETPLLDLINE(sel_pll_dline), .ENABLE(_rf_dline),
                        .CLKOUT(ccc_pll_fbclk));

  CCC_RF_DELAY u_rf_delay (.CLKIN(rfclk_in), .SETPLLDLINE(sel_pll_dline), .ENABLE(rf_dline),
                        .CLKOUT(ccc_pll_rfclk));

  CCC_RF_DIV u_rf_div(.CLKIN(rfclk), .DIV(rfdiv), .ARST_N(ARST_N), .CLKOUT(rfclk_in));

  CCC_FB_DIV u_fb_div(.CLKIN(fbclk), .DIV(fbdiv), .ARST_N(ARST_N), .divq_reset(!divq_reset), .CLKOUT(fbclk_in));

  CCC_RF_MUX u_rf_mux(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                      .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                      .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                      .GPDCLK0(gpd_out_clk[0]), .GPDCLK1(gpd_out_clk[1]),
                      .GPDCLK2(gpd_out_clk[2]), .GPDCLK3(gpd_out_clk[3]),
                      .SEL(selrf), .INV(invrf),
                      .CLKOUT(rfclk));

  CCC_FB_MUX u_fb_mux(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                      .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                      .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                      .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                      .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                      .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                      .SEL(selfb), .INV(invfb),
                      .CLKOUT(fbclk));

  reg bypass_delayed;
  always @(posedge ccc_pll_rfclk)
    bypass_delayed <= ( ccc_pll_bypass | !(|ccc_pll_range) ) ;
  or u0 (divq_reset_gpd, bypass_delayed, !divq_reset);
  
  CCC_GPD0 u_gpd_0(.CLKIN(gbclk_0), .DIV(gbdiv_0),
                  .RESET(GPD0_ARST_N & divq_reset_gpd), .SYNC_RESET(rstsync_b_0), .NOPIPERSTSYNC(nopipe_rstsync_0),
                  .CLKOUT(gpd_out_clk[0]));

  CCC_GPD1 u_gpd_1(.CLKIN(gbclk_1), .DIV(gbdiv_1),
                  .RESET(GPD1_ARST_N & divq_reset_gpd), .SYNC_RESET(rstsync_b_1), .NOPIPERSTSYNC(nopipe_rstsync_1),
                  .CLKOUT(gpd_out_clk[1]));

  CCC_GPD2 u_gpd_2(.CLKIN(gbclk_2), .DIV(gbdiv_2),
                  .RESET(GPD2_ARST_N & divq_reset_gpd), .SYNC_RESET(rstsync_b_2), .NOPIPERSTSYNC(nopipe_rstsync_2),
                  .CLKOUT(gpd_out_clk[2]));

  CCC_GPD3 u_gpd_3(.CLKIN(gbclk_3), .DIV(gbdiv_3),
                  .RESET(GPD3_ARST_N & divq_reset_gpd), .SYNC_RESET(rstsync_b_3), .NOPIPERSTSYNC(nopipe_rstsync_3),
                  .CLKOUT(gpd_out_clk[3]));

  CCC_SYNCB_GEN u_syncb_gen(.VCO0(ccc_pll_clk[7]),  .FBIN(fbclk_in), .LOCK(ccc_pll_lock),
                            .RESET_N(ARST_N), .SWRESYNC(sw_resync_gpd), .FB_DIV(fbdiv),
                            .CORE_LOCK(ccc_core_lock),
                            .RSTSYNC_N({rstsync_b_3, rstsync_b_2, rstsync_b_1, rstsync_b_0}),
                            .GPD0_G3STYLE_N(g3_style_b[0]), .GPD0_SRESETGENEN(sreset_genen[0]), .GPD0_RESETGENEN(reset_genen[0]),
                            .GPD1_G3STYLE_N(g3_style_b[1]), .GPD1_SRESETGENEN(sreset_genen[1]), .GPD1_RESETGENEN(reset_genen[1]),
                            .GPD2_G3STYLE_N(g3_style_b[2]), .GPD2_SRESETGENEN(sreset_genen[2]), .GPD2_RESETGENEN(reset_genen[2]),
                            .GPD3_G3STYLE_N(g3_style_b[3]), .GPD3_SRESETGENEN(sreset_genen[3]), .GPD3_RESETGENEN(reset_genen[3]));

  CCC_GPD_MUX0 u_gp_mux_0(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                          .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                          .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                          .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                          .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                          .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                          //.GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                          .SEL(sel_gpd_0), .INV(invgpd_0),
                          .CLKOUT(gbclk_0));

  CCC_GPD_MUX1 u_gp_mux_1(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                          .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                          .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                          .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                          .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                          .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                          //.GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                          .SEL(sel_gpd_1), .INV(invgpd_1),
                          .CLKOUT(gbclk_1));

  CCC_GPD_MUX2 u_gp_mux_2(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                          .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                          .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                          .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                          .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                          .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                          //.GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                          .SEL(sel_gpd_2), .INV(invgpd_2),
                          .CLKOUT(gbclk_2));

  CCC_GPD_MUX3 u_gp_mux_3(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                          .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                          .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                          .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                          .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                          .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                          //.GPDCLK0(), .GPDCLK1(), .GPDCLK2(), .GPDCLK3(),
                          .SEL(sel_gpd_3), .INV(invgpd_3),
                          .CLKOUT(gbclk_3));

  CCC_NGMUX0 u_gl_mux_0(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                        .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                        .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                        .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                        .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                        .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                        .GPDCLK0(gpd_out_clk[0]), .GPDCLK1(gpd_out_clk[1]),
                        .GPDCLK2(gpd_out_clk[2]), .GPDCLK3(gpd_out_clk[3]),
                        .SEL(selglmux0), .NGMUX_SEL(NGMUX0_SEL), .NGMUX_HOLD_N(NGMUX0_HOLD_N), .OUT_SEL(selout0),
                        .INV(invgl0), .NGMUX_ARST_N(NGMUX0_ARST_N),
                        .GL(GL0), .Y(Y0), .BUSY(glmux_busy0));

  CCC_NGMUX1 u_gl_mux_1(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                        .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                        .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                        .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                        .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                        .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                        .GPDCLK0(gpd_out_clk[0]), .GPDCLK1(gpd_out_clk[1]),
                        .GPDCLK2(gpd_out_clk[2]), .GPDCLK3(gpd_out_clk[3]),
                        .SEL(selglmux1), .NGMUX_SEL(NGMUX1_SEL), .NGMUX_HOLD_N(NGMUX1_HOLD_N), .OUT_SEL(selout1), 
                        .INV(invgl1), .NGMUX_ARST_N(NGMUX1_ARST_N),
                        .GL(GL1), .Y(Y1), .BUSY(glmux_busy1));

  CCC_NGMUX2 u_gl_mux_2(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                        .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                        .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                        .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                        .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                        .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                        .GPDCLK0(gpd_out_clk[0]), .GPDCLK1(gpd_out_clk[1]),
                        .GPDCLK2(gpd_out_clk[2]), .GPDCLK3(gpd_out_clk[3]),
                        .SEL(selglmux2), .NGMUX_SEL(NGMUX2_SEL), .NGMUX_HOLD_N(NGMUX2_HOLD_N), .OUT_SEL(selout2), 
                        .INV(invgl2), .NGMUX_ARST_N(NGMUX2_ARST_N),
                        .GL(GL2), .Y(Y2), .BUSY(glmux_busy2));

  CCC_NGMUX3 u_gl_mux_3(.CLK0_PAD(CLK0_PAD), .CLK1_PAD(CLK1_PAD), .CLK2_PAD(CLK2_PAD), .CLK3_PAD(CLK3_PAD),
                        .CLK0(CLK0), .CLK1(CLK1), .CLK2(CLK2), .CLK3(CLK3),
                        .RCOSC_25_50MHZ(RCOSC_25_50MHZ), .RCOSC_1MHZ(RCOSC_1MHZ), .XTLOSC(XTLOSC),
                        .VCO0(ccc_pll_clk[7]), .VCO45(ccc_pll_clk[6]), .VCO90(ccc_pll_clk[5]),
                        .VCO135(ccc_pll_clk[4]), .VCO180(ccc_pll_clk[3]), .VCO225(ccc_pll_clk[2]),
                        .VCO270(ccc_pll_clk[1]), .VCO315(ccc_pll_clk[0]),
                        .GPDCLK0(gpd_out_clk[0]), .GPDCLK1(gpd_out_clk[1]),
                        .GPDCLK2(gpd_out_clk[2]), .GPDCLK3(gpd_out_clk[3]),
                        .SEL(selglmux3), .NGMUX_SEL(NGMUX3_SEL), .NGMUX_HOLD_N(NGMUX3_HOLD_N), .OUT_SEL(selout3), 
                        .INV(invgl3), .NGMUX_ARST_N(NGMUX3_ARST_N),
                        .GL(GL3), .Y(Y3), .BUSY(glmux_busy3));

  

  CCC_CONFIG #(.CONFIG(INIT))
        u_ccc_config (// Interface to the APB Bus
                      .PCLK(PCLK), .PRESET_N(PRESET_N), .PSEL(PSEL), .PWRITE(PWRITE),
                      .PENABLE(PENABLE), .PWDATA(PWDATA), .PADDR(PADDR), .PRDATA(PRDATA),
                      // Lock Signals
                      .CORE_LOCK(ccc_core_lock),
                      // Interface to the RFMUX and RFDIV
                      .RF_SEL(selrf), .RF_INV(invrf), .RF_DIV(rfdiv),
                      // Interface to the FBMUX and FBDIV
                      .FB_SEL(selfb), .FB_INV(invfb), .FB_DIV(fbdiv),
                      // Interface to the GLMUXs
                      .GLMUX0_SEL(selglmux0), .GLMUX0_SELOUT(selout0), .GLMUX0_INV(invgl0), .GLMUX0_BUSY(glmux0_busy),
                      .GLMUX1_SEL(selglmux1), .GLMUX1_SELOUT(selout1), .GLMUX1_INV(invgl1), .GLMUX1_BUSY(glmux1_busy),
                      .GLMUX2_SEL(selglmux2), .GLMUX2_SELOUT(selout2), .GLMUX2_INV(invgl2), .GLMUX2_BUSY(glmux2_busy),
                      .GLMUX3_SEL(selglmux3), .GLMUX3_SELOUT(selout3), .GLMUX3_INV(invgl3), .GLMUX3_BUSY(glmux3_busy),
                      // Interface for the GPDs
                      .GPD0_SEL(sel_gpd_0), .GPD0_INV(invgpd_0), .GPD0_DIV(gbdiv_0), .GPD0_NOPIPE_RSTSYNC(nopipe_rstsync_0),
                      .GPD1_SEL(sel_gpd_1), .GPD1_INV(invgpd_1), .GPD1_DIV(gbdiv_1), .GPD1_NOPIPE_RSTSYNC(nopipe_rstsync_1),
                      .GPD2_SEL(sel_gpd_2), .GPD2_INV(invgpd_2), .GPD2_DIV(gbdiv_2), .GPD2_NOPIPE_RSTSYNC(nopipe_rstsync_2),
                      .GPD3_SEL(sel_gpd_3), .GPD3_INV(invgpd_3), .GPD3_DIV(gbdiv_3), .GPD3_NOPIPE_RSTSYNC(nopipe_rstsync_3),
                      .GPD_SWRESYNC(sw_resync_gpd),
                      // Interface to the PLL
                      .PLL_LOCKWIN(ccc_pll_lockwin), .PLL_LOCKCNT(ccc_pll_lockcnt),
                      .PLL_FBSEL(ccc_pll_fbsel), .PLL_SSE(ccc_pll_sse), .PLL_SSMD(ccc_pll_ssmd), .PLL_SSMF(ccc_pll_ssmf),
                      .PLL_MODE_32K(ccc_pll_mode32k), .PLL_MODE_1V2(ccc_pll_mode1v2), .PLL_MODE_3V3(ccc_pll_mode3v3),
                      .PLL_RANGE(ccc_pll_range), .PLL_FBDIV(ccc_pll_fbdiv), .PLL_CLKDIV(ccc_pll_clkdiv), .PLL_VCODIV(ccc_pll_vcodiv),
                      // Interface to the SYNCB_GEN
                      .GPD0_G3STYLE_N(g3_style_b[0]), .GPD0_SRESETGENEN(sreset_genen[0]), .GPD0_RESETGENEN(reset_genen[0]),
                      .GPD1_G3STYLE_N(g3_style_b[1]), .GPD1_SRESETGENEN(sreset_genen[1]), .GPD1_RESETGENEN(reset_genen[1]),
                      .GPD2_G3STYLE_N(g3_style_b[2]), .GPD2_SRESETGENEN(sreset_genen[2]), .GPD2_RESETGENEN(reset_genen[2]),
                      .GPD3_G3STYLE_N(g3_style_b[3]), .GPD3_SRESETGENEN(sreset_genen[3]), .GPD3_RESETGENEN(reset_genen[3]),
                      // Interface to the Delay
                      .DELAY_LINE_SET(sel_pll_dline), .DELAY_LINE_RF(rf_dline),
                      
                      .OVWR_SEL_RESET(ovwr_sel_reset), .OVWR_VAL_RESET(ovwr_val_reset),
                      .OVWR_SEL_PD(ovwr_sel_pd), .OVWR_VAL_PD(ovwr_val_pd),
                      .OVWR_SEL_BYPASS(ovwr_sel_bypass), .OVWR_VAL_BYPASS(ovwr_val_bypass),
                      .OVWR_SEL_GL(ovwr_sel_gl), .OVWR_VAL_GL(ovwr_val_gl));
                      
  specify
    specparam PATHPULSE$                    = (1.0, 1.0);
    
    ( CLK0_PAD => GL0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => GL0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => GL0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => GL0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => GL0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => GL0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => GL0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => GL0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => GL0 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => GL0 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => GL0 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => GL1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => GL1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => GL1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => GL1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => GL1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => GL1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => GL1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => GL1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => GL1 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => GL1 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => GL1 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => GL2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => GL2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => GL2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => GL2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => GL2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => GL2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => GL2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => GL2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => GL2 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => GL2 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => GL2 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => GL3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => GL3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => GL3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => GL3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => GL3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => GL3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => GL3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => GL3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => GL3 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => GL3 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => GL3 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    
    ( CLK0_PAD => Y0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => Y0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => Y0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => Y0 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => Y0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => Y0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => Y0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => Y0 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => Y0 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => Y0 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => Y0 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => Y1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => Y1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => Y1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => Y1 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => Y1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => Y1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => Y1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => Y1 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => Y1 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => Y1 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => Y1 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => Y2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => Y2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => Y2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => Y2 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => Y2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => Y2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => Y2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => Y2 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => Y2 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => Y2 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => Y2 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( CLK0_PAD => Y3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1_PAD => Y3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2_PAD => Y3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3_PAD => Y3 )         = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK0 => Y3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK1 => Y3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK2 => Y3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( CLK3 => Y3 )             = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( XTLOSC => Y3 )           = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_1MHZ => Y3 )       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    ( RCOSC_25_50MHZ => Y3 )   = (0.00:0.00:0.00, 0.00:0.00:0.00);
  endspecify
  
endmodule

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps
module RAM1K18 (A_DOUT,B_DOUT,BUSY,
                A_CLK, A_ARST_N, A_BLK, A_DIN, A_ADDR, A_WEN,
                A_DOUT_CLK, A_DOUT_EN, A_DOUT_ARST_N, A_DOUT_SRST_N, A_DOUT_LAT,
                A_WIDTH, A_WMODE,A_EN,
                B_CLK, B_ARST_N, B_BLK, B_DIN, B_ADDR, B_WEN,
                B_DOUT_CLK, B_DOUT_EN, B_DOUT_ARST_N, B_DOUT_SRST_N, B_DOUT_LAT,
                B_WIDTH, B_WMODE,B_EN,
                SII_LOCK);
            
  parameter TC2CWWH = 0;
  parameter TC2CRWH = 0;
  parameter TC2CWRH = 0;

  output [17:0] A_DOUT;
  output [17:0] B_DOUT;
  output        BUSY;
  
  input         A_CLK;
  input         A_DOUT_CLK;
  input         A_ARST_N;
  input         A_DOUT_EN;
  input  [2:0]  A_BLK;
  input         A_DOUT_ARST_N;
  input         A_DOUT_SRST_N;
  input  [17:0] A_DIN;
  input  [13:0] A_ADDR;
  input  [1:0]  A_WEN;
  input         A_DOUT_LAT;
  input  [2:0]  A_WIDTH;
  input         A_WMODE;
  input         A_EN;
  
  input         B_CLK;
  input         B_DOUT_CLK;
  input         B_ARST_N;
  input         B_DOUT_EN;
  input  [2:0]  B_BLK;
  input         B_DOUT_ARST_N;
  input         B_DOUT_SRST_N;
  input  [17:0] B_DIN;
  input  [13:0] B_ADDR;
  input  [1:0]  B_WEN;
  input         B_DOUT_LAT;
  input  [2:0]  B_WIDTH;
  input         B_WMODE;
  input         B_EN;
  
  input         SII_LOCK;


  wire  [17:0] A_DOUTP;
  wire  [17:0] B_DOUTP;
  reg  [17:0]  A_DOUT_stg;
  reg  [17:0]  B_DOUT_stg;
  
  wire         A_CLK_int, A_ARST_N_int, A_BLK_int, A_WMODE_int, A_CLK_dly;
  wire         A_DOUT_SRST_N_int, A_DOUT_ARST_N_int, A_DOUT_CLK_int, A_DOUT_EN_int;
  wire  [17:0] A_DIN_int;
  wire  [13:0] A_ADDR_int;
  wire  [1:0]  A_WEN_int;
  wire  [2:0]  A_WIDTH_int;
  
  wire         B_CLK_int, B_ARST_N_int, B_BLK_int, B_WMODE_int, B_CLK_dly;
  wire         B_DOUT_CLK_int, B_DOUT_EN_int, B_DOUT_ARST_B_int, B_DOUT_SRST_B_int;
  wire  [17:0] B_DIN_int;
  wire  [13:0] B_ADDR_int;
  wire  [1:0]  B_WEN_int;
  wire  [2:0]  B_WIDTH_int;
  
  reg [13:0] A_ADDR_lat;
  reg [13:0] B_ADDR_lat;
  
  wire        A_TWOPORT, B_TWOPORT, TWOPORT;
  reg         A_BLK_lat, B_BLK_lat;
  wire [1:0]  A_WE_lat, B_WE_lat;
  reg         A_WE_dyn, B_WE_dyn;
  reg  [1:0]  A_WEN_prev, B_WEN_prev;
  reg [17:0]  A_DIN_lat, B_DIN_lat;
  
  wire A_RST, B_RST;
  
  time A_CLK_re_active, A_DOUT_CLK_re, B_CLK_re_active, B_DOUT_CLK_re;
  time A_CLK_re, B_CLK_re;
  time A_CLK_period, A_DOUT_CLK_period, B_CLK_period, B_DOUT_CLK_period;
  time A_CLK_Wre, B_CLK_Wre;
  
  real A_CLK_re_real, B_CLK_re_real; 
  
  integer A_Addr_Overlap_L, A_Addr_Overlap_H;
  integer B_Addr_Overlap_L, B_Addr_Overlap_H;
  integer j;
  reg Same_Addr;
  reg [17:0] collision_a, collision_b;

  reg [17:0] MEM_1024_18 [0:1023];
  
  reg       a_clk_flag, b_clk_flag, b_dout_clk_flag;
  
  parameter TPD = 0.001;
  parameter MEMORYFILE = "";
  parameter WARNING_MSGS_ON = 1;  // Used to turn off warnings about read &
                                  // write to same address at same time.
                                  // Default = on.  Set to 0 to turn them off.
  parameter NO_COLLISION = 0;     // Used to turn off collision detection.
                                  // Default = off.  Set to 1 to turn them on.
  reg WARNING_1_ON;                  
  reg NOTIFY_REG;

  pmos p0 (A_DOUT[0], A_DOUTP[0], 0);
  pmos p1 (A_DOUT[1], A_DOUTP[1], 0);
  pmos p2 (A_DOUT[2], A_DOUTP[2], 0);
  pmos p3 (A_DOUT[3], A_DOUTP[3], 0);
  pmos p4 (A_DOUT[4], A_DOUTP[4], 0);
  pmos p5 (A_DOUT[5], A_DOUTP[5], 0);
  pmos p6 (A_DOUT[6], A_DOUTP[6], 0);
  pmos p7 (A_DOUT[7], A_DOUTP[7], 0);
  pmos p8 (A_DOUT[8], A_DOUTP[8], 0);
  pmos p9 (A_DOUT[9], A_DOUTP[9], 0);
  pmos p10 (A_DOUT[10], A_DOUTP[10], 0);
  pmos p11 (A_DOUT[11], A_DOUTP[11], 0);
  pmos p12 (A_DOUT[12], A_DOUTP[12], 0);
  pmos p13 (A_DOUT[13], A_DOUTP[13], 0);
  pmos p14 (A_DOUT[14], A_DOUTP[14], 0);
  pmos p15 (A_DOUT[15], A_DOUTP[15], 0);
  pmos p16 (A_DOUT[16], A_DOUTP[16], 0);
  pmos p17 (A_DOUT[17], A_DOUTP[17], 0);
  
  pmos p18 (B_DOUT[0], B_DOUTP[0], 0);
  pmos p19 (B_DOUT[1], B_DOUTP[1], 0);
  pmos p20 (B_DOUT[2], B_DOUTP[2], 0);
  pmos p21 (B_DOUT[3], B_DOUTP[3], 0);
  pmos p22 (B_DOUT[4], B_DOUTP[4], 0);
  pmos p23 (B_DOUT[5], B_DOUTP[5], 0);
  pmos p24 (B_DOUT[6], B_DOUTP[6], 0);
  pmos p25 (B_DOUT[7], B_DOUTP[7], 0);
  pmos p26 (B_DOUT[8], B_DOUTP[8], 0);
  pmos p27 (B_DOUT[9], B_DOUTP[9], 0);
  pmos p28 (B_DOUT[10], B_DOUTP[10], 0);
  pmos p29 (B_DOUT[11], B_DOUTP[11], 0);
  pmos p30 (B_DOUT[12], B_DOUTP[12], 0);
  pmos p31 (B_DOUT[13], B_DOUTP[13], 0);
  pmos p32 (B_DOUT[14], B_DOUTP[14], 0);
  pmos p33 (B_DOUT[15], B_DOUTP[15], 0);
  pmos p34 (B_DOUT[16], B_DOUTP[16], 0);
  pmos p35 (B_DOUT[17], B_DOUTP[17], 0);
  
  and b0 (A_CLK_int, A_EN, A_CLK);
  and b1 (A_DOUT_CLK_int, A_EN, A_DOUT_CLK);
  buf b2 (A_ARST_N_int, A_ARST_N);
  buf b3 (A_DOUT_EN_int, A_DOUT_EN);
  //buf b4 (A_BLK_int, A_BLK);
  buf b5 (A_DOUT_ARST_N_int, A_DOUT_ARST_N);
  buf b6 (A_DOUT_SRST_N_int, A_DOUT_SRST_N);
  buf b7 (A_DIN_int[0], A_DIN[0]);
  buf b8 (A_DIN_int[1], A_DIN[1]);
  buf b9 (A_DIN_int[2], A_DIN[2]);
  buf b10 (A_DIN_int[3], A_DIN[3]);
  buf b11 (A_DIN_int[4], A_DIN[4]);
  buf b12 (A_DIN_int[5], A_DIN[5]);
  buf b13 (A_DIN_int[6], A_DIN[6]);
  buf b14 (A_DIN_int[7], A_DIN[7]);
  buf b15 (A_DIN_int[8], A_DIN[8]);
  buf b16 (A_DIN_int[9], A_DIN[9]);
  buf b17 (A_DIN_int[10], A_DIN[10]);
  buf b18 (A_DIN_int[11], A_DIN[11]);
  buf b19 (A_DIN_int[12], A_DIN[12]);
  buf b20 (A_DIN_int[13], A_DIN[13]);
  buf b21 (A_DIN_int[14], A_DIN[14]);
  buf b22 (A_DIN_int[15], A_DIN[15]);
  buf b23 (A_DIN_int[16], A_DIN[16]);
  buf b24 (A_DIN_int[17], A_DIN[17]);
  buf b25 (A_ADDR_int[0], A_ADDR[0]);
  buf b26 (A_ADDR_int[1], A_ADDR[1]);
  buf b27 (A_ADDR_int[2], A_ADDR[2]);
  buf b28 (A_ADDR_int[3], A_ADDR[3]);
  buf b29 (A_ADDR_int[4], A_ADDR[4]);
  buf b30 (A_ADDR_int[5], A_ADDR[5]);
  buf b31 (A_ADDR_int[6], A_ADDR[6]);
  buf b32 (A_ADDR_int[7], A_ADDR[7]);
  buf b33 (A_ADDR_int[8], A_ADDR[8]);
  buf b34 (A_ADDR_int[9], A_ADDR[9]);
  buf b35 (A_ADDR_int[10], A_ADDR[10]);
  buf b36 (A_ADDR_int[11], A_ADDR[11]);
  buf b37 (A_ADDR_int[12], A_ADDR[12]);
  buf b38 (A_ADDR_int[13], A_ADDR[13]);
  buf b39 (A_WEN_int[0], A_WEN[0]);
  buf b40 (A_WEN_int[1], A_WEN[1]);
  buf b45 (A_WMODE_int, A_WMODE);
  
  and b46 (B_CLK_int, B_EN, B_CLK);
  and b47 (B_DOUT_CLK_int, B_EN, B_DOUT_CLK);
  buf b48 (B_ARST_N_int, B_ARST_N);
  buf b49 (B_DOUT_EN_int, B_DOUT_EN);
  //buf b50 (B_BLK_int, B_BLK);
  buf b51 (B_DOUT_ARST_B_int, B_DOUT_ARST_N);
  buf b52 (B_DOUT_SRST_B_int, B_DOUT_SRST_N);
  buf b53 (B_DIN_int[0], B_DIN[0]);
  buf b54 (B_DIN_int[1], B_DIN[1]);
  buf b55 (B_DIN_int[2], B_DIN[2]);
  buf b56 (B_DIN_int[3], B_DIN[3]);
  buf b57 (B_DIN_int[4], B_DIN[4]);
  buf b58 (B_DIN_int[5], B_DIN[5]);
  buf b59 (B_DIN_int[6], B_DIN[6]);
  buf b60 (B_DIN_int[7], B_DIN[7]);
  buf b61 (B_DIN_int[8], B_DIN[8]);
  buf b62 (B_DIN_int[9], B_DIN[9]);
  buf b63 (B_DIN_int[10], B_DIN[10]);
  buf b64 (B_DIN_int[11], B_DIN[11]);
  buf b65 (B_DIN_int[12], B_DIN[12]);
  buf b66 (B_DIN_int[13], B_DIN[13]);
  buf b67 (B_DIN_int[14], B_DIN[14]);
  buf b68 (B_DIN_int[15], B_DIN[15]);
  buf b69 (B_DIN_int[16], B_DIN[16]);
  buf b70 (B_DIN_int[17], B_DIN[17]);
  buf b71 (B_ADDR_int[0], B_ADDR[0]);
  buf b72 (B_ADDR_int[1], B_ADDR[1]);
  buf b73 (B_ADDR_int[2], B_ADDR[2]);
  buf b74 (B_ADDR_int[3], B_ADDR[3]);
  buf b75 (B_ADDR_int[4], B_ADDR[4]);
  buf b76 (B_ADDR_int[5], B_ADDR[5]);
  buf b77 (B_ADDR_int[6], B_ADDR[6]);
  buf b78 (B_ADDR_int[7], B_ADDR[7]);
  buf b79 (B_ADDR_int[8], B_ADDR[8]);
  buf b80 (B_ADDR_int[9], B_ADDR[9]);
  buf b81 (B_ADDR_int[10], B_ADDR[10]);
  buf b82 (B_ADDR_int[11], B_ADDR[11]);
  buf b83 (B_ADDR_int[12], B_ADDR[12]);
  buf b84 (B_ADDR_int[13], B_ADDR[13]);
  buf b85 (B_WEN_int[0], B_WEN[0]);
  buf b86 (B_WEN_int[1], B_WEN[1]);
  buf b87 (DOUTLATB_int, B_DOUT_LAT);
  buf b91 (B_WMODE_int, B_WMODE);
  
  assign A_TWOPORT = (A_WIDTH[2] && A_WIDTH[1] && A_WIDTH[0]) || (A_WIDTH[2] && !A_WIDTH[1] && A_WIDTH[0]) || (A_WIDTH[2] && A_WIDTH[1] && !A_WIDTH[0]); //  101, 111, 110
  assign B_TWOPORT = (B_WIDTH[2] && B_WIDTH[1] && B_WIDTH[0]) || (B_WIDTH[2] && !B_WIDTH[1] && B_WIDTH[0]) || (B_WIDTH[2] && B_WIDTH[1] && !B_WIDTH[0]); //  101, 111, 110
  assign TWOPORT  = A_TWOPORT || B_TWOPORT;
  
  assign A_BLK_int = A_BLK[0] && A_BLK[1] && A_BLK[2];
  assign B_BLK_int = B_BLK[0] && B_BLK[1] && B_BLK[2];
  
  assign A_RST = A_ARST_N_int && A_BLK_lat;
  assign B_RST = B_ARST_N_int && ( (B_BLK_lat && !TWOPORT) || (A_BLK_lat && TWOPORT) );
  
  wire [17:0]   A_DOUT_stg_dly, A_DOUT_stg_1, nc;
  wire [17:0]   B_DOUT_stg_dly, B_DOUT_stg_1;
  RAM_DLY u_ADLY(.IN(A_DOUT_stg), .OUT(A_DOUT_stg_dly));
  RAM_DLY u_BDLY(.IN(B_DOUT_stg), .OUT(B_DOUT_stg_dly));
  RAM_DLY u_CLKDLY(.IN({16'b0,B_CLK_int,A_CLK_int}), .OUT({nc[17:2],B_CLK_dly,A_CLK_dly}));
  assign A_DOUT_stg_1[17:0] = (A_DOUT_LAT === 1'b1) ? A_DOUT_stg[17:0] : A_DOUT_stg_dly[17:0];
  assign B_DOUT_stg_1[17:0] = (B_DOUT_LAT === 1'b1) ? B_DOUT_stg[17:0] : B_DOUT_stg_dly[17:0];
  
  genvar i;
  generate
    for(i=0; i<18; i=i+1) begin : PIPEA
      SLE_Prim upipea (.Q(A_DOUTP[i]), .ADn(1'b1), .ALn(A_DOUT_ARST_N_int), .CLK(A_DOUT_CLK_int), .D(A_DOUT_stg_1[i]),
                  .LAT(A_DOUT_LAT), .SD(1'b0), .EN(A_DOUT_EN_int), .SLn(A_DOUT_SRST_N_int));
    end
    
    for(i=0; i<18; i=i+1) begin : PIPEB
      SLE_Prim upipeb (.Q(B_DOUTP[i]), .ADn(1'b1), .ALn(B_DOUT_ARST_B_int), .CLK(B_DOUT_CLK_int), .D(B_DOUT_stg_1[i]),
                  .LAT(B_DOUT_LAT), .SD(1'b0), .EN(B_DOUT_EN_int), .SLn(B_DOUT_SRST_B_int));
    end
  endgenerate
  
  initial begin
    WARNING_1_ON = 1;
    if ( WARNING_MSGS_ON == 0 )
      $display("Note: SRAM warnings are disabled. Set WARNING_MSGS_ON = 1 to enable warnings.");
    
    if ( MEMORYFILE != "")
      $readmemb ( MEMORYFILE, MEM_1024_18 );
      
    a_clk_flag = 1'b0;
    b_clk_flag = 1'b0;
    b_dout_clk_flag = 1'b0;
    
    if (TWOPORT && A_WMODE)
      $display("Error : A_WMODE can not be set to 1 in 2-port mode. Instance: %m",$realtime);
    if (TWOPORT && B_WMODE)
      $display("Error : B_WMODE can not be set to 1 in 2-port mode. Instance: %m",$realtime);
  end
  
  // Issue warnings if any of the clocks goes unknown
  always @(A_CLK_int === 1'bx ) begin
    if ( ($time > 0) && (A_RST === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : A_CLK input went unknown at time %0.1fps. Instance: %m",$realtime);
    end
  end
  always @(B_CLK_int === 1'bx ) begin
    if ( ($time > 0) && (B_RST === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : B_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
    end
  end
  
  // Warnings for the DOUTCLKs
  always @( A_DOUT_CLK_int ) begin
    if ( A_DOUT_CLK_int === 1'bx ) begin
      if (($time > 0) && (A_DOUT_ARST_N_int === 1'b1) && (A_DOUT_EN_int === 1'b1) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning : A_DOUT_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
      end
    end
    else if( (A_DOUT_CLK_int !== 1'b1) && (A_DOUT_LAT === 1'b1) ) begin
      // DOUTCLK should always be high in feedthrough mode
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: A_DOUT_CLK is not high in feedthrough mode at time %0.1fps! Instance: %m", $realtime);
    end
  end
  always @(B_DOUT_CLK_int) begin
    if ( B_DOUT_CLK_int === 1'bx ) begin
      if ( ($time > 0) && (B_DOUT_ARST_B_int === 1'b1) && (B_DOUT_EN_int === 1'b1) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning : B_DOUT_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
      end
    end
    else if( (B_DOUT_CLK_int !== 1'b1) && (B_DOUT_LAT === 1'b1) ) begin
      // DOUTCLK should always be high in feedthrough mode
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: B_DOUT_CLK is not high in feedthrough mode (when B_DOUT_LAT = 1'b1) at time %0.1fps! Instance: %m", $realtime);
    end    
  end
    
  //Block selects operation : clear the outputs of the RAM block
  always @( A_BLK_lat ) begin
    case ( A_BLK_lat )
      1'b0 : begin
          A_DOUT_stg = 18'b0;
          // In 2-port mode, blka clears B_DOUT
          if( TWOPORT === 1'b1 )
            B_DOUT_stg = 18'b0;
        end
      1'b1 : ;
      default : begin
          if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
            $display("Warning : A_BLK went unknown at time %0.1fps. Instance: %m", $realtime);
        end
    endcase
  end
  always @( B_BLK_lat ) begin
    case ( B_BLK_lat )
      1'b0 : begin
          // B_BLK is only allowed to clear B_DOUT in dual-port mode
          if( TWOPORT === 1'b0 )
            B_DOUT_stg = 18'b0;
        end
      1'b1 : ;
      default : begin
          if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
            $display("Warning : B_BLK went unknown at time %0.1fps. Instance: %m", $realtime);
        end
    endcase
  end
  
  // Asynchronous clear signal for the input ports
  always @( A_ARST_N_int ) begin
    case ( A_ARST_N_int )
      1'b0 : begin
          A_DOUT_stg = 18'b0;
          if( (TWOPORT === 1'b1) && (A_ARST_N_int !== B_ARST_N_int) ) begin
            // both A_ARST_N and B_ARST_N should be tied together
            if ( WARNING_MSGS_ON == 1 )
              $display(" Warning: A_ARST_N and B_ARST_N are not tied together in two-port mode at time %0.1fps! Instance: %m", $realtime);
          end
          
          if( ($time - A_CLK_Wre) < A_CLK_period ) begin
            if ( WARNING_MSGS_ON == 1 ) begin
              $display(" Warning: A_ARST_N was asserted during a write cycle. Updating memory contents at the write address with X!");
              $display (" Time: %0.1fps Instance: %m ", $realtime );
            end
          end
        end
      1'b1 : ;
      default : begin
          if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
            $display(" Warning: A_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
        end
    endcase
  end
  always @( B_ARST_N_int ) begin
    case ( B_ARST_N_int )
      1'b0 : begin
          B_DOUT_stg = 18'b0;
          if( (TWOPORT === 1'b1) && (A_ARST_N_int !== B_ARST_N_int) ) begin
            // both A_ARST_N and B_ARST_N should be tied together
            if ( WARNING_MSGS_ON == 1 )
              $display(" Warning: A_ARST_N and B_ARST_N are not tied together in two-port mode at time %0.1fps! Instance: %m", $realtime);
          end
          
          if( ($time - B_CLK_Wre) < B_CLK_period ) begin
            if ( WARNING_MSGS_ON == 1 ) begin
              $display(" Warning: B_ARST_N was asserted during a write cycle. Updating memory contents at the write address with X");
              $display (" Time: %0.1fps Instance: %m ", $realtime );
            end
          end
        end
      1'b1 : ;
      default : begin
          if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
            $display(" Warning: B_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
        end
    endcase
  end
  
  // Asynchronous reset for the output pipeline registers
  always @( A_DOUT_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_DOUT_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_DOUT_ARST_B_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_DOUT_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
  // Pipeline warnings at port A
  always @(posedge A_DOUT_CLK_int) begin
    A_DOUT_CLK_period = $time - A_DOUT_CLK_re;
    A_DOUT_CLK_re = $time;
    
    if ( A_DOUT_LAT === 1'b0 ) begin
      if ( (A_DOUT_CLK_period != A_CLK_period) && (TWOPORT != 1'b1) ) begin
        if ( (WARNING_MSGS_ON == 1) && (a_clk_flag == 1'b0) ) begin
          $display(" Warning: A_DOUT_CLK is not synchronized to A_CLK in pipeline mode at time %0.1fps! Instance: %m", $realtime);
          a_clk_flag = 1'b1;
        end
      end
      else
        a_clk_flag = 1'b0;
    end
  end
  always @( A_DOUT_LAT ) begin
    if( A_DOUT_LAT === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: A_DOUT_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  // Enables for the output pipeline registers
  always @( A_DOUT_EN_int ) begin
    if( A_DOUT_EN_int === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: A_DOUT_EN went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  // Synchronous reset for the output pipeline registers
  always @( A_DOUT_SRST_N_int ) begin
    if( A_DOUT_SRST_N_int === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: A_DOUT_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  
 
  // Pipeline warnings at port B
  always @(posedge B_DOUT_CLK_int) begin
    B_DOUT_CLK_period = $time - B_DOUT_CLK_re;
    B_DOUT_CLK_re = $time;
    
    if ( B_DOUT_LAT === 1'b0 ) begin
      if ( (B_DOUT_CLK_period != B_CLK_period) && (TWOPORT != 1'b1) ) begin
        if ( (WARNING_MSGS_ON == 1) && (b_clk_flag == 1'b0) ) begin
          $display(" Warning: B_DOUT_CLK is not synchronized to B_CLK in pipeline mode at time %0.1fps! Instance: %m", $realtime);
          b_clk_flag = 1'b1;
        end
      end
      else
        b_clk_flag = 1'b0;
      
      if( A_TWOPORT === 1'b1 ) begin
        if ( B_DOUT_CLK_period != A_CLK_period ) begin
          if ( (WARNING_MSGS_ON == 1) && (b_dout_clk_flag == 1'b0) ) begin
            $display(" Warning: B_DOUT_CLK is not synchronized to A_CLK in R36 pipeline mode at time %0.1fps! Instance: %m", $realtime);
            b_dout_clk_flag = 1'b1;
          end
        end
        else
          b_dout_clk_flag = 1'b0;
      end
    end
  end
  always @( B_DOUT_LAT ) begin
    if( B_DOUT_LAT === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: B_DOUT_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  // Enables for the output pipeline registers
  always @( B_DOUT_EN_int ) begin
    if( B_DOUT_EN_int === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: B_DOUT_EN went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  // Synchronous reset for the output pipeline registers
  always @( B_DOUT_SRST_B_int ) begin
    if( B_DOUT_SRST_B_int === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display(" Warning: B_DOUT_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end

  assign A_WE_lat = A_CLK_int ? A_WE_lat : A_WEN_int;   // In 2-port mode, port A is always enabled as a read port
  assign B_WE_lat = B_CLK_int ? B_WE_lat : B_WEN_int;
  
  // SAR 61056: Determining whether WEA or WEB are dynamic
  always @(A_WEN_int) begin
    if ( (A_WEN_int != A_WEN_prev) && (^A_WEN_prev !== 1'bx) )
      A_WE_dyn = 1'b1;
    else
      A_WE_dyn = 1'b0;
    A_WEN_prev = A_WEN_int;
  end
  always @(B_WEN_int) begin
    if ( (B_WEN_int != B_WEN_prev) && (^B_WEN_prev !== 1'bx) )
      B_WE_dyn = 1'b1;
    else
      B_WE_dyn = 1'b0;
    B_WEN_prev = B_WEN_int;
  end
  
  
  always @(posedge B_CLK_dly) begin
    if ( NO_COLLISION == 0 ) begin
      // The collision warnings has to be delayed to cover up for the case when the A and B clocks are idenitcal
      if ( (B_WE_lat === 2'b00) && (TWOPORT === 1'b0) ) begin
        // read mode, only for dual-port
        if( (B_ARST_N === 1'b1) && (B_BLK_lat === 1'b1) && (A_BLK_lat === 1'b1) ) begin
          // reading is only allowed when there is no reset on port B and blk select is high
          address_overlap(B_ADDR_lat, A_ADDR_lat, B_WIDTH, A_WIDTH, Same_Addr, B_Addr_Overlap_L, B_Addr_Overlap_H);
          collision(B_ADDR_lat, A_ADDR_lat, B_WIDTH, A_WIDTH, Same_Addr, collision_b);
          
          if ( (Same_Addr === 1'b1) && ((A_CLK_re_active + TC2CWRH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
          begin
            // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
            if ( WARNING_MSGS_ON == 1 ) begin
              $display (" ** Warning: Port A Write to and Port B Read from the same address at the same time. Read data from conflicting address is unknown"); 
              $display (" Time: %0.1fps! Instance: %m ", B_CLK_re_real );
            end
            for ( j=0; j<18; j=j+1 )
              B_DOUT_stg[j] = (collision_b[j] == 1'b1) ? 1'bx : B_DOUT_stg[j];
          end
        end
      end
    end
  end
  
  // Collision detection for Port A read and port B write
  always @(posedge A_CLK_dly) begin
    if ( NO_COLLISION == 0 ) begin
      // The collision warnings has to be delayed to cover up for the case when the A and B clocks are idenitcal
      if ( (A_WE_lat === 2'b00) || (TWOPORT === 1'b1) ) begin
        // read mode
        if( (A_ARST_N === 1'b1) && (A_BLK_lat === 1'b1) && (B_BLK_lat === 1'b1) ) begin
          address_overlap(A_ADDR_lat, B_ADDR_lat, A_WIDTH, B_WIDTH, Same_Addr, A_Addr_Overlap_L, A_Addr_Overlap_H);
          collision(A_ADDR_lat, B_ADDR_lat, A_WIDTH, B_WIDTH, Same_Addr, collision_a);
          if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWRH) >= A_CLK_re_active)
                && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
          begin
            // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
            if ( WARNING_MSGS_ON == 1 ) begin
              $display (" ** Warning: Port B Write and Port A Read to/from the same address at the same time. Read data from conflicting address is unknown"); 
              $display (" Time: %0.1fps! Instance: %m ", A_CLK_re_real );
            end
            case (A_WIDTH)
              3'b000,3'b001,3'b010,3'b011,3'b100 : 
                begin  // Dual-port mode
                  for ( j=0; j<18; j=j+1 )
                    A_DOUT_stg[j] = (collision_a[j] == 1'b1) ? 1'bx : A_DOUT_stg[j];
                end
            
              3'b101,3'b110,3'b111 : 
                begin  // Two-port mode
                  if (A_Addr_Overlap_L < 18) begin
                    for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                      A_DOUT_stg[j] = 1'bx;
                  end
                  else begin
                    for ( j=A_Addr_Overlap_L-18; j<=A_Addr_Overlap_H-18; j=j+1 )
                      B_DOUT_stg[j] = 1'bx;
                  end
                end
            endcase
          end
        end
      end
    end
  end

  always @(posedge A_CLK_int) begin
    A_CLK_period = $time - A_CLK_re;
    A_CLK_re = $time;
    A_ADDR_lat = A_ADDR_int;
    A_BLK_lat = A_BLK_int;
    if (TWOPORT === 1'b0) begin
      A_DIN_lat = A_DIN_int;
    end
    
    if (A_BLK_lat === 1'b1) begin
      A_CLK_re_active = $time;
      A_CLK_re_real = $realtime;
    end
    
    // SAR 61056: In case of R36/W36, we need to make sure that WEA and WEB are static
    if( (B_TWOPORT === 1'b1) && (A_TWOPORT === 1'b1)  ) begin
      if ( B_CLK_period != A_CLK_period ) begin
        if( (A_WE_dyn === 1'b1) || (B_WE_dyn === 1'b1) ) begin
          if ( (WARNING_MSGS_ON == 1) && (WARNING_1_ON == 1) )
            $display(" Warning: B_CLK is not synchronized to A_CLK in W36 mode at time %0.1fps! Instance: %m", $realtime);
          WARNING_1_ON = 0;
        end
      end
    end
    
    if( (B_TWOPORT === 1'b1) && (A_TWOPORT !== 1'b1) ) begin
      if ( B_CLK_period != A_CLK_period ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display(" Warning: B_CLK is not synchronized to A_CLK in W36 mode at time %0.1fps! Instance: %m", $realtime);
      end
    end
    
    if ( ((A_WE_lat[0] === 1'b1) || (A_WE_lat[1] === 1'b1)) && (TWOPORT === 1'b0) ) begin
      // write mode - only supported in dual-port mode
      if ((^A_ADDR_lat) === 1'bx) begin
        if ( WARNING_MSGS_ON == 1 )
          $display(" Warning: Illegal address on port A at time %0.1fps! Instance: %m", $realtime);
      end
      else if( (A_ARST_N_int === 1'b1) && (A_BLK_lat === 1'b1) ) begin
        A_CLK_Wre = A_CLK_re_active;
        address_overlap(A_ADDR_lat, B_ADDR_lat, A_WIDTH, B_WIDTH, Same_Addr, A_Addr_Overlap_L, A_Addr_Overlap_H);
        collision(A_ADDR_lat, B_ADDR_lat, A_WIDTH, B_WIDTH, Same_Addr, collision_a);
        case (A_WIDTH)
          3'b000 : begin
            if( A_WE_lat === 2'b01 ) begin
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ A_ADDR_lat[2:0] + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[0];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                   && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( A_WMODE === 1'b1 ) begin
                A_DOUT_stg[0] = A_DIN_lat[0];
              end
              else if( A_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: A_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                  A_WE_lat, A_WIDTH, $realtime);
            end
          end
          
          3'b001 : begin
            if( A_WE_lat === 2'b01 ) begin
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2:1] * 2) + 0 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[0];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2:1] * 2) + 1 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[1];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                   && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( A_WMODE === 1'b1 ) begin
                A_DOUT_stg[1:0] = A_DIN_lat[1:0];
              end
              else if( A_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: A_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN state of %2b is unallowed for a width of %3b at time %0.1fps! Instance: %m", 
                  A_WE_lat, A_WIDTH, $realtime);
            end
          end
          3'b010 : begin
            if( A_WE_lat === 2'b01 ) begin
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 0 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[0];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 1 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[1];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 2 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[2];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 3 + (9 * A_ADDR_lat[3]) ] = A_DIN_lat[3];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                   && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( A_WMODE === 1'b1 ) begin
                A_DOUT_stg[3:0] = A_DIN_lat[3:0];
              end
              else if( A_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: A_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN state of %2b is unallowed for a width of %3b at time %0.1fps! Instance: %m", 
                  A_WE_lat, A_WIDTH, $realtime);
            end
          end
          3'b011 : begin
            if( A_WE_lat === 2'b01 ) begin
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 0 ] = A_DIN_lat[0];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 1 ] = A_DIN_lat[1];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 2 ] = A_DIN_lat[2];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 3 ] = A_DIN_lat[3];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 4 ] = A_DIN_lat[4];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 5 ] = A_DIN_lat[5];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 6 ] = A_DIN_lat[6];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 7 ] = A_DIN_lat[7];
              MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 8 ] = A_DIN_lat[8];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                   && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( A_WMODE === 1'b1 ) begin
                A_DOUT_stg[8:0] = A_DIN_lat[8:0];
              end
              else if( A_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display(" Warning: A_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN state of %2b is unallowed for a width of %3b at time %0.1fps! Instance: %m", 
                  A_WE_lat, A_WIDTH, $realtime);
            end
          end
          3'b100 : begin
            case( A_WE_lat )
              2'b01: begin
                MEM_1024_18[ A_ADDR_lat[13:4] ] [8:0] = A_DIN_lat[8:0];
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                     && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                  begin
                    if( A_Addr_Overlap_L < 9 ) begin
                      // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                      if ( WARNING_MSGS_ON == 1 ) begin
                        $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                        $display (" Time: %0.1fps! Instance: %m ", $realtime );
                      end
                      if ( A_Addr_Overlap_H > 8 )
                        A_Addr_Overlap_H = 8;
                      for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                        MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                    end
                  end
                end
                
              end
              2'b10: begin
                MEM_1024_18[ A_ADDR_lat[13:4] ] [17:9] = A_DIN_lat[17:9];
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                     && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                  begin
                    if( A_Addr_Overlap_H > 8 ) begin
                      // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                      if ( WARNING_MSGS_ON == 1 ) begin
                        $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                        $display (" Time: %0.1fps! Instance: %m ", $realtime );
                      end
                      if ( A_Addr_Overlap_L < 9 )
                        A_Addr_Overlap_L = 9;
                      for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                        MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                    end
                  end
                end
              end
              2'b11: begin
                MEM_1024_18[ A_ADDR_lat[13:4] ] = A_DIN_lat;
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && ((B_CLK_re_active + TC2CWWH) >= A_CLK_re_active)
                     && (((A_WE_lat[0]||A_WE_lat[1]||B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b1))||((B_WE_lat[0]||B_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0))))
                  begin
                    // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                    if ( WARNING_MSGS_ON == 1 ) begin
                      $display (" ** Warning: Port B Write and Port A Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                      $display (" Time: %0.1fps! Instance: %m ", $realtime );
                    end
                    for ( j=A_Addr_Overlap_L; j<=A_Addr_Overlap_H; j=j+1 )
                      MEM_1024_18[ A_ADDR_lat[13:4] ] [j] = 1'bx;
                  end
                end
              end
              default: begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: A_WEN state of %2b is unallowed for a width of %3b at time %0.1fps! Instance: %m", 
                    A_WE_lat, A_WIDTH, $realtime);
              end
            endcase
            if( A_WMODE === 1'b1 ) begin
              A_DOUT_stg[17:0] = A_DIN_lat[17:0];
            end
            else if( A_WMODE === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display(" Warning: A_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
            end
          end
          3'b101,3'b110,3'b111 : begin  
            // In two-port mode, write operation is controlled by port B controls
          end
          default: begin
            if ( WARNING_MSGS_ON == 1 )
              $display ("Warning: invalid WIDTH configuration on Port A at time %0.1fps! Legal Width: 1,2,4,9,18,36. Instance: %m", $realtime);
          end
        endcase
      end
    end
    else if ( (A_WE_lat === 2'b00) || (TWOPORT === 1'b1) ) begin
      // read mode
      if ((^A_ADDR_lat) === 1'bx) begin
        if ( WARNING_MSGS_ON == 1 )
          $display(" Warning: Illegal address on port A at time %0.1fps! Instance: %m", $realtime);
      end
      else if( (A_ARST_N === 1'b1) && (A_BLK_lat === 1'b1) ) begin
        // reading is only allowed when there is no reset on port A and blk select is high
        // this is true for both dual- and two-port modes
        A_DOUT_stg[17:0] = 18'b0;
        case (A_WIDTH)
        3'b000 : begin
          A_DOUT_stg[0] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ A_ADDR_lat[2:0] + (9 * A_ADDR_lat[3]) ];
        end
        3'b001 : begin
          A_DOUT_stg[0] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2:1] * 2) + 0 + (9 * A_ADDR_lat[3]) ];
          A_DOUT_stg[1] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2:1] * 2) + 1 + (9 * A_ADDR_lat[3]) ];
        end
        3'b010 : begin
          A_DOUT_stg[0] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 0 + (9 * A_ADDR_lat[3]) ];
          A_DOUT_stg[1] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 1 + (9 * A_ADDR_lat[3]) ];
          A_DOUT_stg[2] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 2 + (9 * A_ADDR_lat[3]) ];
          A_DOUT_stg[3] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[2] * 4) + 3 + (9 * A_ADDR_lat[3]) ];
        end
        3'b011 : begin
          A_DOUT_stg[0] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 0 ];
          A_DOUT_stg[1] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 1 ];
          A_DOUT_stg[2] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 2 ];
          A_DOUT_stg[3] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 3 ];
          A_DOUT_stg[4] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 4 ];
          A_DOUT_stg[5] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 5 ];
          A_DOUT_stg[6] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 6 ];
          A_DOUT_stg[7] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 7 ];
          A_DOUT_stg[8] = MEM_1024_18[ A_ADDR_lat[13:4] ] [ (A_ADDR_lat[3] * 9) + 8 ];
        end
        3'b100 : begin
          A_DOUT_stg = MEM_1024_18[ A_ADDR_lat[13:4] ];
        end
        3'b101,3'b110,3'b111 : begin  // Two-port mode
          B_DOUT_stg[17:0] = 18'b0;
          case (B_WIDTH) 
            3'b111,3'b110,3'b101,3'b100,3'b011 : begin
              B_DOUT_stg = MEM_1024_18[ A_ADDR_lat[13:5] * 2 ];
              A_DOUT_stg = MEM_1024_18[ (A_ADDR_lat[13:5] * 2) + 1 ];
            end
            3'b000,3'b001,3'b010 : begin    // If there is  W4/W2/W1, then we have R32 instead of R36
              B_DOUT_stg[16:9] = MEM_1024_18[ A_ADDR_lat[13:5] * 2 ] [ 16:9 ];
              B_DOUT_stg[7:0]  = MEM_1024_18[ A_ADDR_lat[13:5] * 2 ] [ 7:0 ];
              A_DOUT_stg[16:9] = MEM_1024_18[ (A_ADDR_lat[13:5] * 2) + 1 ] [ 16:9 ];
              A_DOUT_stg[7:0]  = MEM_1024_18[ (A_ADDR_lat[13:5] * 2) + 1 ] [ 7:0 ];
            end
            default: begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: invalid WIDTH configuration on Port B at time %0.1fps! Legal Width: 1,2,4,9,18,36. Instance: %m", $realtime);
            end
          endcase
        end
        default: begin
          if ( WARNING_MSGS_ON == 1 )
            $display ("Warning: invalid WIDTH configuration on Port A at time %0.1fps! Legal Width: 1,2,4,9,18,36. Instance: %m", $realtime);
        end
        endcase
      end      
    end
    else begin
      if ( WARNING_MSGS_ON == 1 )
        $display ("Warning: A_WEN went unknown at time %0.1fps! Instance: %m", $realtime);
    end
  end
  
  always @(posedge B_CLK_int) begin
    B_CLK_period = $time - B_CLK_re;
    B_CLK_re = $time;
    B_ADDR_lat = B_ADDR_int;
    B_DIN_lat = B_DIN_int;
    B_BLK_lat = B_BLK_int;
    if (TWOPORT === 1'b1) begin
      A_DIN_lat = A_DIN_int;
    end
    
    if (B_BLK_lat === 1'b1) begin
      B_CLK_re_active = $time;
      B_CLK_re_real = $realtime;
    end
    
    if ( (((B_WE_lat[0] === 1'b1) || (B_WE_lat[1] === 1'b1)) && (TWOPORT === 1'b0)) || // dual-port
         (((B_WE_lat[0] === 1'b1) || (B_WE_lat[1] === 1'b1) || (A_WE_lat[0] === 1'b1) || (A_WE_lat[1] === 1'b1)) && (TWOPORT === 1'b1)) ) begin  // 2-port
      //write mode
      if ((^B_ADDR_lat) === 1'bx) begin
        if ( WARNING_MSGS_ON == 1 )
          $display(" Warning: Illegal address on port B at time %0.1fps! Instance: %m", $realtime);
      end
      else if( (B_ARST_N_int === 1'b1) && (B_BLK_lat === 1'b1) ) begin
        B_CLK_Wre = B_CLK_re_active;
        address_overlap(B_ADDR_lat, A_ADDR_lat, B_WIDTH, A_WIDTH, Same_Addr, B_Addr_Overlap_L, B_Addr_Overlap_H);
        collision(B_ADDR_lat, A_ADDR_lat, B_WIDTH, A_WIDTH, Same_Addr, collision_b);
        
        case (B_WIDTH)
          3'b000 : begin
            if( B_WE_lat === 2'b01 ) begin
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ B_ADDR_lat[2:0] + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[0];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( B_WMODE === 1'b1 ) begin
                B_DOUT_stg[0] = B_DIN_lat[0];
              end
              else if( B_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                  B_WE_lat, B_WIDTH, $realtime);
            end
          end
          
          3'b001 : begin
            if( B_WE_lat === 2'b01 ) begin
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2:1] * 2) + 0 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[0];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2:1] * 2) + 1 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[1];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( B_WMODE === 1'b1 ) begin
                B_DOUT_stg[1:0] = B_DIN_lat[1:0];
              end
              else if( B_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                  B_WE_lat, B_WIDTH, $realtime);
            end
          end
          3'b010 : begin
            if( B_WE_lat === 2'b01 ) begin
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2] * 4) + 0 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[0];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2] * 4) + 1 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[1];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2] * 4) + 2 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[2];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[2] * 4) + 3 + (9 * B_ADDR_lat[3]) ] = B_DIN_lat[3];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( B_WMODE === 1'b1 ) begin
                B_DOUT_stg[3:0] = B_DIN_lat[3:0];
              end
              else if( B_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                  B_WE_lat, B_WIDTH, $realtime);
            end
          end
          3'b011 : begin
            if( B_WE_lat === 2'b01 ) begin
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 0 ] = B_DIN_lat[0];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 1 ] = B_DIN_lat[1];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 2 ] = B_DIN_lat[2];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 3 ] = B_DIN_lat[3];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 4 ] = B_DIN_lat[4];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 5 ] = B_DIN_lat[5];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 6 ] = B_DIN_lat[6];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 7 ] = B_DIN_lat[7];
              MEM_1024_18[ B_ADDR_lat[13:4] ] [ (B_ADDR_lat[3] * 9) + 8 ] = B_DIN_lat[8];
              
              if ( NO_COLLISION == 0 ) begin
                if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                begin
                  // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                  if ( WARNING_MSGS_ON == 1 ) begin
                    $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                    $display (" Time: %0.1fps! Instance: %m ", $realtime );
                  end
                  for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                    MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                end
              end
              
              if( B_WMODE === 1'b1 ) begin
                B_DOUT_stg[8:0] = B_DIN_lat[8:0];
              end
              else if( B_WMODE === 1'bx ) begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
              end
            end
            else begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                  B_WE_lat, B_WIDTH, $realtime);
            end
          end
          3'b100 : begin
            case( B_WE_lat )
              2'b01: begin
                MEM_1024_18[ B_ADDR_lat[13:4] ] [8:0] = B_DIN_lat[8:0];
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                  begin
                    // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                    if ( WARNING_MSGS_ON == 1 ) begin
                      $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                      $display (" Time: %0.1fps! Instance: %m ", $realtime );
                    end
                    if ( B_Addr_Overlap_H > 9 )
                        B_Addr_Overlap_H = 9;
                    for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                      MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                  end
                end
              end
              2'b10: begin
                MEM_1024_18[ B_ADDR_lat[13:4] ] [17:9] = B_DIN_lat[17:9];
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                  begin
                    // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                    if ( WARNING_MSGS_ON == 1 ) begin
                      $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                      $display (" Time: %0.1fps! Instance: %m ", $realtime );
                    end
                    if ( B_Addr_Overlap_L < 9 )
                        B_Addr_Overlap_L = 9;
                    for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                      MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                  end
                end
              end
              2'b11: begin
                MEM_1024_18[ B_ADDR_lat[13:4] ] = B_DIN_lat;
                
                if ( NO_COLLISION == 0 ) begin
                  if ( (Same_Addr === 1'b1) && (A_BLK_lat === 1'b1) && ((A_CLK_re_active + TC2CWWH) >= B_CLK_re_active) && ((A_WE_lat[0]||A_WE_lat[1] == 1'b1) && (TWOPORT === 1'b0)))
                  begin
                    // Collision, write from port B at the same address. Read operation will be unknown while the write will be successful
                    if ( WARNING_MSGS_ON == 1 ) begin
                      $display (" ** Warning: Port A Write and Port B Write to the same address at the same time. Memory contents at conflicting address is unknown"); 
                      $display (" Time: %0.1fps! Instance: %m ", $realtime );
                    end
                    for ( j=B_Addr_Overlap_L; j<=B_Addr_Overlap_H; j=j+1 )
                      MEM_1024_18[ B_ADDR_lat[13:4] ] [j] = 1'bx;
                  end
                end
                
              end
              default: begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: B_WEN state of %2b is not allowed for a width of %3b at time %0.1fps! Instance: %m", 
                    B_WE_lat, B_WIDTH, $realtime);
              end
            endcase
            if( B_WMODE === 1'b1 ) begin
              B_DOUT_stg[17:0] = B_DIN_lat[17:0];
            end
            else if( B_WMODE === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
            end
          end
          3'b101,3'b110,3'b111 : begin  
            // two-port mode
            if( B_WE_lat[0] === 1'b1 ) begin
              MEM_1024_18[ B_ADDR_lat[13:5] * 2 ] [ 8:0 ] = B_DIN_lat[8:0];
            end
            else if( B_WE_lat[0] === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN[0] went unknown at time %0.1fps! Instance: %m", $realtime);
            end
            
            if( B_WE_lat[1] === 1'b1 ) begin
              MEM_1024_18[ B_ADDR_lat[13:5] * 2 ] [ 17:9 ] = B_DIN_lat[17:9];
            end
            else if( B_WE_lat[1] === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WEN[1] went unknown at time %0.1fps! Instance: %m", $realtime);
            end
            
            if( A_WE_lat[0] === 1'b1 ) begin
              MEM_1024_18[ B_ADDR_lat[13:5] * 2 + 1 ] [ 8:0 ] = A_DIN_lat[8:0];
            end
            else if( A_WE_lat[0] === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN[0] went unknown at time %0.1fps! Instance: %m", $realtime);
            end
            
            if( A_WE_lat[1] === 1'b1 ) begin
              MEM_1024_18[ B_ADDR_lat[13:5] * 2 + 1 ] [ 17:9 ] = A_DIN_lat[17:9];
            end
            else if( A_WE_lat[1] === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: A_WEN[1] went unknown at time %0.1fps! Instance: %m", $realtime);
            end
            
            if( (A_WMODE === 1'b1) && (B_WMODE === 1'b1) ) begin
              B_DOUT_stg[17:0] = B_DIN_lat[17:0];
              A_DOUT_stg[17:0] = A_DIN_lat[17:0];
            end
            else if( B_WMODE === 1'bx ) begin
              if ( WARNING_MSGS_ON == 1 )
                $display ("Warning: B_WMODE went unknown at time %0.1fps! Instance: %m", $realtime);
            end
          end
          default: begin
            if ( WARNING_MSGS_ON == 1 )
              $display ("Warning: invalid WIDTH configuration on Port B at time %0.1fps! Legal Width: 1,2,4,9,18,36. Instance: %m", $realtime);
          end
        endcase
      end
    end
    else if ( (B_WE_lat === 2'b00) && (TWOPORT === 1'b0) ) begin
      // read mode, only for dual-port
      if ((^B_ADDR_int) === 1'bx) begin
        if ( WARNING_MSGS_ON == 1 )
          $display(" Warning: Illegal address on port B at time %0.1fps! Instance: %m", $realtime);
      end
      else if( (B_ARST_N === 1'b1) && (B_BLK_lat === 1'b1) ) begin
        // reading is only allowed when there is no reset on port B and blk select is high
        B_DOUT_stg[17:0] = 0;
        case (B_WIDTH)
          3'b000 : begin
            B_DOUT_stg[0] = MEM_1024_18[ B_ADDR_int[13:4] ] [ B_ADDR_int[2:0] + (9 * B_ADDR_lat[3]) ];
          end
          3'b001 : begin
            B_DOUT_stg[0] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2:1] * 2) + 0 + (9 * B_ADDR_lat[3]) ];
            B_DOUT_stg[1] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2:1] * 2) + 1 + (9 * B_ADDR_lat[3]) ];
          end
          3'b010 : begin
            B_DOUT_stg[0] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2] * 4) + 0 + (9 * B_ADDR_lat[3]) ];
            B_DOUT_stg[1] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2] * 4) + 1 + (9 * B_ADDR_lat[3]) ];
            B_DOUT_stg[2] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2] * 4) + 2 + (9 * B_ADDR_lat[3]) ];
            B_DOUT_stg[3] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[2] * 4) + 3 + (9 * B_ADDR_lat[3]) ];
          end
          3'b011 : begin
            B_DOUT_stg[0] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 0 ];
            B_DOUT_stg[1] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 1 ];
            B_DOUT_stg[2] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 2 ];
            B_DOUT_stg[3] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 3 ];
            B_DOUT_stg[4] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 4 ];
            B_DOUT_stg[5] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 5 ];
            B_DOUT_stg[6] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 6 ];
            B_DOUT_stg[7] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 7 ];
            B_DOUT_stg[8] = MEM_1024_18[ B_ADDR_int[13:4] ] [ (B_ADDR_int[3] * 9) + 8 ];
          end
          3'b100 : begin
            B_DOUT_stg = MEM_1024_18[ B_ADDR_int[13:4] ];
          end
          3'b101,3'b110,3'b111 : begin  
            // In two-port mode, read is not controlled by port B controls
          end
          default: begin
            if ( WARNING_MSGS_ON == 1 )
              $display ("Warning: invalid WIDTH configuration on Port B at time %0.1fps! Legal Width: 1,2,4,9,18,36. Instance: %m", $realtime);
          end
        endcase
      end
    end
  end
  
  // function to convert address vector to integer based on the width of the data port
  function integer get_address;
    input [13:0] addr_signal;
    input [2:0] width;
    integer      ADDR,i,LSB;
    begin
      ADDR = 0;
      case (width)
        3'b000 : LSB = 0;
        3'b001 : LSB = 1;
        3'b010 : LSB = 2;
        3'b011 : LSB = 3;
        3'b100 : LSB = 4;
        3'b101,3'b110,3'b111 : LSB = 5;
      endcase
      
      for( i=LSB; i<14; i=i+1) begin
        ADDR = ADDR + ( addr_signal[i]*(2**(i-LSB)) );
      end
      get_address = ADDR;
    end
  endfunction
  
  task collision;
    input [13:0]     R_ADDR;
    input [13:0]     W_ADDR;
    input [2:0]     R_WIDTH;
    input [2:0]     W_WIDTH;
    output          same_address;
    output [17:0]   collision;
    
    integer     j;
    reg         addr_overlap_0, addr_overlap_1, addr_overlap;
    reg [17:0]  collision_0, collision_1;
    
    begin
      if ( R_ADDR[13:4] === W_ADDR[13:4] ) begin
        case ( R_WIDTH )
          3'b000 : addr_overlap_0 = ( (R_ADDR[3:0] === W_ADDR[3:0]) ? 1'b1 : 1'b0 );
          3'b001 : addr_overlap_0 = ( (R_ADDR[3:1] === W_ADDR[3:1]) ? 1'b1 : 1'b0 );
          3'b010 : addr_overlap_0 = ( (R_ADDR[3:2] === W_ADDR[3:2]) ? 1'b1 : 1'b0 );
          3'b011 : addr_overlap_0 = ( (R_ADDR[ 3 ] === W_ADDR[ 3 ]) ? 1'b1 : 1'b0 );
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   addr_overlap_0 = 1'b1;
          default : addr_overlap_0 = 1'b0;
        endcase
        
        case ( W_WIDTH )
          3'b001 : addr_overlap_1 = ( (R_ADDR[3:1] === W_ADDR[3:1]) ? 1'b1 : 1'b0 );
          3'b010 : addr_overlap_1 = ( (R_ADDR[3:2] === W_ADDR[3:2]) ? 1'b1 : 1'b0 );
          3'b011 : addr_overlap_1 = ( (R_ADDR[ 3 ] === W_ADDR[ 3 ]) ? 1'b1 : 1'b0 );
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   addr_overlap_1 = 1'b1;
          default : addr_overlap_1 = 1'b0;
        endcase
        
        same_address = ( (R_WIDTH === W_WIDTH) || (R_WIDTH[2] & W_WIDTH[2] === 1'b1) ) ? addr_overlap_0 :
                       ( ( R_WIDTH > W_WIDTH ) ? addr_overlap_0 :
                       ( ( R_WIDTH < W_WIDTH ) ? addr_overlap_1 : 1'b0 ) );
                  
        case ( R_WIDTH )
          3'b000 : collision_0 = 18'h1;
          3'b001 : collision_0 = 18'h3;
          3'b010 : collision_0 = 18'hF;
          3'b011 : collision_0 = 18'h1FF;
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   collision_0 = 18'h3FFFF;
          default : collision_0 = 18'h0;
        endcase
        
        case ( W_WIDTH )
          3'b000 : collision_1 = 2**( W_ADDR[2:0] + (9 * W_ADDR[3]) );
          3'b001 : collision_1 = 2**( (W_ADDR[2:1] * 2) + 1 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2:1] * 2) + 0 + (9 * W_ADDR[3]) );
          3'b010 : collision_1 = 2**( (W_ADDR[2] * 4) + 3 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2] * 4) + 2 + (9 * W_ADDR[3]) ) + 
                                 2**( (W_ADDR[2] * 4) + 1 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2] * 4) + 0 + (9 * W_ADDR[3]) );
          3'b011 : collision_1 = 2**( (W_ADDR[3] * 9) + 8 ) + 2**( (W_ADDR[3] * 9) + 7 ) + 2**( (W_ADDR[3] * 9) + 6 ) +
                                 2**( (W_ADDR[3] * 9) + 5 ) + 2**( (W_ADDR[3] * 9) + 4 ) + 2**( (W_ADDR[3] * 9) + 3 ) +
                                 2**( (W_ADDR[3] * 9) + 2 ) + 2**( (W_ADDR[3] * 9) + 1 ) + 2**( (W_ADDR[3] * 9) + 0 );
          default : collision_1 = 18'h0;
        endcase
        
        collision = ( (R_WIDTH === W_WIDTH) || (R_WIDTH[2] & W_WIDTH[2] === 1'b1) ) ? collision_0 & {18{addr_overlap_0}}:
                    ( ( R_WIDTH > W_WIDTH ) ? collision_1 & {18{addr_overlap_1}} :
                    ( ( R_WIDTH < W_WIDTH ) ? collision_0 & {18{addr_overlap_0}} : 18'b0 ) );

      end
      else begin
        addr_overlap = 1'b0;
        addr_overlap_0 = 1'b0;
        addr_overlap_1 = 1'b0;
        collision = 18'b0;
        same_address = 1'b0;
      end
      
    end
  endtask
  
  task address_overlap;
    input [13:0]   addr_r, addr_w;
    input [2:0]    width_r, width_w;
    output         same_address;
    output integer overlap_min;
    output integer overlap_max;
    integer        max_r, max_w, min_r, min_w;
    begin
      same_address = 1'b0;
      overlap_max = 0;
      overlap_min = 0;
      get_range(addr_r[3:0],width_r,max_r,min_r);
      get_range(addr_w[3:0],width_w,max_w,min_w);
      
      if( (width_r > 3'b100) || (width_w > 3'b100) ) begin
        if( (width_r < 3'b101) && (width_w > 3'b100) ) begin
          // write port uses the 36 bits
          if( (addr_r[13:4] === addr_w[13:4]) || (addr_r[13:4] === addr_w[13:4]+1'b1) ) begin
            same_address = 1'b1;
            overlap_max = max_r;
            overlap_min = min_r;
          end
        end
        else begin
          if( (width_r > 3'b100) && (width_w < 3'b101) ) begin
            // read port uses the 36 bits
            if( addr_r[13:4] === addr_w[13:4] ) begin
              same_address = 1'b1;
              overlap_max = max_w;
              overlap_min = min_w;
            end
            else begin
              if( (addr_r[13:4]+1'b1) === addr_w[13:4] ) begin
                same_address = 1'b1;
                overlap_max = max_w + 18;
                overlap_min = min_w + 18;
              end
            end
          end
          else begin
            if( (width_r > 3'b100) && (width_w > 3'b100) ) begin
              // Both read and write are 36 bits wide
              if( addr_r[13:4] === addr_w[13:4] ) begin
                same_address = 1'b1;
                overlap_max = 0;
                overlap_min = 35;
              end
            end
          end
        end
      end
      else begin
        if( addr_r[13:4] === addr_w[13:4] ) begin
          if( (width_r === 3'b100) || (width_w === 3'b100) ) begin
            // One of the ports uses the full 18 bits width
            same_address = 1'b1;
            if (width_r > width_w) begin
              overlap_max = max_r;
              overlap_min = min_r;
            end
            else begin
              overlap_max = max_w;
              overlap_min = min_w;
            end
          end
          else begin
            if( width_r > width_w ) begin
              if( (max_r >= max_w) && (min_r <= min_w) ) begin
                same_address = 1'b1;
                overlap_max = max_w;
                overlap_min = min_w;
              end
              else if( (max_r >= max_w) && (min_r >= min_w) && (min_r <= max_w) ) begin
                same_address = 1'b1;
                overlap_max = max_w;
                overlap_min = min_r;
              end
              else if( (max_r < max_w) && (min_r < min_w) && (max_r >= min_w) ) begin
                same_address = 1'b1;
                overlap_max = max_r;
                overlap_min = min_w;
              end
            end
            else begin
              if( (max_w >= max_r) && (min_w <= min_r) ) begin
                same_address = 1'b1;
                overlap_max = max_r;
                overlap_min = min_r;
              end
              else if( (max_w >= max_r) && (min_w >= min_r) && (min_w <= max_r) ) begin
                same_address = 1'b1;
                overlap_max = max_r;
                overlap_min = min_w;
              end
              else if( (max_w < max_r) && (min_w < min_r) && (max_w >= min_r) ) begin
                same_address = 1'b1;
                overlap_max = max_w;
                overlap_min = min_r;
              end
            end
          end
        end
      end
    end
  endtask
  
  task get_range;
    input [3:0]    addr;
    input [2:0]    width;
    output integer max;
    output integer min;
    integer        address;
    begin
      case( width )
        3'b000 : begin
            address = addr[0]*1 + addr[1]*2 + addr[2]*4 + addr[3]*8;
            min = address;
            max = address;
          end
        3'b001 : begin
            address = addr[1]*1 + addr[2]*2 + addr[3]*4;
            min = address * 2;
            max = min + 1;
          end
        3'b010 : begin
            address = addr[2]*1 + addr[3]*2;
            min = address * 2;
            max = min + 4;
          end
        3'b011 : begin
            address = addr[3]*1;
            min = address * 9;
            max = min + 8;
          end
        3'b100 : begin
            min = 0;
            max = 17;
          end
        3'b101,3'b110,3'b111 : begin
            min = 0;
            max = 35;
          end
      endcase
    end
  endtask
  
  assign DINA_EN_DP = A_ARST_N & ~TWOPORT;
  assign DOUTA_FF_EN_1 = ~A_DOUT_LAT & A_DOUT_ARST_N & A_DOUT_EN;
  assign DOUTA_FF_EN_2 = ~A_DOUT_LAT & A_DOUT_ARST_N;
  assign DINB_EN_TP = B_ARST_N & TWOPORT;
  assign DINB_EN_DP = B_ARST_N & ~TWOPORT;
  assign DOUTB_FF_EN_1 = ~B_DOUT_LAT & B_DOUT_ARST_N & B_DOUT_EN;
  assign DOUTB_FF_EN_2 = ~B_DOUT_LAT & B_DOUT_ARST_N;
    
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_CLK *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[1] ) ( posedge A_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
        
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT && A_WIDTH[2] && A_WIDTH[0] ) ( posedge A_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT && ~TWOPORT ) ( posedge B_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
        
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ARST_N *> (A_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ARST_N *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge A_BLK[0] *> (A_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[0] *> (A_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge A_BLK[1] *> (A_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[1] *> (A_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge A_BLK[2] *> (A_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_BLK[2] *> (A_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[0] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[1] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[2] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge A_DOUT_ARST_N *> (A_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_DOUT_ARST_N *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[0] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[0] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[1] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[1] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    ( negedge B_BLK[2] *> (B_DOUT[0]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[1]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[2]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[3]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[4]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[5]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[6]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[7]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[8]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[9]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[10]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[11]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[12]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[13]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[14]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[15]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[16]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_BLK[2] *> (B_DOUT[17]+:18'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    $setup(posedge A_ADDR[0], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[1], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[2], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[3], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[4], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[5], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[6], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[7], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[8], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[9], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[10], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[11], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[12], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[13], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(negedge A_ADDR[0], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[1], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[2], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[3], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[4], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[5], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[6], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[7], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[8], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[9], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[10], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[11], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[12], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[13], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[2], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[3], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[4], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[5], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[6], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[7], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[8], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[9], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[10], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[11], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[12], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_ADDR[13], 0.0, NOTIFY_REG);

    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[2], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[3], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[4], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[5], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[6], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[7], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[8], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[9], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[10], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[11], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[12], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_ADDR[13], 0.0, NOTIFY_REG);

    $setup(posedge A_DIN[0], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[1], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[2], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[3], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[4], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[5], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[6], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[7], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[8], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[9], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[10], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[11], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[12], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[13], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[14], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[15], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[16], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[17], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);

    $setup(negedge A_DIN[0], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[1], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[2], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[3], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[4], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[5], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[6], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[7], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[8], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[9], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[10], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[11], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[12], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[13], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[14], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[15], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[16], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[17], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);

    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[2], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[3], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[4], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[5], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[6], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[7], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[8], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[9], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[10], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[11], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[12], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[13], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[14], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[15], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[16], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_DIN[17], 0.0, NOTIFY_REG);

    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[2], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[3], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[4], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[5], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[6], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[7], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[8], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[9], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[10], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[11], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[12], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[13], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[14], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[15], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[16], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_DIN[17], 0.0, NOTIFY_REG);
    
    $setup(posedge A_BLK[0], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_BLK[1], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge A_BLK[2], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[0], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[1], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[2], posedge A_CLK &&& A_ARST_N, 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, posedge A_BLK[2], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& A_ARST_N, negedge A_BLK[2], 0.0, NOTIFY_REG);
    
    $setup(posedge A_WEN[0], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge A_WEN[1], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_WEN[0], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge A_WEN[1], posedge A_CLK &&& DINA_EN_DP, 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, posedge A_WEN[1], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge A_CLK &&& DINA_EN_DP, negedge A_WEN[1], 0.0, NOTIFY_REG);
    
    $recovery(posedge A_ARST_N, posedge A_CLK, 0.0, NOTIFY_REG);
    $hold(posedge A_CLK, posedge A_ARST_N, 0.0, NOTIFY_REG);
    
    $recovery(posedge A_DOUT_ARST_N, posedge A_DOUT_CLK, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK, posedge A_DOUT_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_DOUT_SRST_N, posedge A_DOUT_CLK &&& DOUTA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_DOUT_SRST_N, posedge A_DOUT_CLK &&& DOUTA_FF_EN_1, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_1, posedge A_DOUT_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_1, negedge A_DOUT_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_DOUT_EN, posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge A_DOUT_EN, posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, posedge A_DOUT_EN, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, negedge A_DOUT_EN, 0.0, NOTIFY_REG);
    
    $setup(posedge B_ADDR[0], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[1], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[2], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[3], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[4], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[5], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[6], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[7], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[8], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[9], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[10], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[11], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[12], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[13], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);

    $setup(negedge B_ADDR[0], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[1], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[2], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[3], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[4], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[5], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[6], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[7], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[8], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[9], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[10], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[11], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[12], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[13], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_ADDR[	13	], 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_ADDR[	13	], 0.0, NOTIFY_REG);

    
    $setup(posedge B_DIN[	0	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	1	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	2	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	3	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	4	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	5	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	6	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	7	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	8	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	9	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	10	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	11	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	12	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	13	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	14	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	15	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	16	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_DIN[	17	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);

    $setup(negedge B_DIN[	0	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	1	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	2	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	3	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	4	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	5	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	6	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	7	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	8	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	9	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	10	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	11	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	12	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	13	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	14	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	15	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	16	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_DIN[	17	], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_DIN[	17	], 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_DIN[	17	], 0.0, NOTIFY_REG);

    
    $setup(posedge A_DIN[	0	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	1	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	2	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	3	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	4	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	5	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	6	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	7	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	8	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	9	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	10	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	11	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	12	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	13	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	14	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	15	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	16	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_DIN[	17	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);

    $setup(negedge A_DIN[	0	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	1	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	2	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	3	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	4	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	5	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	6	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	7	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	8	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	9	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	10	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	11	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	12	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	13	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	14	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	15	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	16	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_DIN[	17	], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_DIN[	17	], 0.0, NOTIFY_REG);

    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_DIN[	17	], 0.0, NOTIFY_REG);

    
    $setup(posedge B_BLK[0], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge B_BLK[1], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $setup(posedge B_BLK[2], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[0], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[1], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[2], posedge B_CLK &&& DINB_EN_DP, 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, posedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, posedge B_BLK[2], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, posedge B_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, negedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, negedge B_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_DP, negedge B_BLK[2], 0.0, NOTIFY_REG);
    
    $setup(posedge B_WEN[0], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge B_WEN[1], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_WEN[0], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge B_WEN[1], posedge B_CLK &&& B_ARST_N, 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, posedge B_WEN[1], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& B_ARST_N, negedge B_WEN[1], 0.0, NOTIFY_REG);
    
    $setup(posedge A_WEN[0], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(posedge A_WEN[1], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_WEN[0], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $setup(negedge A_WEN[1], posedge B_CLK &&& DINB_EN_TP, 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, posedge A_WEN[1], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_WEN[0], 0.0, NOTIFY_REG);
    $hold(posedge B_CLK &&& DINB_EN_TP, negedge A_WEN[1], 0.0, NOTIFY_REG);
    
    $recovery(posedge B_ARST_N, posedge B_CLK, 0.0, NOTIFY_REG);
    $hold(posedge B_CLK, posedge B_ARST_N, 0.0, NOTIFY_REG);
    
    $recovery(posedge B_DOUT_ARST_N, posedge B_DOUT_CLK, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK, posedge B_DOUT_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_DOUT_SRST_N, posedge B_DOUT_CLK &&& DOUTB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_DOUT_SRST_N, posedge B_DOUT_CLK &&& DOUTB_FF_EN_1, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_1, posedge B_DOUT_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_1, negedge B_DOUT_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_DOUT_EN, posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge B_DOUT_EN, posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, posedge B_DOUT_EN, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, negedge B_DOUT_EN, 0.0, NOTIFY_REG);
    
    $width(posedge A_CLK, 0.0, 0, NOTIFY_REG);
    $width(negedge A_CLK, 0.0, 0, NOTIFY_REG);    
    $width(posedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    
    $width(posedge B_CLK, 0.0, 0, NOTIFY_REG);
    $width(negedge B_CLK, 0.0, 0, NOTIFY_REG);    
    $width(posedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    
    $width(negedge A_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(posedge A_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge B_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(posedge B_ARST_N, 0.0, 0, NOTIFY_REG);
    
    $width(negedge A_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(posedge A_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(negedge A_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(posedge A_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(negedge A_BLK[2], 0.0, 0, NOTIFY_REG);
    $width(posedge A_BLK[2], 0.0, 0, NOTIFY_REG);
    
    $width(negedge B_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(posedge B_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(negedge B_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(posedge B_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(negedge B_BLK[2], 0.0, 0, NOTIFY_REG);
    $width(posedge B_BLK[2], 0.0, 0, NOTIFY_REG);
    
    $width(negedge A_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(posedge A_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge B_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(posedge B_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    
    $period( posedge A_DOUT_CLK, 0.0, NOTIFY_REG );
    $period( negedge A_DOUT_CLK, 0.0, NOTIFY_REG );
    $period( posedge B_DOUT_CLK, 0.0, NOTIFY_REG );
    $period( negedge B_DOUT_CLK, 0.0, NOTIFY_REG );
    
    $period( posedge A_CLK, 0.0, NOTIFY_REG );
    $period( negedge A_CLK, 0.0, NOTIFY_REG );
    $period( posedge B_CLK, 0.0, NOTIFY_REG );
    $period( negedge B_CLK, 0.0, NOTIFY_REG );
  endspecify
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults


`timescale 1 ps / 1 ps
module RAM_DLY (input  [17:0] IN,
                output [17:0] OUT);
  
  assign OUT[17:0] = IN[17:0];
  
  specify
    ( IN[0] *> (OUT[0]+:OUT[0]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[1] *> (OUT[1]+:OUT[1]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[2] *> (OUT[2]+:OUT[2]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[3] *> (OUT[3]+:OUT[3]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[4] *> (OUT[4]+:OUT[4]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[5] *> (OUT[5]+:OUT[5]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[6] *> (OUT[6]+:OUT[6]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[7] *> (OUT[7]+:OUT[7]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[8] *> (OUT[8]+:OUT[8]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[9] *> (OUT[9]+:OUT[9]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[10] *> (OUT[10]+:OUT[10]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[11] *> (OUT[11]+:OUT[11]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[12] *> (OUT[12]+:OUT[12]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[13] *> (OUT[13]+:OUT[13]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[14] *> (OUT[14]+:OUT[14]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[15] *> (OUT[15]+:OUT[15]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[16] *> (OUT[16]+:OUT[16]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
    ( IN[17] *> (OUT[17]+:OUT[17]) ) = (50.0:50.0:50.0, 50.0:50.0:50.0);
  endspecify
endmodule

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps
module RAM64x18_IP (A_DOUT,B_DOUT,BUSY,
                    A_ADDR_CLK,A_ADDR_EN,A_ADDR_LAT,A_ADDR_ARST_N,A_ADDR_SRST_N,
                    A_DOUT_CLK,A_DOUT_EN,A_DOUT_LAT,A_DOUT_ARST_N,A_DOUT_SRST_N,
                    A_ADDR,A_WIDTH,A_BLK,A_EN,
                    B_ADDR_CLK,B_ADDR_EN,B_ADDR_LAT,B_ADDR_ARST_N,B_ADDR_SRST_N,
                    B_DOUT_CLK,B_DOUT_EN,B_DOUT_LAT,B_DOUT_ARST_N,B_DOUT_SRST_N,
                    B_ADDR,B_WIDTH,B_BLK,B_EN,
                    C_CLK,C_ADDR,C_DIN,C_WEN,C_BLK,C_WIDTH,C_EN, C_ARST_N,
                    SII_LOCK);
            
  parameter TC2CRWH = 0;
  parameter TC2CWRH = 1;

  output [17:0] A_DOUT;
  output [17:0] B_DOUT;
  output        BUSY;
  
  input         A_ADDR_CLK, A_ADDR_EN, A_ADDR_LAT, A_ADDR_ARST_N, A_ADDR_SRST_N;
  input         A_DOUT_CLK, A_DOUT_EN, A_DOUT_LAT, A_DOUT_ARST_N, A_DOUT_SRST_N;
  input         A_EN;
  input  [1:0]  A_BLK;
  input  [9:0]  A_ADDR;
  input  [2:0]  A_WIDTH;
  
  input         B_ADDR_CLK, B_ADDR_EN, B_ADDR_LAT, B_ADDR_ARST_N, B_ADDR_SRST_N;
  input         B_DOUT_CLK, B_DOUT_EN, B_DOUT_LAT, B_DOUT_ARST_N, B_DOUT_SRST_N;
  input         B_EN;
  input  [1:0]  B_BLK;
  input  [9:0]  B_ADDR;
  input  [2:0]  B_WIDTH;
  
  input         C_CLK, C_WEN, C_ARST_N;
  input         C_EN;
  input  [1:0]  C_BLK;
  input  [9:0]  C_ADDR;
  input  [17:0] C_DIN;  
  input  [2:0]  C_WIDTH;
  
  input         SII_LOCK;
  
  reg [17:0] MEM_64_18 [0:63];
  
  parameter MEMORYFILE = "";
  parameter WARNING_MSGS_ON = 1;  // Used to turn off warnings about read &
                                  // write to same address at same time.
                                  // Default = on.  Set to 0 to turn them off.
  parameter NO_COLLISION = 0;     // Used to turn off collision detection.
                                  // Default = off.  Set to 1 to turn them on.

  reg NOTIFY_REG;
  
  wire [9:0]  A_ADDR_lat;
  wire [9:0]  B_ADDR_lat;
  reg  [9:0]  C_ADDR_lat;
  wire        A_BLK_lat, B_BLK_lat;
  reg         C_BLK_lat;
  reg         C_WEN_lat;
  reg  [17:0] C_DIN_lat;
  wire [17:0] A_DOUTP;
  wire [17:0] B_DOUTP;
  wire  [17:0] A_DOUT_stg;
  wire  [17:0] B_DOUT_stg;
  
  wire         A_ADDR_CLK_int, A_ADDR_EN_int, A_ADDR_LAT_int, A_ADDR_ARST_N_int, A_ADDR_SRST_N_int, A_BLK_int;
  wire         A_DOUT_CLK_int, A_DOUT_EN_int, A_DOUT_LAT_int, A_DOUT_ARST_N_int, A_DOUT_SRST_N_int;
  wire  [9:0]  A_ADDR_int;
  wire  [2:0]  A_WIDTH_int;
  wire         B_ADDR_CLK_int, B_ADDR_EN_int, B_ADDR_LAT_int, B_ADDR_ARST_N_int, B_ADDR_SRST_N_int, B_BLK_int;
  wire         B_DOUT_CLK_int, B_DOUT_EN_int, B_DOUT_LAT_int, B_DOUT_ARST_N_int, B_DOUT_SRST_N_int;
  wire  [9:0]  B_ADDR_int;
  wire  [2:0]  B_WIDTH_int;
  wire         C_CLK_int, C_WEN_int, C_ARST_N_int, C_BLK_int;
  wire  [9:0]  C_ADDR_int;
  wire  [17:0] C_DIN_int;
  wire  [2:0]  C_WIDTH_int;
  
  wire A_RST, B_RST, C_RST;
  
  time A_CLK_re, B_CLK_re, C_CLK_re;
  
  //wire C_ARST_N;
  //assign C_ARST_N = 1'b1;
  
  // For handling collisions
  integer A_Addr_Overlap_L, A_Addr_Overlap_H;
  integer B_Addr_Overlap_L, B_Addr_Overlap_H;
  integer j;
  reg Same_Addr;
  wire [17:0] Mask;
  
  wire [17:0] A_DOUT_comb, B_DOUT_comb;
  wire [17:0] collision_a, collision_b;
  
  pmos p0 (A_DOUT[0], A_DOUTP[0], 0);
  pmos p1 (A_DOUT[1], A_DOUTP[1], 0);
  pmos p2 (A_DOUT[2], A_DOUTP[2], 0);
  pmos p3 (A_DOUT[3], A_DOUTP[3], 0);
  pmos p4 (A_DOUT[4], A_DOUTP[4], 0);
  pmos p5 (A_DOUT[5], A_DOUTP[5], 0);
  pmos p6 (A_DOUT[6], A_DOUTP[6], 0);
  pmos p7 (A_DOUT[7], A_DOUTP[7], 0);
  pmos p8 (A_DOUT[8], A_DOUTP[8], 0);
  pmos p9 (A_DOUT[9], A_DOUTP[9], 0);
  pmos p10 (A_DOUT[10], A_DOUTP[10], 0);
  pmos p11 (A_DOUT[11], A_DOUTP[11], 0);
  pmos p12 (A_DOUT[12], A_DOUTP[12], 0);
  pmos p13 (A_DOUT[13], A_DOUTP[13], 0);
  pmos p14 (A_DOUT[14], A_DOUTP[14], 0);
  pmos p15 (A_DOUT[15], A_DOUTP[15], 0);
  pmos p16 (A_DOUT[16], A_DOUTP[16], 0);
  pmos p17 (A_DOUT[17], A_DOUTP[17], 0);
  pmos p18 (B_DOUT[0], B_DOUTP[0], 0);
  pmos p19 (B_DOUT[1], B_DOUTP[1], 0);
  pmos p20 (B_DOUT[2], B_DOUTP[2], 0);
  pmos p21 (B_DOUT[3], B_DOUTP[3], 0);
  pmos p22 (B_DOUT[4], B_DOUTP[4], 0);
  pmos p23 (B_DOUT[5], B_DOUTP[5], 0);
  pmos p24 (B_DOUT[6], B_DOUTP[6], 0);
  pmos p25 (B_DOUT[7], B_DOUTP[7], 0);
  pmos p26 (B_DOUT[8], B_DOUTP[8], 0);
  pmos p27 (B_DOUT[9], B_DOUTP[9], 0);
  pmos p28 (B_DOUT[10], B_DOUTP[10], 0);
  pmos p29 (B_DOUT[11], B_DOUTP[11], 0);
  pmos p30 (B_DOUT[12], B_DOUTP[12], 0);
  pmos p31 (B_DOUT[13], B_DOUTP[13], 0);
  pmos p32 (B_DOUT[14], B_DOUTP[14], 0);
  pmos p33 (B_DOUT[15], B_DOUTP[15], 0);
  pmos p34 (B_DOUT[16], B_DOUTP[16], 0);
  pmos p35 (B_DOUT[17], B_DOUTP[17], 0);
  
  and b36 (A_ADDR_CLK_int, A_EN, A_ADDR_CLK);
  buf b37 (A_ADDR_EN_int, A_ADDR_EN);
  buf b38 (A_ADDR_LAT_int, A_ADDR_LAT);
  buf b39 (A_ADDR_ARST_N_int, A_ADDR_ARST_N);
  buf b40 (A_ADDR_SRST_N_int, A_ADDR_SRST_N);
  and b41 (A_DOUT_CLK_int, A_EN, A_DOUT_CLK);
  buf b42 (A_DOUT_EN_int, A_DOUT_EN);
  buf b43 (A_DOUT_LAT_int, A_DOUT_LAT);
  buf b44 (A_DOUT_ARST_N_int, A_DOUT_ARST_N);
  buf b45 (A_DOUT_SRST_N_int, A_DOUT_SRST_N);
  buf b46 (A_ADDR_int[0], A_ADDR[0]);
  buf b47 (A_ADDR_int[1], A_ADDR[1]);
  buf b48 (A_ADDR_int[2], A_ADDR[2]);
  buf b49 (A_ADDR_int[3], A_ADDR[3]);
  buf b50 (A_ADDR_int[4], A_ADDR[4]);
  buf b51 (A_ADDR_int[5], A_ADDR[5]);
  buf b52 (A_ADDR_int[6], A_ADDR[6]);
  buf b53 (A_ADDR_int[7], A_ADDR[7]);
  buf b54 (A_ADDR_int[8], A_ADDR[8]);
  buf b55 (A_ADDR_int[9], A_ADDR[9]);
  buf b56 (A_WIDTH_int[0], A_WIDTH[0]);
  buf b57 (A_WIDTH_int[1], A_WIDTH[1]);
  buf b58 (A_WIDTH_int[2], A_WIDTH[2]);
  //buf b59 (A_BLK_int, A_BLK);
  and b61 (B_ADDR_CLK_int, B_EN, B_ADDR_CLK);
  buf b62 (B_ADDR_EN_int, B_ADDR_EN);
  buf b63 (B_ADDR_LAT_int, B_ADDR_LAT);
  buf b64 (B_ADDR_ARST_N_int, B_ADDR_ARST_N);
  buf b65 (B_ADDR_SRST_N_int, B_ADDR_SRST_N);
  and b66 (B_DOUT_CLK_int, B_EN, B_DOUT_CLK);
  buf b67 (B_DOUT_EN_int, B_DOUT_EN);
  buf b68 (B_DOUT_LAT_int, B_DOUT_LAT);
  buf b69 (B_DOUT_ARST_N_int, B_DOUT_ARST_N);
  buf b70 (B_DOUT_SRST_N_int, B_DOUT_SRST_N);
  buf b71 (B_ADDR_int[0], B_ADDR[0]);
  buf b72 (B_ADDR_int[1], B_ADDR[1]);
  buf b73 (B_ADDR_int[2], B_ADDR[2]);
  buf b74 (B_ADDR_int[3], B_ADDR[3]);
  buf b75 (B_ADDR_int[4], B_ADDR[4]);
  buf b76 (B_ADDR_int[5], B_ADDR[5]);
  buf b77 (B_ADDR_int[6], B_ADDR[6]);
  buf b78 (B_ADDR_int[7], B_ADDR[7]);
  buf b79 (B_ADDR_int[8], B_ADDR[8]);
  buf b80 (B_ADDR_int[9], B_ADDR[9]);
  buf b81 (B_WIDTH_int[0], B_WIDTH[0]);
  buf b82 (B_WIDTH_int[1], B_WIDTH[1]);
  buf b83 (B_WIDTH_int[2], B_WIDTH[2]);
  //buf b84 (B_BLK_int, B_BLK);
  and b86 (C_CLK_int, C_EN, C_CLK);
  buf b87 (C_WEN_int, C_WEN);
  buf b88 (C_ARST_N_int, C_ARST_N);
  buf b89 (C_ADDR_int[0], C_ADDR[0]);
  buf b90 (C_ADDR_int[1], C_ADDR[1]);
  buf b91 (C_ADDR_int[2], C_ADDR[2]);
  buf b92 (C_ADDR_int[3], C_ADDR[3]);
  buf b93 (C_ADDR_int[4], C_ADDR[4]);
  buf b94 (C_ADDR_int[5], C_ADDR[5]);
  buf b95 (C_ADDR_int[6], C_ADDR[6]);
  buf b96 (C_ADDR_int[7], C_ADDR[7]);
  buf b97 (C_ADDR_int[8], C_ADDR[8]);
  buf b98 (C_ADDR_int[9], C_ADDR[9]);
  buf b99 (C_DIN_int[0], C_DIN[0]);
  buf b100 (C_DIN_int[1], C_DIN[1]);
  buf b101 (C_DIN_int[2], C_DIN[2]);
  buf b102 (C_DIN_int[3], C_DIN[3]);
  buf b103 (C_DIN_int[4], C_DIN[4]);
  buf b104 (C_DIN_int[5], C_DIN[5]);
  buf b105 (C_DIN_int[6], C_DIN[6]);
  buf b106 (C_DIN_int[7], C_DIN[7]);
  buf b107 (C_DIN_int[8], C_DIN[8]);
  buf b108 (C_DIN_int[9], C_DIN[9]);
  buf b109 (C_DIN_int[10], C_DIN[10]);
  buf b110 (C_DIN_int[11], C_DIN[11]);
  buf b111 (C_DIN_int[12], C_DIN[12]);
  buf b112 (C_DIN_int[13], C_DIN[13]);
  buf b113 (C_DIN_int[14], C_DIN[14]);
  buf b114 (C_DIN_int[15], C_DIN[15]);
  buf b115 (C_DIN_int[16], C_DIN[16]);
  buf b116 (C_DIN_int[17], C_DIN[17]);
  //buf b117 (C_BLK_int, C_BLK);
  buf b119 (C_WIDTH_int[0], C_WIDTH[0]);
  buf b120 (C_WIDTH_int[1], C_WIDTH[1]);
  buf b121 (C_WIDTH_int[2], C_WIDTH[2]);
  
  assign A_BLK_int = A_BLK[1] && A_BLK[0];
  assign B_BLK_int = B_BLK[1] && B_BLK[0];
  assign C_BLK_int = C_BLK[1] && C_BLK[0];
  
  assign A_RST = A_ADDR_ARST_N_int && A_BLK_lat;
  assign B_RST = B_ADDR_ARST_N_int && B_BLK_lat;
  assign C_RST = C_ARST_N_int && C_BLK_lat;

  wire [17:0]   A_DOUT_stg_dly, A_DOUT_stg_1;
  wire [17:0]   B_DOUT_stg_dly, B_DOUT_stg_1;
  RAM_DLY u_ADLY(.IN(A_DOUT_stg), .OUT(A_DOUT_stg_dly));
  RAM_DLY u_BDLY(.IN(B_DOUT_stg), .OUT(B_DOUT_stg_dly));
    
  assign A_DOUT_stg_1[17:0] = (A_DOUT_LAT === 1'b1) ? A_DOUT_stg[17:0] : A_DOUT_stg_dly[17:0];
  assign B_DOUT_stg_1[17:0] = (B_DOUT_LAT === 1'b1) ? B_DOUT_stg[17:0] : B_DOUT_stg_dly[17:0];
  
  genvar i;
  generate
    // Level 2 latch implementation for Port A
    for(i=0; i<10; i=i+1) begin : L2A
      SLE_Prim uaddra (.Q(A_ADDR_lat[i]), .ADn(1'b1), .ALn(A_ADDR_ARST_N_int), .CLK(A_ADDR_CLK_int), .D(A_ADDR_int[i]),
                  .LAT(A_ADDR_LAT), .SD(1'b0), .EN(A_ADDR_EN_int), .SLn(A_ADDR_SRST_N_int));
    end
    
    SLE_Prim ublka (.Q(A_BLK_lat), .ADn(1'b1), .ALn(A_ADDR_ARST_N_int), .CLK(A_ADDR_CLK_int), .D(A_BLK_int),
                .LAT(A_ADDR_LAT), .SD(1'b0), .EN(A_ADDR_EN_int), .SLn(A_ADDR_SRST_N_int));
  endgenerate
  
  generate
    // Level 2 latch implementation for Port B
    for(i=0; i<10; i=i+1) begin : L2B
      SLE_Prim uaddrb (.Q(B_ADDR_lat[i]), .ADn(1'b1), .ALn(B_ADDR_ARST_N_int), .CLK(B_ADDR_CLK_int), .D(B_ADDR_int[i]),
                  .LAT(B_ADDR_LAT), .SD(1'b0), .EN(B_ADDR_EN_int), .SLn(B_ADDR_SRST_N_int));
    end
    SLE_Prim ublkb (.Q(B_BLK_lat), .ADn(1'b1), .ALn(B_ADDR_ARST_N_int), .CLK(B_ADDR_CLK_int), .D(B_BLK_int),
                .LAT(B_ADDR_LAT), .SD(1'b0), .EN(B_ADDR_EN_int), .SLn(B_ADDR_SRST_N_int));
  endgenerate
    
  generate
    // Pipeline register latch implementation for Port A
    for(i=0; i<18; i=i+1) begin : PIPEA
      SLE_Prim upipea (.Q(A_DOUTP[i]), .ADn(1'b1), .ALn(A_DOUT_ARST_N_int), .CLK(A_DOUT_CLK_int), .D(A_DOUT_stg_1[i]),
                  .LAT(A_DOUT_LAT), .SD(1'b0), .EN(A_DOUT_EN_int), .SLn(A_DOUT_SRST_N_int));
    end
  endgenerate
  
  generate
    // Pipeline register latch implementation for Port B    
    for(i=0; i<18; i=i+1) begin : PIPEB
      SLE_Prim upipeb (.Q(B_DOUTP[i]), .ADn(1'b1), .ALn(B_DOUT_ARST_N_int), .CLK(B_DOUT_CLK_int), .D(B_DOUT_stg_1[i]),
                  .LAT(B_DOUT_LAT), .SD(1'b0), .EN(B_DOUT_EN_int), .SLn(B_DOUT_SRST_N_int));
    end
  endgenerate
  
  initial begin
    if ( WARNING_MSGS_ON == 0 )
      $display("Note: URAM warnings are disabled. Set WARNING_MSGS_ON = 1 to enable warnings.");
    
    if ( MEMORYFILE != "")
      $readmemb ( MEMORYFILE, MEM_64_18 );
  end
  
  // Issue warnings if any of the clocks goes unknown
  always @(A_ADDR_CLK_int === 1'bx ) begin
    if ( ($time > 0) && (A_RST === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : A_ADDR_CLK input went unknown at time %0.1fps. Instance: %m",$realtime);
    end
  end
  always @(B_ADDR_CLK_int === 1'bx ) begin
    if ( ($time > 0) && (B_RST === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : B_ADDR_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
    end
  end
  always @(C_CLK_int === 1'bx ) begin
    if ( ($time > 0) && (C_RST === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : C_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
    end
  end
  
  // Warnings for the DOUTCLKs
  always @( A_DOUT_CLK_int ) begin
    if ( A_DOUT_CLK_int === 1'bx ) begin
      // A_DOUT_CLK went unknown
      if (($time > 0) && (A_DOUT_ARST_N_int === 1'b1) && (A_DOUT_EN_int === 1'b1) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning : A_DOUT_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
      end
    end
    else if( (A_DOUT_CLK_int !== 1'b1) && (A_DOUT_LAT === 1'b1) ) begin
      // DOUTCLK should always be high in feedthrough mode
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: A_DOUT_CLK is not high in feedthrough mode at time %0.1fps! Instance: %m", $realtime);
    end
  end
  always @(B_DOUT_CLK_int) begin
    if ( B_DOUT_CLK_int === 1'bx ) begin
      // B_DOUT_CLK went unknown
      if ( ($time > 0) && (B_DOUT_ARST_N_int === 1'b1) && (B_DOUT_EN_int === 1'b1) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning : B_DOUT_CLK went unknown at time %0.1fps. Instance: %m",$realtime);
      end
    end
    else if( (B_DOUT_CLK_int !== 1'b1) && (B_DOUT_LAT === 1'b1) ) begin
      // DOUTCLK should always be high in feedthrough mode
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: B_DOUT_CLK is not high in feedthrough mode at time %0.1fps! Instance: %m", $realtime);
    end
  end
  
  //Block selects operation : clear the outputs of the RAM block
  always @( A_BLK_lat ) begin
    if ( A_BLK_lat === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display("Warning : A_BLK went unknown at time %0.1fps. Instance: %m", $realtime);
    end
  end
  always @( B_BLK_lat ) begin
    if ( B_BLK_lat === 1'bx ) begin
      if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
        $display("Warning : B_BLK went unknown at time %0.1fps. Instance: %m", $realtime);
    end
  end
  
  // Asynchronous reset for the input L2 registers
  always @( A_ADDR_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_ADDR_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_ADDR_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_ADDR_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( C_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: C_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
  // L2 latch warnings at port A
  always @( A_ADDR_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_ADDR_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_ADDR_LAT === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_ADDR_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_ADDR_EN_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_ADDR_EN went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_ADDR_SRST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_ADDR_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
  // L2 latch warnings at port B
  always @( B_ADDR_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_ADDR_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_ADDR_LAT === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_ADDR_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_ADDR_EN_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_ADDR_EN went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_ADDR_SRST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_ADDR_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
  // Pipeline warnings at port A
  always @( A_DOUT_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_DOUT_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_DOUT_LAT === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_DOUT_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_DOUT_EN_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_DOUT_EN went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( A_DOUT_SRST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: A_DOUT_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
  // Pipeline warnings at port B
  always @( B_DOUT_ARST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_DOUT_ARST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_DOUT_LAT === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_DOUT_LAT went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_DOUT_EN_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_DOUT_EN went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  always @( B_DOUT_SRST_N_int === 1'bx ) begin
    if ( ($time > 0) && (WARNING_MSGS_ON == 1) )
      $display(" Warning: B_DOUT_SRST_N went unknown at time %0.1fps! Instance: %m", $realtime);
  end
  
      
  
  assign A_DOUT_comb[17:0] = read_data(MEM_64_18[ A_ADDR_lat[9:4] ][17:0], A_ADDR_lat[3:0], A_WIDTH_int[2:0], A_BLK_lat);
                    
  // Collision Detection on port A
  assign clkAC_overlap = ( (C_CLK_re + TC2CWRH) >= A_CLK_re );  
  assign collision_a[17:0] = collision( A_ADDR_lat, C_ADDR_lat, A_WIDTH_int, C_WIDTH_int) & {18{clkAC_overlap}} & {18{!NO_COLLISION}};
  always @( collision_a ) begin
    if ( (|collision_a) & C_WEN_lat ) begin
      // Collision, write from port C at the same address. Read operation will be unknown while the write will be successful
      if ( (WARNING_MSGS_ON == 1) && (NO_COLLISION == 0) ) begin
        $display (" ** Warning: Port C Write to and Port A Read from the same address at the same time. Read data from conflicting address is unknown."); 
        $display ("    Time: %0.1fps! Instance: %m ", $realtime );
      end
    end
  end
  
  assign A_DOUT_stg[17:0] = { (collision_a[17] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 17 ],
                              (collision_a[16] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 16 ],
                              (collision_a[15] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 15 ],
                              (collision_a[14] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 14 ],
                              (collision_a[13] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 13 ],
                              (collision_a[12] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 12 ],
                              (collision_a[11] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 11 ],
                              (collision_a[10] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 10 ],
                              (collision_a[9] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 9 ],
                              (collision_a[8] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 8 ],
                              (collision_a[7] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 7 ],
                              (collision_a[6] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 6 ],
                              (collision_a[5] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 5 ],
                              (collision_a[4] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 4 ],
                              (collision_a[3] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 3 ],
                              (collision_a[2] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 2 ],
                              (collision_a[1] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 1 ],
                              (collision_a[0] & C_WEN_lat) ? 1'bx : A_DOUT_comb[ 0 ]};
  
  always @(posedge A_ADDR_CLK) begin
    A_CLK_re = $time;
  end
  
  always @(posedge C_CLK_int) begin
    if( (C_BLK_int === 1'b1) && (C_ARST_N === 1'b1) ) begin
      C_CLK_re = $time;
      if ( (A_ADDR_LAT === 1'b1) && (A_ADDR_CLK === 1'b1) ) begin
        A_CLK_re = $time;
        #(TC2CWRH+1);
        A_CLK_re = $time;
      end
      
      if ( (B_ADDR_LAT === 1'b1) && (B_ADDR_CLK === 1'b1) ) begin
        B_CLK_re = $time;
        #(TC2CWRH+1);
        B_CLK_re = $time;
      end
    end
  end  
                
  always @( A_ADDR_CLK or A_ADDR_lat or A_BLK_lat ) begin
    if ( ((^A_ADDR_lat) === 1'bx) && (A_BLK_lat === 1'b1) && (A_ADDR_CLK === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1fps! Instance: %m", $realtime);
    end
  end
  
  assign B_DOUT_comb[17:0] = read_data(MEM_64_18[ B_ADDR_lat[9:4] ][17:0], B_ADDR_lat[3:0], B_WIDTH_int[2:0], B_BLK_lat);
                    
  // Collision Detection on port B
  assign clkBC_overlap = ( (C_CLK_re + TC2CWRH) >= B_CLK_re );  
  assign collision_b[17:0] = collision( B_ADDR_lat, C_ADDR_lat, B_WIDTH_int, C_WIDTH_int) & {18{clkBC_overlap}} & {18{!NO_COLLISION}};
  always @( collision_b ) begin
    if ( |collision_b  & C_WEN_lat ) begin
      // Collision, write from port C at the same address. Read operation will be unknown while the write will be successful
      if ( (WARNING_MSGS_ON == 1) && (NO_COLLISION == 0) ) begin
        $display (" ** Warning: Port C Write to and Port B Read from the same address at the same time. Read data from conflicting address is unknown."); 
        $display ("    Time: %0.1fps! Instance: %m ", $realtime );
      end
    end
  end
  
  assign B_DOUT_stg[17:0] = { (collision_b[17] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 17 ],
                              (collision_b[16] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 16 ],
                              (collision_b[15] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 15 ],
                              (collision_b[14] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 14 ],
                              (collision_b[13] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 13 ],
                              (collision_b[12] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 12 ],
                              (collision_b[11] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 11 ],
                              (collision_b[10] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 10 ],
                              (collision_b[9] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 9 ],
                              (collision_b[8] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 8 ],
                              (collision_b[7] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 7 ],
                              (collision_b[6] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 6 ],
                              (collision_b[5] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 5 ],
                              (collision_b[4] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 4 ],
                              (collision_b[3] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 3 ],
                              (collision_b[2] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 2 ],
                              (collision_b[1] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 1 ],
                              (collision_b[0] & C_WEN_lat) ? 1'bx : B_DOUT_comb[ 0 ]};
  
  always @(posedge B_ADDR_CLK) begin
    B_CLK_re = $time;
  end
  
  always @( B_ADDR_CLK or B_ADDR_lat or B_BLK_lat ) begin
    if ( ((^B_ADDR_lat) === 1'bx) && (B_BLK_lat === 1'b1) && (B_ADDR_CLK === 1'b1) ) begin
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1fps! Instance: %m", $realtime);
    end
  end
  
  always @( C_ARST_N ) begin
    if( C_ARST_N === 1'b0 ) begin
      C_ADDR_lat = 0;
      C_DIN_lat  = 0;
      C_BLK_lat  = 0;
      C_WEN_lat   = 0;
    end
  end
  
  always @(posedge C_CLK_int) begin
    if( (C_BLK_int === 1'b1) && (C_ARST_N === 1'b1) ) begin
      //C_CLK_re = $time;
      
      C_ADDR_lat = C_ADDR_int;
      C_DIN_lat  = C_DIN_int;
      C_BLK_lat  = C_BLK_int;
      C_WEN_lat   = C_WEN_int;
      if( C_WEN_int === 1'b1 ) begin
      
        //write mode
        if ((^C_ADDR_lat) === 1'bx) begin
          if ( WARNING_MSGS_ON == 1 )
            $display(" Warning: Illegal address on port C at time %0.1fps! Instance: %m", $realtime);
        end
        else begin
          case ( C_WIDTH_int )
            3'b000 : begin
              MEM_64_18[ C_ADDR_lat[9:4] ] [ C_ADDR_lat[2:0] + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[0];
            end
            3'b001 : begin
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2:1] * 2) + 0 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[0];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2:1] * 2) + 1 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[1];
            end
            3'b010 : begin
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2] * 4) + 0 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[0];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2] * 4) + 1 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[1];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2] * 4) + 2 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[2];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[2] * 4) + 3 + (9 * C_ADDR_lat[3]) ] = C_DIN_lat[3];
            end
            3'b011 : begin
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 0 ] = C_DIN_lat[0];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 1 ] = C_DIN_lat[1];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 2 ] = C_DIN_lat[2];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 3 ] = C_DIN_lat[3];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 4 ] = C_DIN_lat[4];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 5 ] = C_DIN_lat[5];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 6 ] = C_DIN_lat[6];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 7 ] = C_DIN_lat[7];
              MEM_64_18[ C_ADDR_lat[9:4] ] [ (C_ADDR_lat[3] * 9) + 8 ] = C_DIN_lat[8];
            end
            3'b100,3'b101, 3'b110, 3'b111 : begin
              MEM_64_18[ C_ADDR_lat[9:4] ] = C_DIN_lat;
            end
            default : begin
              if ( WARNING_MSGS_ON == 1 )
              $display ("Warning: invalid WIDTH configuration on Port C at time %0.1fps! Legal Width: 1,2,4,9,18. Instance: %m", $realtime);
            end
          endcase
        end
      end
    end
  end
  
  
  function [17:0] collision;
    input [9:0] R_ADDR;
    input [9:0] W_ADDR;
    input [2:0] R_WIDTH;
    input [2:0] W_WIDTH;

    reg         addr_overlap_0, addr_overlap_1, addr_overlap;
    reg [17:0]  collision_0, collision_1;
    
    begin
      if ( R_ADDR[9:4] === W_ADDR[9:4] ) begin
        case ( R_WIDTH )
          3'b000 : addr_overlap_0 = ( (R_ADDR[3:0] === W_ADDR[3:0]) ? 1'b1 : 1'b0 );
          3'b001 : addr_overlap_0 = ( (R_ADDR[3:1] === W_ADDR[3:1]) ? 1'b1 : 1'b0 );
          3'b010 : addr_overlap_0 = ( (R_ADDR[3:2] === W_ADDR[3:2]) ? 1'b1 : 1'b0 );
          3'b011 : addr_overlap_0 = ( (R_ADDR[ 3 ] === W_ADDR[ 3 ]) ? 1'b1 : 1'b0 );
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   addr_overlap_0 = 1'b1;
          default : addr_overlap_0 = 1'b0;
        endcase
        
        case ( W_WIDTH )
          3'b001 : addr_overlap_1 = ( (R_ADDR[3:1] === W_ADDR[3:1]) ? 1'b1 : 1'b0 );
          3'b010 : addr_overlap_1 = ( (R_ADDR[3:2] === W_ADDR[3:2]) ? 1'b1 : 1'b0 );
          3'b011 : addr_overlap_1 = ( (R_ADDR[ 3 ] === W_ADDR[ 3 ]) ? 1'b1 : 1'b0 );
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   addr_overlap_1 = 1'b1;
          default : addr_overlap_1 = 1'b0;
        endcase
        
        addr_overlap = ( (R_WIDTH === W_WIDTH) || (R_WIDTH[2] & W_WIDTH[2] === 1'b1) ) ? addr_overlap_0 :
                       ( ( R_WIDTH > W_WIDTH ) ? addr_overlap_0 :
                       ( ( R_WIDTH < W_WIDTH ) ? addr_overlap_1 : 1'b0 ) );
                  
        case ( R_WIDTH )
          3'b000 : collision_0 = 18'h1;
          3'b001 : collision_0 = 18'h3;
          3'b010 : collision_0 = 18'hF;
          3'b011 : collision_0 = 18'h1FF;
          3'b100, 3'b101, 3'b110, 3'b111 : 
                   collision_0 = 18'h3FFFF;
          default : collision_0 = 18'h0;
        endcase
        
        case ( W_WIDTH )
          3'b000 : collision_1 = 2**( W_ADDR[2:0] + (9 * W_ADDR[3]) );
          3'b001 : collision_1 = 2**( (W_ADDR[2:1] * 2) + 1 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2:1] * 2) + 0 + (9 * W_ADDR[3]) );
          3'b010 : collision_1 = 2**( (W_ADDR[2] * 4) + 3 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2] * 4) + 2 + (9 * W_ADDR[3]) ) + 
                                 2**( (W_ADDR[2] * 4) + 1 + (9 * W_ADDR[3]) ) + 2**( (W_ADDR[2] * 4) + 0 + (9 * W_ADDR[3]) );
          3'b011 : collision_1 = 2**( (W_ADDR[3] * 9) + 8 ) + 2**( (W_ADDR[3] * 9) + 7 ) + 2**( (W_ADDR[3] * 9) + 6 ) +
                                 2**( (W_ADDR[3] * 9) + 5 ) + 2**( (W_ADDR[3] * 9) + 4 ) + 2**( (W_ADDR[3] * 9) + 3 ) +
                                 2**( (W_ADDR[3] * 9) + 2 ) + 2**( (W_ADDR[3] * 9) + 1 ) + 2**( (W_ADDR[3] * 9) + 0 );
          default : collision_1 = 18'h0;
        endcase
        
        collision = ( (R_WIDTH === W_WIDTH) || (R_WIDTH[2] & W_WIDTH[2] === 1'b1) ) ? collision_0 & {18{addr_overlap_0}}:
                    ( ( R_WIDTH > W_WIDTH ) ? collision_1 & {18{addr_overlap_1}} :
                    ( ( R_WIDTH < W_WIDTH ) ? collision_0 & {18{addr_overlap_0}} : 18'b0 ) );

      end
      else begin
        addr_overlap = 1'b0;
        addr_overlap_0 = 1'b0;
        addr_overlap_1 = 1'b0;
        collision = 18'b0;
      end
  end
  endfunction
  
  function [17:0] read_data;
    input [17:0]  MEM;
    input [3:0]   ADDR;
    input [2:0]   WIDTH;
    input         BLK;
                
    begin
      if (BLK === 1'b1) begin
        case ( WIDTH )
          3'b000 : read_data[17:0]   = {17'b0, MEM[ ADDR[2:0] + (9 * ADDR[3]) ]};
          3'b001 : read_data[17:0]   = {16'b0, MEM[ (ADDR[2:1] * 2) + (9 * ADDR[3]) +: 2 ]};
          3'b010 : read_data[17:0]   = {14'b0, MEM[ (ADDR[2] * 4) + (9 * ADDR[3]) +: 4 ]};
          3'b011 : read_data[17:0]   = {9'b0,  MEM[ (ADDR[3] * 9) +: 9 ]};
          3'b100, 3'b101, 3'b110, 3'b111 :
                   read_data[17:0]   = MEM[ 17:0 ];
        endcase
      end
      else
        read_data[17:0] = 18'b0;
    end
  endfunction


  // Enables used for timing checks
  wire DINA_FF_EN_1, DINA_FF_EN_2, DINA_FF_EN_3;
  wire DOUTA_FF_EN_1, DOUTA_FF_EN_2, DOUTA_FF_EN_3,DOUTA_FF_EN_4;
  wire DINB_FF_EN_1, DINB_FF_EN_2, DINB_FF_EN_3;
  wire DOUTB_FF_EN_1, DOUTB_FF_EN_2, DOUTB_FF_EN_3,DOUTB_FF_EN_4;
  
  assign DINA_FF_EN_1 = ~A_ADDR_LAT & A_ADDR_ARST_N & A_ADDR_EN & A_ADDR_SRST_N;
  assign DINA_FF_EN_2 = ~A_ADDR_LAT & A_ADDR_ARST_N & A_ADDR_EN;
  assign DINA_FF_EN_3 = ~A_ADDR_LAT & A_ADDR_ARST_N;
  
  assign DOUTA_FF_EN_1 = ~A_DOUT_LAT & A_DOUT_ARST_N & A_DOUT_EN & A_DOUT_SRST_N;
  assign DOUTA_FF_EN_2 = ~A_DOUT_LAT & A_DOUT_ARST_N & A_DOUT_EN;
  assign DOUTA_FF_EN_3 = ~A_DOUT_LAT & A_DOUT_ARST_N;
  assign DOUTA_FF_EN_4 = DOUTA_FF_EN_1 & A_ADDR_LAT & A_ADDR_CLK & A_ADDR_ARST_N & A_ADDR_EN & A_ADDR_SRST_N;
  
  assign DINB_FF_EN_1 = ~B_ADDR_LAT & B_ADDR_ARST_N & B_ADDR_EN & B_ADDR_SRST_N;
  assign DINB_FF_EN_2 = ~B_ADDR_LAT & B_ADDR_ARST_N & B_ADDR_EN;
  assign DINB_FF_EN_3 = ~B_ADDR_LAT & B_ADDR_ARST_N;
  
  assign DOUTB_FF_EN_1 = ~B_DOUT_LAT & B_DOUT_ARST_N & B_DOUT_EN & B_DOUT_SRST_N;
  assign DOUTB_FF_EN_2 = ~B_DOUT_LAT & B_DOUT_ARST_N & B_DOUT_EN;
  assign DOUTB_FF_EN_3 = ~B_DOUT_LAT & B_DOUT_ARST_N;
  assign DOUTB_FF_EN_4 = DOUTB_FF_EN_1 & B_ADDR_LAT & B_ADDR_CLK & B_ADDR_ARST_N & B_ADDR_EN & B_ADDR_SRST_N;
  
  specify
    specparam PATHPULSE$     = (0.001, 0.001);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_CLK *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~A_DOUT_LAT ) ( posedge A_DOUT_CLK *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[0] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[1] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[2] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[3] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[4] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[5] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[6] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[7] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[8] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[0]+:A_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[1]+:A_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[2]+:A_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[3]+:A_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[4]+:A_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[5]+:A_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[6]+:A_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[7]+:A_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[8]+:A_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[9]+:A_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[10]+:A_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[11]+:A_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[12]+:A_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[13]+:A_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[14]+:A_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[15]+:A_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[16]+:A_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( A_ADDR[9] *> (A_DOUT[17]+:A_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	0	] *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_BLK[	1	] *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	0	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_BLK[	1	] *> (A_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    ( negedge A_DOUT_ARST_N *> (A_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge A_DOUT_ARST_N *> (A_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_ARST_N *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_DOUT_SRST_N *> (A_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( posedge A_DOUT_SRST_N *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_DOUT_LAT ) ( negedge A_ADDR_ARST_N *> (A_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_ARST_N *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( negedge A_ADDR_SRST_N *> (A_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	0	]+:A_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	1	]+:A_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	2	]+:A_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	3	]+:A_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	4	]+:A_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	5	]+:A_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	6	]+:A_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	7	]+:A_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	8	]+:A_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	9	]+:A_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	10	]+:A_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	11	]+:A_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	12	]+:A_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	13	]+:A_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	14	]+:A_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	15	]+:A_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	16	]+:A_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( A_ADDR_LAT && A_DOUT_LAT ) ( posedge A_ADDR_SRST_N *> (A_DOUT[	17	]+:A_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( ~B_DOUT_LAT ) ( posedge B_DOUT_CLK *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[0] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[1] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[2] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[3] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[4] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[5] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[6] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[7] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[8] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[0]+:B_DOUT[0]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[1]+:B_DOUT[1]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[2]+:B_DOUT[2]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[3]+:B_DOUT[3]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[4]+:B_DOUT[4]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[5]+:B_DOUT[5]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[6]+:B_DOUT[6]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[7]+:B_DOUT[7]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[8]+:B_DOUT[8]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[9]+:B_DOUT[9]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[10]+:B_DOUT[10]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[11]+:B_DOUT[11]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[12]+:B_DOUT[12]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[13]+:B_DOUT[13]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[14]+:B_DOUT[14]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[15]+:B_DOUT[15]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[16]+:B_DOUT[16]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( B_ADDR[9] *> (B_DOUT[17]+:B_DOUT[17]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	0	] *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_BLK[	1	] *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	0	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_BLK[	1	] *> (B_DOUT[	0	]+:1'b0	) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    ( negedge B_DOUT_ARST_N *> (B_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    ( negedge B_DOUT_ARST_N *> (B_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_ARST_N *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_DOUT_SRST_N *> (B_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( posedge B_DOUT_SRST_N *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_DOUT_LAT ) ( negedge B_ADDR_ARST_N *> (B_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_ARST_N *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	0	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	1	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	2	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	3	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	4	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	5	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	6	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	7	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	8	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	9	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	10	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	11	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	12	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	13	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	14	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	15	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	16	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( negedge B_ADDR_SRST_N *> (B_DOUT[	17	]+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	0	]+:B_DOUT[	0	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	1	]+:B_DOUT[	1	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	2	]+:B_DOUT[	2	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	3	]+:B_DOUT[	3	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	4	]+:B_DOUT[	4	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	5	]+:B_DOUT[	5	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	6	]+:B_DOUT[	6	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	7	]+:B_DOUT[	7	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	8	]+:B_DOUT[	8	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	9	]+:B_DOUT[	9	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	10	]+:B_DOUT[	10	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	11	]+:B_DOUT[	11	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	12	]+:B_DOUT[	12	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	13	]+:B_DOUT[	13	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	14	]+:B_DOUT[	14	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	15	]+:B_DOUT[	15	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	16	]+:B_DOUT[	16	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    if( B_ADDR_LAT && B_DOUT_LAT ) ( posedge B_ADDR_SRST_N *> (B_DOUT[	17	]+:B_DOUT[	17	]) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
    
    $setup(posedge A_ADDR[	0	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	1	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	2	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	3	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	4	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	5	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	6	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	7	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	8	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	9	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);

    $setup(negedge A_ADDR[	0	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	1	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	2	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	3	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	4	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	5	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	6	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	7	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	8	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	9	], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);

    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_ADDR[	9	], 0.0, NOTIFY_REG);

    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_ADDR[	9	], 0.0, NOTIFY_REG);
    
    $setup(posedge A_BLK[0], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge A_BLK[1], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[0], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[1], posedge A_ADDR_CLK &&& DINA_FF_EN_1, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, posedge A_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_1, negedge A_BLK[1], 0.0, NOTIFY_REG);
    
    $recovery(posedge A_ADDR_ARST_N, posedge A_ADDR_CLK &&& ~A_ADDR_LAT, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& ~A_ADDR_LAT, posedge A_ADDR_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_ADDR_SRST_N, posedge A_ADDR_CLK &&& DINA_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR_SRST_N, posedge A_ADDR_CLK &&& DINA_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_2, posedge A_ADDR_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_2, negedge A_ADDR_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_ADDR_EN, posedge A_ADDR_CLK &&& DINA_FF_EN_3, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR_EN, posedge A_ADDR_CLK &&& DINA_FF_EN_3, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_3, posedge A_ADDR_EN, 0.0, NOTIFY_REG);
    $hold(posedge A_ADDR_CLK &&& DINA_FF_EN_3, negedge A_ADDR_EN, 0.0, NOTIFY_REG);
    
    $recovery(posedge A_DOUT_ARST_N, posedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& ~A_DOUT_LAT, posedge A_DOUT_ARST_N, 0.0, NOTIFY_REG);
    $recovery(posedge A_DOUT_ARST_N, negedge A_DOUT_CLK &&& A_DOUT_LAT, 0.0, NOTIFY_REG);
    $hold(negedge A_DOUT_CLK &&& A_DOUT_LAT, posedge A_DOUT_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_DOUT_SRST_N, posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge A_DOUT_SRST_N, posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, posedge A_DOUT_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_2, negedge A_DOUT_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge A_DOUT_EN, posedge A_DOUT_CLK &&& DOUTA_FF_EN_3, 0.0, NOTIFY_REG);
    $setup(negedge A_DOUT_EN, posedge A_DOUT_CLK &&& DOUTA_FF_EN_3, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_3, posedge A_DOUT_EN, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_3, negedge A_DOUT_EN, 0.0, NOTIFY_REG);
    
    $setup(posedge A_ADDR[	0	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	1	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	2	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	3	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	4	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	5	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	6	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	7	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	8	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_ADDR[	9	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);

    $setup(negedge A_ADDR[	0	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	1	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	2	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	3	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	4	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	5	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	6	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	7	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	8	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_ADDR[	9	], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);

    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_ADDR[	9	], 0.0, NOTIFY_REG);

    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_ADDR[	9	], 0.0, NOTIFY_REG);

    $setup(posedge A_BLK[0], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge A_BLK[1], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[0], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge A_BLK[1], posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, posedge A_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge A_DOUT_CLK &&& DOUTA_FF_EN_4, negedge A_BLK[1], 0.0, NOTIFY_REG);

    $setup(posedge B_ADDR[	0	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	1	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	2	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	3	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	4	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	5	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	6	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	7	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	8	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	9	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);

    $setup(negedge B_ADDR[	0	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	1	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	2	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	3	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	4	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	5	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	6	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	7	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	8	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	9	], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);

    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_ADDR[	9	], 0.0, NOTIFY_REG);

    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_ADDR[	9	], 0.0, NOTIFY_REG);
    
    $setup(posedge B_BLK[0], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(posedge B_BLK[1], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[0], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[1], posedge B_ADDR_CLK &&& DINB_FF_EN_1, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, posedge B_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_1, negedge B_BLK[1], 0.0, NOTIFY_REG);
    
    $recovery(posedge B_ADDR_ARST_N, posedge B_ADDR_CLK &&& ~B_ADDR_LAT, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& ~B_ADDR_LAT, posedge B_ADDR_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_ADDR_SRST_N, posedge B_ADDR_CLK &&& DINB_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR_SRST_N, posedge B_ADDR_CLK &&& DINB_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_2, posedge B_ADDR_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_2, negedge B_ADDR_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_ADDR_EN, posedge B_ADDR_CLK &&& DINB_FF_EN_3, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR_EN, posedge B_ADDR_CLK &&& DINB_FF_EN_3, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_3, posedge B_ADDR_EN, 0.0, NOTIFY_REG);
    $hold(posedge B_ADDR_CLK &&& DINB_FF_EN_3, negedge B_ADDR_EN, 0.0, NOTIFY_REG);
    
    $recovery(posedge B_DOUT_ARST_N, posedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& ~B_DOUT_LAT, posedge B_DOUT_ARST_N, 0.0, NOTIFY_REG);
    $recovery(posedge B_DOUT_ARST_N, negedge B_DOUT_CLK &&& B_DOUT_LAT, 0.0, NOTIFY_REG);
    $hold(negedge B_DOUT_CLK &&& B_DOUT_LAT, posedge B_DOUT_ARST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_DOUT_SRST_N, posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, 0.0, NOTIFY_REG);
    $setup(negedge B_DOUT_SRST_N, posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, posedge B_DOUT_SRST_N, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_2, negedge B_DOUT_SRST_N, 0.0, NOTIFY_REG);
    
    $setup(posedge B_DOUT_EN, posedge B_DOUT_CLK &&& DOUTB_FF_EN_3, 0.0, NOTIFY_REG);
    $setup(negedge B_DOUT_EN, posedge B_DOUT_CLK &&& DOUTB_FF_EN_3, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_3, posedge B_DOUT_EN, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_3, negedge B_DOUT_EN, 0.0, NOTIFY_REG);
    
    $setup(posedge B_ADDR[	0	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	1	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	2	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	3	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	4	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	5	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	6	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	7	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	8	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_ADDR[	9	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);

    $setup(negedge B_ADDR[	0	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	1	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	2	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	3	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	4	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	5	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	6	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	7	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	8	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_ADDR[	9	], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);

    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_ADDR[	9	], 0.0, NOTIFY_REG);

    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_ADDR[	9	], 0.0, NOTIFY_REG);

    $setup(posedge B_BLK[0], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(posedge B_BLK[1], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[0], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $setup(negedge B_BLK[1], posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, posedge B_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge B_DOUT_CLK &&& DOUTB_FF_EN_4, negedge B_BLK[1], 0.0, NOTIFY_REG);
    
    $setup(posedge C_ADDR[	0	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	1	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	2	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	3	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	4	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	5	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	6	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	7	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	8	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_ADDR[	9	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);

    $setup(negedge C_ADDR[	0	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	1	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	2	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	3	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	4	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	5	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	6	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	7	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	8	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_ADDR[	9	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);

    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_ADDR[	9	], 0.0, NOTIFY_REG);

    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	0	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	1	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	2	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	3	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	4	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	5	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	6	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	7	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	8	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_ADDR[	9	], 0.0, NOTIFY_REG);
    
    $setup(posedge C_DIN[	0	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	1	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	2	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	3	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	4	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	5	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	6	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	7	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	8	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	9	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	10	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	11	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	12	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	13	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	14	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	15	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	16	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_DIN[	17	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);

    $setup(negedge C_DIN[	0	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	1	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	2	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	3	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	4	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	5	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	6	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	7	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	8	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	9	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	10	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	11	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	12	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	13	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	14	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	15	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	16	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_DIN[	17	], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);

    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_DIN[	17	], 0.0, NOTIFY_REG);

    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	0	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	1	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	2	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	3	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	4	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	5	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	6	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	7	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	8	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	9	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	10	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	11	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	12	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	13	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	14	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	15	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	16	], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_DIN[	17	], 0.0, NOTIFY_REG);

    
    $setup(posedge C_BLK[0], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(posedge C_BLK[1], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_BLK[0], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_BLK[1], posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_BLK[1], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_BLK[0], 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_BLK[1], 0.0, NOTIFY_REG);
    
    $setup(posedge C_WEN, posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $setup(negedge C_WEN, posedge C_CLK &&& C_ARST_N, 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, posedge C_WEN, 0.0, NOTIFY_REG);
    $hold(posedge C_CLK &&& C_ARST_N, negedge C_WEN, 0.0, NOTIFY_REG);
    
    $recovery(negedge C_ARST_N, posedge C_CLK, 0.0, NOTIFY_REG);
    $hold(posedge C_CLK, negedge C_ARST_N, 0.0, NOTIFY_REG);
    
    $width(posedge A_ADDR_CLK &&& ~A_ADDR_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge A_ADDR_CLK &&& ~A_ADDR_LAT, 0.0, 0, NOTIFY_REG);
    $width(posedge B_ADDR_CLK &&& ~B_ADDR_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge B_ADDR_CLK &&& ~B_ADDR_LAT, 0.0, 0, NOTIFY_REG);
    
    $width(posedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    $width(posedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    $width(negedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, 0, NOTIFY_REG);
    
    $width(posedge C_CLK, 0.0, 0, NOTIFY_REG);
    $width(negedge C_CLK, 0.0, 0, NOTIFY_REG);
    
    $width(negedge A_ADDR_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge B_ADDR_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge A_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge B_DOUT_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge C_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(posedge C_ARST_N, 0.0, 0, NOTIFY_REG);
    $width(negedge A_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(negedge A_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(negedge B_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(negedge B_BLK[1], 0.0, 0, NOTIFY_REG);
    $width(negedge C_BLK[0], 0.0, 0, NOTIFY_REG);
    $width(negedge C_BLK[1], 0.0, 0, NOTIFY_REG);
    
    $period(posedge A_ADDR_CLK &&& ~A_ADDR_LAT, 0.0, NOTIFY_REG);
    $period(posedge B_ADDR_CLK &&& ~B_ADDR_LAT, 0.0, NOTIFY_REG);
    $period(posedge A_DOUT_CLK &&& ~A_DOUT_LAT, 0.0, NOTIFY_REG);
    $period(posedge B_DOUT_CLK &&& ~B_DOUT_LAT, 0.0, NOTIFY_REG);
    $period(posedge C_CLK, 0.0, NOTIFY_REG);
  endspecify
  
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 1 ps
module RAM64x18 (A_DOUT,B_DOUT,BUSY,
                 A_ADDR_CLK,A_ADDR_EN,A_ADDR_LAT,A_ADDR_ARST_N,A_ADDR_SRST_N,
                 A_DOUT_CLK,A_DOUT_EN,A_DOUT_LAT,A_DOUT_ARST_N,A_DOUT_SRST_N,
                 A_ADDR,A_WIDTH,A_BLK,A_EN,
                 B_ADDR_CLK,B_ADDR_EN,B_ADDR_LAT,B_ADDR_ARST_N,B_ADDR_SRST_N,
                 B_DOUT_CLK,B_DOUT_EN,B_DOUT_LAT,B_DOUT_ARST_N,B_DOUT_SRST_N,
                 B_ADDR,B_WIDTH,B_BLK,B_EN,
                 C_CLK,C_ADDR,C_DIN,C_WEN,C_BLK,C_WIDTH,C_EN,
                 SII_LOCK);
            
  output [17:0] A_DOUT;
  output [17:0] B_DOUT;
  output        BUSY;
  
  input         A_ADDR_CLK, A_ADDR_EN, A_ADDR_LAT, A_ADDR_ARST_N, A_ADDR_SRST_N;
  input         A_DOUT_CLK, A_DOUT_EN, A_DOUT_LAT, A_DOUT_ARST_N, A_DOUT_SRST_N;
  input         A_EN;
  input  [1:0]  A_BLK;
  input  [9:0]  A_ADDR;
  input  [2:0]  A_WIDTH;
  
  input         B_ADDR_CLK, B_ADDR_EN, B_ADDR_LAT, B_ADDR_ARST_N, B_ADDR_SRST_N;
  input         B_DOUT_CLK, B_DOUT_EN, B_DOUT_LAT, B_DOUT_ARST_N, B_DOUT_SRST_N;
  input         B_EN;
  input  [1:0]  B_BLK;
  input  [9:0]  B_ADDR;
  input  [2:0]  B_WIDTH;
  
  input         C_CLK, C_WEN;
  input         C_EN;
  input  [1:0]  C_BLK;
  input  [9:0]  C_ADDR;
  input  [17:0] C_DIN;  
  input  [2:0]  C_WIDTH;
  
  input         SII_LOCK;
  
  parameter MEMORYFILE = "";
  parameter WARNING_MSGS_ON = 1;  // Used to turn off warnings about read &
                                  // write to same address at same time.
                                  // Default = on.  Set to 0 to turn them off.
  parameter NO_COLLISION = 0;     // Used to turn off collision detection.
                                  // Default = off.  Set to 1 to turn them on.
  
  RAM64x18_IP #(.MEMORYFILE(MEMORYFILE), .WARNING_MSGS_ON(WARNING_MSGS_ON), .NO_COLLISION(NO_COLLISION))
              u0 (.A_DOUT(A_DOUT),.B_DOUT(B_DOUT),.BUSY(BUSY),
                  .A_ADDR_CLK(A_ADDR_CLK),.A_ADDR_EN(A_ADDR_EN),.A_ADDR_LAT(A_ADDR_LAT),
                  .A_ADDR_ARST_N(A_ADDR_ARST_N),.A_ADDR_SRST_N(A_ADDR_SRST_N),
                  .A_DOUT_CLK(A_DOUT_CLK),.A_DOUT_EN(A_DOUT_EN),.A_DOUT_LAT(A_DOUT_LAT),
                  .A_DOUT_ARST_N(A_DOUT_ARST_N),.A_DOUT_SRST_N(A_DOUT_SRST_N),
                  .A_ADDR(A_ADDR),.A_WIDTH(A_WIDTH),.A_BLK(A_BLK),.A_EN(A_EN),
                  .B_ADDR_CLK(B_ADDR_CLK),.B_ADDR_EN(B_ADDR_EN),.B_ADDR_LAT(B_ADDR_LAT),
                  .B_ADDR_ARST_N(B_ADDR_ARST_N),.B_ADDR_SRST_N(B_ADDR_SRST_N),
                  .B_DOUT_CLK(B_DOUT_CLK),.B_DOUT_EN(B_DOUT_EN),.B_DOUT_LAT(B_DOUT_LAT),
                  .B_DOUT_ARST_N(B_DOUT_ARST_N),.B_DOUT_SRST_N(B_DOUT_SRST_N),
                  .B_ADDR(B_ADDR),.B_WIDTH(B_WIDTH),.B_BLK(B_BLK),.B_EN(B_EN),
                  .C_CLK(C_CLK),.C_ADDR(C_ADDR),.C_DIN(C_DIN),.C_WEN(C_WEN),.C_BLK(C_BLK),
                  .C_WIDTH(C_WIDTH),.C_EN(C_EN), .C_ARST_N(1'b1),
                  .SII_LOCK(SII_LOCK));
endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults



module ReadPort(input [17:0]  MEM,
                input [3:0]   ADDR,
                input [2:0]   WIDTH,
                input         BLK,
                output [17:0] DOUT);
                
  wire [17:0] DOUT_W1, DOUT_W2, DOUT_W4, DOUT_W9, DOUT_W18;
  
  assign DOUT_W1[17:0]   = {17'b0, MEM[ ADDR[2:0] + (9 * ADDR[3]) ]};
  assign DOUT_W2[17:0]   = {16'b0, 
                              MEM[ (ADDR[2:1] * 2) + 1 + (9 * ADDR[3]) ],
                              MEM[ (ADDR[2:1] * 2) + 0 + (9 * ADDR[3]) ]};
  assign DOUT_W4[17:0]   = {14'b0, 
                              MEM[ (ADDR[2] * 4) + 3 + (9 * ADDR[3]) ],
                              MEM[ (ADDR[2] * 4) + 2 + (9 * ADDR[3]) ],
                              MEM[ (ADDR[2] * 4) + 1 + (9 * ADDR[3]) ],
                              MEM[ (ADDR[2] * 4) + 0 + (9 * ADDR[3]) ]};
  assign DOUT_W9[17:0]   = {9'b0, 
                              MEM[ (ADDR[3] * 9) + 8 ],
                              MEM[ (ADDR[3] * 9) + 7 ],
                              MEM[ (ADDR[3] * 9) + 6 ],
                              MEM[ (ADDR[3] * 9) + 5 ],
                              MEM[ (ADDR[3] * 9) + 4 ],
                              MEM[ (ADDR[3] * 9) + 3 ],
                              MEM[ (ADDR[3] * 9) + 2 ],
                              MEM[ (ADDR[3] * 9) + 1 ],
                              MEM[ (ADDR[3] * 9) + 0 ]};
  assign DOUT_W18[17:0]  = MEM[ 17:0 ];
  
  assign DOUT[17:0]       = ( BLK === 1'b0 )            ? 18'b0 :
                            ( ( WIDTH[2] === 1'b1 )     ? DOUT_W18 :
                            ( ( WIDTH[2:0] === 3'b011 ) ? DOUT_W9 :
                            ( ( WIDTH[2:0] === 3'b010 ) ? DOUT_W4 :
                            ( ( WIDTH[2:0] === 3'b001 ) ? DOUT_W2 :
                            ( ( WIDTH[2:0] === 3'b000 ) ? DOUT_W1 : 18'hxxxxx ) ) ) ) );
endmodule



/*--------------------------------------------------------------------
 CELL NAME : MACC_COMB
---------------------------------------------------------------------*/
`timescale 1ps/1ps
module MACC_COMB(a_comb_b, b_comb_b, c_comb_b, cdin_comb, fdbk_comb, 
                 sel0_comb_b, sel1_comb_b, 
                 shft_comb_b, sub_comb_b, 
                 carryin_comb_b, 
                 mode0, mode1, mode2, 
                 p_comb_b, ovfl_ext_comb_b, cdout);
  
  input signed [17:0] a_comb_b;
  input signed [17:0] b_comb_b;
  input signed [43:0] c_comb_b;
  input signed [43:0] cdin_comb;
  input signed [43:0] fdbk_comb;
  input sel0_comb_b;
  input sel1_comb_b;
  input shft_comb_b;
  input sub_comb_b;
  input carryin_comb_b;
  input mode0;
  input mode1;
  input mode2;
  output [43:0] p_comb_b;
  output ovfl_ext_comb_b;
  output [43:0] cdout;
  
  wire        sel0_comb, sel1_comb, shft_comb, sub_comb, carryin_comb;
  wire        ovfl_ext_comb;
  
  wire signed [18:0] a_comb;
  wire signed [18:0] b_comb;
  wire signed [43:0] c_comb;
  wire signed [43:0] p_comb;
  wire signed [8:0]  a_lower;
  wire signed [8:0]  a_upper;
  wire signed [8:0]  b_lower;
  wire signed [8:0]  b_upper;
  wire signed [25:0] c_upper;
  wire signed [25:0] d_upper;
  wire signed [1:0]  carryin;
  
  wire signed [43:0] fdbk_out;
  wire signed [43:0] preshft;
  wire signed [43:0] shft;
  wire signed [43:0] d;
  wire signed [44:0] prod;
  wire signed [45:0] sum;
  wire signed [17:0] sum_lower;
  wire signed [27:0] sum_upper;
  
  assign sel0_comb    = ~ sel0_comb_b;
  assign sel1_comb    = ~ sel1_comb_b;
  assign shft_comb    = ~ shft_comb_b & ~mode0;
  assign sub_comb     = ~ sub_comb_b;
  assign carryin_comb = ~ carryin_comb_b;
  
  assign a_comb          = ~ a_comb_b;
  assign b_comb          = ~ b_comb_b;
  assign c_comb          = ~ c_comb_b;
  assign p_comb_b        = ~ p_comb;
  assign ovfl_ext_comb_b = ~ ovfl_ext_comb;
  
  assign carryin = carryin_comb ? 2'b01 : 2'b00;
  assign a_lower = a_comb[8:0];
  assign a_upper = a_comb[17:9];
  assign b_lower = b_comb[8:0];
  assign b_upper = b_comb[17:9];
  assign c_upper = c_comb[43:18];
  assign d_upper = preshft[43:18];
  
  
  assign fdbk_out = sel0_comb ? ( mode0 ? {fdbk_comb[43:18], 18'b0} : fdbk_comb ) : 44'b0;
  assign preshft  = sel1_comb ? ( mode0 ? {cdin_comb[43:18], fdbk_out[17:0] } : cdin_comb ) : fdbk_out;
  assign d        = shft_comb ? shft : preshft;
  
  // Normal Mode
  assign shft = { {17{preshft[43]}}, preshft[43:17] };
  assign prod = mode1 ? ( ( a_lower * b_upper ) + ( a_upper * b_lower ) ) * 512 : ( a_comb * b_comb );
  assign sum  = sub_comb ? ( c_comb + d + carryin - prod ) : ( c_comb + d + carryin + prod );
  
  // SIMD Mode
  assign sum_lower  = ( a_lower * b_lower ) + carryin;
  assign sum_upper  = sub_comb ? ( c_upper + d_upper - ( a_upper * b_upper ) ) : ( c_upper + d_upper + ( a_upper * b_upper ) );
  
  assign ovfl = mode0 ? ( sum_upper[27] ^ sum_upper[26] ) | ( sum_upper[26] ^ sum_upper[25] ) : ( sum[45] ^ sum[44] ) | ( sum[44] ^ sum[43] );
  assign ext  = mode0 ? c_upper[25] ^ d_upper[25] ^ sum_upper[26] : c_comb[43] ^ d[43] ^ sum[44];
  
  // Outputs
  assign #100 p_comb        = mode0 ? { sum_upper[25:0], sum_lower } : sum[43:0];
  assign #100 ovfl_ext_comb = mode2 ? ext : ovfl;
  assign cdout         = fdbk_comb;
endmodule

/*--------------------------------------------------------------------
 CELL NAME : MACC_IP
---------------------------------------------------------------------*/
`timescale 1ps/1ps
module datareg (input   clk,
                input   d,
                input   e,
                input   arst_b,
                input   srst_b,
                input   lat,
                input   pwrdwn_b,
                output  q);
  wire clk_gate;
  assign clk_gate = clk & pwrdwn_b;
  SLE_Prim u0(.Q(q), .ADn(1'b1), .ALn(arst_b), .CLK(clk_gate), .D(d),
              .LAT(lat), .SD(1'b0), .EN(e), .SLn(srst_b));
endmodule

`timescale 1ps/1ps
module cntlreg (input   clk,
                input   d,
                input   e,
                input   al_b,
                input   sl_b,
                input   lat,
                input   ad,
                input   sd_b,
                input   pwrdwn_b,
                output  q);
                
  wire clk_gate, al_b_gate, ad_b, sd;
  assign clk_gate  = clk & pwrdwn_b;
  assign al_b_gate = al_b & pwrdwn_b;
  assign ad_b      = ~ ad;
  assign sd        = ~ sd_b;

  SLE_Prim u0(.Q(q), .ADn(ad_b), .ALn(al_b_gate), .CLK(clk_gate), .D(d),
              .LAT(lat), .SD(sd), .EN(e), .SLn(sl_b));
endmodule

`timescale 1ps/1ps
module MACC_IP_P (// A input
                  input [1:0] clka,
                  input [17:0] a,
                  input [1:0] ea,
                  input [1:0] arsta_b,
                  input [1:0] srsta_b,
                  input [1:0] alat,
                  // B input
                  input [1:0] clkb,
                  input [17:0] b,
                  input [1:0] eb,
                  input [1:0] arstb_b,
                  input [1:0] srstb_b,
                  input [1:0] blat,
                  // C input
                  input [1:0]  clkc,
                  input [43:0] c,
                  input        carryin,
                  input [1:0]  ec,
                  input [1:0]  arstc_b,
                  input [1:0]  srstc_b,
                  input [1:0]  clat,
                  // cdin input
                  input [43:0] cdin,
                  // sub input
                  input       clksub,
                  input       sub,
                  input       esub,
                  input       alsub_b,
                  input       slsub_b,
                  input       sublat,
                  input       subad,
                  input       subsd_b,
                  // shft input
                  input       clkshft,
                  input       shft,
                  input       eshft,
                  input       alshft_b,
                  input       slshft_b,
                  input       shftlat,
                  input       shftad,
                  input       shftsd_b,
                  // sel0 input
                  input       clksel0,
                  input       sel0,
                  input       esel0,
                  input       alsel0_b,
                  input       slsel0_b,
                  input       sel0lat,
                  input       sel0ad,
                  input       sel0sd_b,
                  // sel1 input
                  input       clksel1,
                  input       sel1,
                  input       esel1,
                  input       alsel1_b,
                  input       slsel1_b,
                  input       sel1lat,
                  input       sel1ad,
                  input       sel1sd_b,
                  // p_out controls
                  input [1:0] clkp,
                  input [1:0] ep,
                  input [1:0] arstp_b,
                  input [1:0] srstp_b,
                  input [1:0] plat,
                  // common
                  input mode0,
                  input mode1,
                  input mode2,
                  input pwrdwn_b,

                  output [43:0] p_out,
                  output        ovfl_ext_out,
                  output [43:0] cdout);


  wire [17:0] a_comb;
  wire [17:0] a_comb_b;
  
  wire [17:0] b_comb;
  wire [17:0] b_comb_b;
  
  wire [43:0] c_comb;
  wire [43:0] c_comb_b;
  
  wire [43:0] p_comb;
  wire [43:0] p_comb_b;
  
  wire        carryin_comb;
  wire        carryin_comb_b;

  wire [17:0] a_int;
  wire [1:0]  clka_int;
  wire [1:0]  ea_int;
  wire [1:0]  alat_int;
  wire [1:0]  arsta_b_int;
  wire [1:0]  srsta_b_int;

  wire [17:0] b_int;
  wire [1:0]  clkb_int;
  wire [1:0]  eb_int;
  wire [1:0]  blat_int;
  wire [1:0]  arstb_b_int;
  wire [1:0]  srstb_b_int;
  
  wire [43:0] c_int;
  wire        carryin_int;
  wire [1:0]  clkc_int;
  wire [1:0]  ec_int;
  wire [1:0]  clat_int;
  wire [1:0]  arstc_b_int;
  wire [1:0]  srstc_b_int;
  
  wire [43:0] p_zd;
  wire [43:0] cdout_zd;
  wire [1:0]  clkp_int;
  wire [1:0]  ep_int;
  wire [1:0]  plat_int;
  wire [1:0]  arstp_b_int;
  wire [1:0]  srstp_b_int;
  wire        ovfl_ext_comb;
  wire        ovfl_ext_comb_b;
  wire        ovfl_ext_out_int;
  
  wire [43:0] cdin_comb;
  wire [43:0] fdbk_comb;
  
  wire        sub_int, clksub_int, esub_int, sublat_int, alsub_b_int, subad_int, slsub_b_int, subsd_b_int;
  wire        shft_int, clkshft_int, eshft_int, shftlat_int, alshft_b_int, shftad_int, slshft_b_int, shftsd_b_int;
  wire        sel0_int, clksel0_int, esel0_int, sel0lat_int, alsel0_b_int, sel0ad_int, slsel0_b_int, sel0sd_b_int;
  wire        sel1_int, clksel1_int, esel1_int, sel1lat_int, alsel1_b_int, sel1ad_int, slsel1_b_int, sel1sd_b_int;

  buf u_inbufclksub ( clksub_int, clksub );
  buf u_inbufalsub  ( alsub_b_int, alsub_b );
  buf u_inbufsub    ( sub_int, sub );
  buf u_inbufesub   ( esub_int, esub );
  buf u_inbufsublat ( sublat_int, sublat );
  buf u_inbufsubad  ( subad_int, subad );
  buf u_inbufslsub  ( slsub_b_int, slsub_b );
  buf u_inbufsubsd  ( subsd_b_int, subsd_b );
  
  buf u_inbufclkshft ( clkshft_int, clkshft );
  buf u_inbufalshft  ( alshft_b_int, alshft_b );
  buf u_inbufshft    ( shft_int, shft );
  buf u_inbufeshft   ( eshft_int, eshft );
  buf u_inbufshftlat ( shftlat_int, shftlat );
  buf u_inbufshftad  ( shftad_int, shftad );
  buf u_inbufslshft  ( slshft_b_int, slshft_b );
  buf u_inbufshftsd  ( shftsd_b_int, shftsd_b );
  
  buf u_inbufclksel0 ( clksel0_int, clksel0 );
  buf u_inbufalsel0  ( alsel0_b_int, alsel0_b );
  buf u_inbufsel0    ( sel0_int, sel0 );
  buf u_inbufesel0   ( esel0_int, esel0 );
  buf u_inbufsel0lat ( sel0lat_int, sel0lat );
  buf u_inbufsel0ad  ( sel0ad_int, sel0ad );
  buf u_inbufslsel0  ( slsel0_b_int, slsel0_b );
  buf u_inbufsel0sd  ( sel0sd_b_int, sel0sd_b );
  
  buf u_inbufclksel1 ( clksel1_int, clksel1 );
  buf u_inbufalsel1  ( alsel1_b_int, alsel1_b );
  buf u_inbufsel1    ( sel1_int, sel1 );
  buf u_inbufesel1   ( esel1_int, esel1 );
  buf u_inbufsel1lat ( sel1lat_int, sel1lat );
  buf u_inbufsel1ad  ( sel1ad_int, sel1ad );
  buf u_inbufslsel1  ( slsel1_b_int, slsel1_b );
  buf u_inbufsel1sd  ( sel1sd_b_int, sel1sd_b );
  
  pmos pmos_p     ( ovfl_ext_out, ovfl_ext_out_zd, 0 );
  
  genvar i;
  generate
    // input buffers for a and b
    for(i=0; i<18; i=i+1) begin : INBUF
      buf u_inbufa ( a_int[i], a[i] );
      buf u_inbufb ( b_int[i], b[i] );
    end
    
    // input buffers for c
    for(i=0; i<44; i=i+1) begin : INBUFC
      buf u_inbufc    ( c_int[i], c[i] );
      buf u_inbufcdin ( cdin_comb[i], cdin[i] );
    end
    buf u_inbufcarryin ( carryin_int, carryin );

    // input buffers for control signals
    for(i=0; i<2; i=i+1) begin : REGCTRL
      buf u_inbufclka  ( clka_int[i], clka[i] );
      buf u_inbufarsta ( arsta_b_int[i], arsta_b[i] );
      buf u_inbufalat  ( alat_int[i], alat[i] );
      buf u_inbufea    ( ea_int[i], ea[i] );
      buf u_inbufsrsta ( srsta_b_int[i], srsta_b[i] );

      buf u_inbufclkb  ( clkb_int[i], clkb[i] );
      buf u_inbufarstb ( arstb_b_int[i], arstb_b[i] );
      buf u_inbufblat  ( blat_int[i], blat[i] );
      buf u_inbufeb    ( eb_int[i], eb[i] );
      buf u_inbufsrstb ( srstb_b_int[i], srstb_b[i] );
      
      buf u_inbufclkc  ( clkc_int[i], clkc[i] );
      buf u_inbufarstc ( arstc_b_int[i], arstc_b[i] );
      buf u_inbufclat  ( clat_int[i], clat[i] );
      buf u_inbufec    ( ec_int[i], ec[i] );
      buf u_inbufsrstc ( srstc_b_int[i], srstc_b[i] );
      
      buf u_inbufclkp  ( clkp_int[i], clkp[i] );
      buf u_inbufarstp ( arstp_b_int[i], arstp_b[i] );
      buf u_inbufplat  ( plat_int[i], plat[i] );
      buf u_inbufep    ( ep_int[i], ep[i] );
      buf u_inbufsrstp ( srstp_b_int[i], srstp_b[i] );
    end
    
    for(i=0; i<44; i=i+1) begin : p_buffers
      pmos pmos_p     ( p_out[i], p_zd[i], 0 );
      pmos pmos_cdout ( cdout[i], cdout_zd[i], 0 );
    end
  endgenerate

                
  generate
    // INREG for a[8:0]  and b[8:0]
    for(i=0; i<9; i=i+1) begin : INREG_0
      datareg u_areglsb (.q(a_comb[i]), .arst_b(arsta_b_int[0]), .clk(clka_int[0]), .d(a_int[i]),
                         .lat(alat_int[0]), .e(ea_int[0]), .srst_b(srsta_b_int[0]), .pwrdwn_b(pwrdwn_b));
      datareg u_breglsb (.q(b_comb[i]), .arst_b(arstb_b_int[0]), .clk(clkb_int[0]), .d(b_int[i]),
                         .lat(blat_int[0]), .e(eb_int[0]), .srst_b(srstb_b_int[0]), .pwrdwn_b(pwrdwn_b));
    end

    // INREG for a[17:9] and b[17:9]
    for(i=9; i<18; i=i+1) begin : INREG_1
      datareg u_aregmsb (.q(a_comb[i]), .arst_b(arsta_b_int[1]), .clk(clka_int[1]), .d(a_int[i]),
                         .lat(alat_int[1]), .e(ea_int[1]), .srst_b(srsta_b_int[1]), .pwrdwn_b(pwrdwn_b));
      datareg u_bregmsb (.q(b_comb[i]), .arst_b(arstb_b_int[1]), .clk(clkb_int[1]), .d(b_int[i]),
                         .lat(blat_int[1]), .e(eb_int[1]), .srst_b(srstb_b_int[1]), .pwrdwn_b(pwrdwn_b));
    end
    
    // INREG for c[17:0]  and p[17:0] 
    for(i=0; i<18; i=i+1) begin : INREG_2
      datareg u_creglsb (.q(c_comb[i]), .arst_b(arstc_b_int[0]), .clk(clkc_int[0]), .d(c_int[i]),
                         .lat(clat_int[0]), .e(ec_int[0]), .srst_b(srstc_b_int[0]), .pwrdwn_b(pwrdwn_b));
      datareg u_preglsb (.q(p_zd[i]), .arst_b(arstp_b_int[0]), .clk(clkp_int[0]), .d(p_comb[i]),
                         .lat(plat_int[0]), .e(ep_int[0]), .srst_b(srstp_b_int[0]), .pwrdwn_b(pwrdwn_b));
    end
    
    // INREG for c[43:18]  and p[43:18] 
    for(i=18; i<44; i=i+1) begin : INREG_3
      datareg u_cregmsb (.q(c_comb[i]), .arst_b(arstc_b_int[1]), .clk(clkc_int[1]), .d(c_int[i]),
                         .lat(clat_int[1]), .e(ec_int[1]), .srst_b(srstc_b_int[1]), .pwrdwn_b(pwrdwn_b));
      datareg u_pregmsb (.q(p_zd[i]), .arst_b(arstp_b_int[1]), .clk(clkp_int[1]), .d(p_comb[i]),
                         .lat(plat_int[1]), .e(ep_int[1]), .srst_b(srstp_b_int[1]), .pwrdwn_b(pwrdwn_b));
    end
    
  endgenerate
  
  cntlreg u_subreg  (.q(sub_comb), .ad(subad_int), .al_b(alsub_b_int), .clk(clksub_int), .d(sub_int),
                     .lat(sublat_int), .sd_b(subsd_b_int), .e(esub_int), .sl_b(slsub_b_int), .pwrdwn_b(pwrdwn_b));
  cntlreg u_shftreg (.q(shft_comb), .ad(shftad_int), .al_b(alshft_b_int), .clk(clkshft_int), .d(shft_int),
                     .lat(shftlat_int), .sd_b(shftsd_b_int), .e(eshft_int), .sl_b(slshft_b_int), .pwrdwn_b(pwrdwn_b));
  cntlreg u_sel0reg (.q(sel0_comb), .ad(sel0ad_int), .al_b(alsel0_b_int), .clk(clksel0_int), .d(sel0_int),
                     .lat(sel0lat_int), .sd_b(sel0sd_b_int), .e(esel0_int), .sl_b(slsel0_b_int), .pwrdwn_b(pwrdwn_b));
  cntlreg u_sel1reg (.q(sel1_comb), .ad(sel1ad_int), .al_b(alsel1_b_int), .clk(clksel1_int), .d(sel1_int),
                     .lat(sel1lat_int), .sd_b(sel1sd_b_int), .e(esel1_int), .sl_b(slsel1_b_int), .pwrdwn_b(pwrdwn_b));
  datareg u_carryinreg (.q(carryin_comb), .arst_b(arstc_b_int[0]), .clk(clkc_int[0]), .d(carryin_int),
                        .lat(clat_int[0]), .e(ec_int[0]), .srst_b(srstc_b_int[0]), .pwrdwn_b(pwrdwn_b));
  datareg u_ovflreg    (.q(ovfl_ext_out_zd), .arst_b(arstp_b_int[1]), .clk(clkp_int[1]), .d(ovfl_ext_comb),
                        .lat(plat_int[1]), .e(ep_int[1]), .srst_b(srstp_b_int[1]), .pwrdwn_b(pwrdwn_b));
                          
  
  assign a_comb_b       = ~ a_comb;
  assign b_comb_b       = ~ b_comb;
  assign c_comb_b       = ~ c_comb;
  assign carryin_comb_b = ~ carryin_comb;
  assign sub_comb_b     = ~ sub_comb;
  assign shft_comb_b    = ~ shft_comb;
  assign sel0_comb_b    = ~ sel0_comb;
  assign sel1_comb_b    = ~ sel1_comb;
  assign p_comb         = ~ p_comb_b;
  assign ovfl_ext_comb  = ~ ovfl_ext_comb_b;
  
  MACC_COMB u0(.a_comb_b(a_comb_b), .b_comb_b(b_comb_b), .c_comb_b(c_comb_b), 
                    .cdin_comb(cdin_comb), .fdbk_comb(p_zd), 
                    .sel0_comb_b(sel0_comb_b), .sel1_comb_b(sel1_comb_b), 
                    .shft_comb_b(shft_comb_b), .sub_comb_b(sub_comb_b), 
                    .carryin_comb_b(carryin_comb_b), 
                    .mode0(mode0), .mode1(mode1), .mode2(mode2), 
                    .p_comb_b(p_comb_b), .ovfl_ext_comb_b(ovfl_ext_comb_b), .cdout(cdout_zd));
 
endmodule

module MACC_IP (// A input
                input [1:0] A_CLK,
                  input [17:0] A,
                  input [1:0] A_EN,
                  input [1:0] A_ARST_N,
                  input [1:0] A_SRST_N,
                  input [1:0] A_BYPASS,
                  // B input
                  input [1:0] B_CLK,
                  input [17:0] B,
                  input [1:0] B_EN,
                  input [1:0] B_ARST_N,
                  input [1:0] B_SRST_N,
                  input [1:0] B_BYPASS,
                  // C input
                  input [1:0]  C_CLK,
                  input [43:0] C,
                  input        CARRYIN,
                  input [1:0]  C_EN,
                  input [1:0]  C_ARST_N,
                  input [1:0]  C_SRST_N,
                  input [1:0]  C_BYPASS,
                  // cdin input
                  input [43:0] CDIN,
                  // sub input
                  input       SUB_CLK,
                  input       SUB,
                  input       SUB_EN,
                  input       SUB_AL_N,
                  input       SUB_SL_N,
                  input       SUB_BYPASS,
                  input       SUB_AD,
                  input       SUB_SD_N,
                  // shft input
                  input       ARSHFT17_CLK,
                  input       ARSHFT17,
                  input       ARSHFT17_EN,
                  input       ARSHFT17_AL_N,
                  input       ARSHFT17_SL_N,
                  input       ARSHFT17_BYPASS,
                  input       ARSHFT17_AD,
                  input       ARSHFT17_SD_N,
                  // sel0 input
                  input       FDBKSEL_CLK,
                  input       FDBKSEL,
                  input       FDBKSEL_EN,
                  input       FDBKSEL_AL_N,
                  input       FDBKSEL_SL_N,
                  input       FDBKSEL_BYPASS,
                  input       FDBKSEL_AD,
                  input       FDBKSEL_SD_N,
                  // sel1 input
                  input       CDSEL_CLK,
                  input       CDSEL,
                  input       CDSEL_EN,
                  input       CDSEL_AL_N,
                  input       CDSEL_SL_N,
                  input       CDSEL_BYPASS,
                  input       CDSEL_AD,
                  input       CDSEL_SD_N,
                  // p_out controls
                  input [1:0] P_CLK,
                  input [1:0] P_EN,
                  input [1:0] P_ARST_N,
                  input [1:0] P_SRST_N,
                  input [1:0] P_BYPASS,
                  // common
                  input SIMD,
                  input DOTP,
                  input OVFL_CARRYOUT_SEL,

                  output [43:0] P,
                  output        OVFL_CARRYOUT,
                  output [43:0] CDOUT);
  
  reg NOTIFY_REG;
  
  initial begin
    if (SIMD)
      $display("Error : SIMD can not be tied to 1. Instance: %m",$realtime);
  end
  
  MACC_IP_P u0 (.clka(A_CLK), .a(A), .ea(A_EN), .arsta_b(A_ARST_N), .srsta_b(A_SRST_N), .alat(A_BYPASS),
                .clkb(B_CLK), .b(B), .eb(B_EN), .arstb_b(B_ARST_N), .srstb_b(B_SRST_N), .blat(B_BYPASS),
                .clkc(C_CLK), .c(C), .ec(C_EN), .arstc_b(C_ARST_N), .srstc_b(C_SRST_N), .clat(C_BYPASS),
                .clkp(P_CLK),        .ep(P_EN), .arstp_b(P_ARST_N), .srstp_b(P_SRST_N), .plat(P_BYPASS),
                .carryin(CARRYIN), .cdin(CDIN),
                .clksub(SUB_CLK), .sub(SUB), .esub(SUB_EN), .alsub_b(SUB_AL_N), .slsub_b(SUB_SL_N), .sublat(SUB_BYPASS), .subad(SUB_AD), .subsd_b(SUB_SD_N),
                .clkshft(ARSHFT17_CLK), .shft(ARSHFT17), .eshft(ARSHFT17_EN), .alshft_b(ARSHFT17_AL_N), .slshft_b(ARSHFT17_SL_N), .shftlat(ARSHFT17_BYPASS), .shftad(ARSHFT17_AD), .shftsd_b(ARSHFT17_SD_N),
                .clksel0(FDBKSEL_CLK), .sel0(FDBKSEL), .esel0(FDBKSEL_EN), .alsel0_b(FDBKSEL_AL_N), .slsel0_b(FDBKSEL_SL_N), .sel0lat(FDBKSEL_BYPASS), .sel0ad(FDBKSEL_AD), .sel0sd_b(FDBKSEL_SD_N),
                .clksel1(CDSEL_CLK), .sel1(CDSEL), .esel1(CDSEL_EN), .alsel1_b(CDSEL_AL_N), .slsel1_b(CDSEL_SL_N), .sel1lat(CDSEL_BYPASS), .sel1ad(CDSEL_AD), .sel1sd_b(CDSEL_SD_N),
                .mode0(SIMD), .mode1(DOTP), .mode2(OVFL_CARRYOUT_SEL),
                .pwrdwn_b(1'b1),
                .p_out(P), .ovfl_ext_out(OVFL_CARRYOUT), .cdout(CDOUT));
  
  wire tim_chk_0 = B_BYPASS[1] & ~P_BYPASS[0];
  wire tim_chk_1 = A_BYPASS[1] & ~P_BYPASS[1];
  wire tim_chk_2 = C_BYPASS[0] & ~P_BYPASS[1];
  wire tim_chk_3 = B_BYPASS[0] & ~P_BYPASS[1];
  wire tim_chk_4 = A_BYPASS[0] & ~P_BYPASS[0];
  wire tim_chk_5 = B_BYPASS[0] & ~P_BYPASS[0];
  wire tim_chk_6 = A_BYPASS[1] & ~P_BYPASS[0];
  wire tim_chk_7 = A_BYPASS[0] & ~P_BYPASS[1];
  wire tim_chk_8 = C_BYPASS[0] & ~P_BYPASS[0];
  wire tim_chk_9 = C_BYPASS[1] & ~P_BYPASS[1];
  wire tim_chk_10 = B_BYPASS[1] & ~P_BYPASS[1];

  wire tim_chk_16 = (~A_BYPASS[0] & ~P_BYPASS[0]) | (~B_BYPASS[0] & ~P_BYPASS[0]) | (~C_BYPASS[0] & ~P_BYPASS[0]) ;
  wire tim_chk_17 = tim_chk_17 | (~ARSHFT17_BYPASS & ~P_BYPASS[0]) | (~CDSEL_BYPASS & ~P_BYPASS[0]) | (~FDBKSEL_BYPASS & ~P_BYPASS[0]) | (~SUB_BYPASS & ~P_BYPASS[0]) ;

  specify
    specparam PATHPULSE$     = (0.001, 0.001);
specparam tpdLH_CLK_to_Q = (0.1:0.1:0.1);
specparam tpdHL_CLK_to_Q = (0.1:0.1:0.1);
specparam tpdLH_IN_to_OUT = (0.1:0.1:0.1);
specparam tpdHL_IN_to_OUT = (0.1:0.1:0.1);
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[9], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge SUB, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[33] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CARRYIN, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[1], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[17] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[4], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[5], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[23], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[2], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[15] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[13], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[7], 0.0, NOTIFY_REG );
$setup( posedge C[19], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[8], 0.0, NOTIFY_REG );
$setup( negedge C[32], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[36], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[43] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[17], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, posedge ARSHFT17_AL_N, 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[30], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, negedge SUB_EN, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[34] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[43], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[25], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge SUB, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, negedge CDSEL_EN, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[0], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[28], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[7], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
$setup( posedge B[6], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[17], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[1], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[32], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[26], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[38], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[14], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[16] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[4], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CARRYIN, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge A[0], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
$setup( negedge B[7], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
$setup( posedge A_EN[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[8], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[24], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$setup( negedge C[14], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CARRYIN, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[35], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[1] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[0] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C_SRST_N[1], 0.0, NOTIFY_REG );
$setup( posedge CDIN[14], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$setup( negedge C[41], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[14], 0.0, NOTIFY_REG );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A_EN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[9], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[17] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[26], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[12], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, posedge ARSHFT17_EN, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[16], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[1], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[15], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[9] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[3] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[0] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[5], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[31] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[12], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[9], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C_EN[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[2], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[1], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge FDBKSEL_SL_N, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[10], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[2], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[10], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[12], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[21], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$setup( negedge A[11], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[7], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[17], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[17], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[2], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[11], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[8], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[16], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[26], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[30], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[21] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[16], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[6], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[6], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge C[22], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[10], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$setup( posedge A[16], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[6], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[12], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge CDIN[12], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[10], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[11], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A_EN[1], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[9], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[21], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[29], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[18], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[36], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[13], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C_ARST_N[0], 0.0, NOTIFY_REG );
$setup( posedge C[7], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[32] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[2] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[15] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[17], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[18], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[30] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[10], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[34], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[29] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[17], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[0] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[6] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[22], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[5], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[11], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[11], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[16], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[10], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[40], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[20], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDSEL, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[15], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[15], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[22], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[2], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[9], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[6] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[18] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[10], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[14], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge ARSHFT17_SL_N, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[7], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge P_EN[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[13], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[33], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[24], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[8], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[14], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[4], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[16] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[20], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[27], 0.0, NOTIFY_REG );
$setup( posedge C[24], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[1] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[11] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[4], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[32], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[2], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[12], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[8], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[18], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[0] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[36], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[3] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[42] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[26], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C_SRST_N[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[8], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[17], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[5], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[34], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge P_EN[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[7], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[6], 0.0, NOTIFY_REG );
$setup( posedge A_SRST_N[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[5], 0.0, NOTIFY_REG );
$setup( posedge A[4], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[28], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[26], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[1], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[27], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[16], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[3], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, posedge SUB_EN, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[2], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[16], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, posedge ARSHFT17, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[2], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, posedge ARSHFT17_SL_N, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[16] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[9], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[11], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[19], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[22], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[12], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$setup( negedge CDIN[18], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[7], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[10], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[34], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[42], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge ARSHFT17_SL_N, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[5], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[14], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge P_ARST_N[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[14], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[3] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[5], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[33], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[10], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[33] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[28], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[3], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge FDBKSEL_EN, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[16], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[1], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$setup( posedge C[13], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge P_SRST_N[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[11], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[8] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[4], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[21], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, negedge SUB_SL_N, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[20], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[39] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[42] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[34], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[38], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[33], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[5], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[15] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDSEL_SL_N, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
$setup( negedge A[15], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[19], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[1], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[38], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[10], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[19], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[19], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[17] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[29], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[11], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[12], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[17], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[12] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDSEL, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, posedge CDSEL_AL_N, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[38], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[24], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[1], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[12], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[27], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A_EN[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[3], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[39] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[38], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[38] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[13], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[35], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge SUB_EN, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[37], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[14], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[11], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[32], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B_EN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[17], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[0], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C_EN[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[21], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[9] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[11], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[8] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[32] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[17], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[37] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[3], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge B_ARST_N[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, negedge FDBKSEL_SL_N, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[1], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[11], 0.0, NOTIFY_REG );
$setup( negedge CARRYIN, posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[12] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[40], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[33], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[0], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[31], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[16], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[26], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[13] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[31], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[6], 0.0, NOTIFY_REG );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B_EN[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[23], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[2], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[13], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[16], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B_ARST_N[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[29], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[20] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[7], 0.0, NOTIFY_REG );
$setup( negedge C[33], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge P_SRST_N[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[4] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[2], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[12], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[2], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[15], 0.0, NOTIFY_REG );
$setup( posedge B[10], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[16], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[25], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[26], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[29], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[3], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[3], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[21], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[10], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[12], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[38], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[34], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[7] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[42], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[16], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[43] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[3], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[1], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[11], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[40], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[19], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B_EN[1], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[11], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[14], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[24], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[24], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[14] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[20], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[8], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[11], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[13] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge ARSHFT17_AL_N, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge P_EN[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[1], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[20], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[11], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[28], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, posedge FDBKSEL_AL_N, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[2] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B_SRST_N[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[2], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$setup( negedge A[8], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[14], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[5], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[37], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[8], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[34], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge B[6], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[34], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[40], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[6], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge A[11], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[2], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[24], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[13], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge CDIN[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[7], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[3], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[0], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[5], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CARRYIN, posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[13], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[4], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[26], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[16] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[11], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[17], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[7], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[33], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[38], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[30], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[0], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[4], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[22], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[4], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge P_EN[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[34], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[8] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[28], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[1], 0.0, NOTIFY_REG );
$setup( negedge C[17], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[17], 0.0, NOTIFY_REG );
$setup( posedge A[3], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[43] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[17], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[42], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[1], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[13], 0.0, NOTIFY_REG );
$setup( negedge C[23], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[39], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[1] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[27], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[3], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, posedge SUB_SL_N, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[42], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[26], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[10], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
$setup( negedge CDIN[35], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[42] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[3], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[6], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[2], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[31], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[6], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge P_EN[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[20], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[32], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[13], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge P_ARST_N[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[23], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[13], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[8], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[4], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[5], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[3], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[35], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[36], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[17], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[27], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[15] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C_EN[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[21], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[2], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[4], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[23], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[6], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[9] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[11], 0.0, NOTIFY_REG );
$setup( negedge C[23], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[4], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[27], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[32], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[6], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A_SRST_N[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[0] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[3], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[26] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[17], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[24], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B_EN[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[25], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge FDBKSEL_EN, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[14], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] )
( B[0] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[37], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[42] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B_SRST_N[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[26] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[32], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[14], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
$setup( negedge ARSHFT17, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
$setup( posedge C[38], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[3], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[18] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[16], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
$setup( posedge A[14], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[1] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[2], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[30], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[9], 0.0, NOTIFY_REG );
$setup( posedge B[12], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[43], 0.0, NOTIFY_REG );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[18], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge P_EN[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[13], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[6], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[31], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[2] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B_SRST_N[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[3], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[31], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[9], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[11], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[11], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[4], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[9] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[16], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[15] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[9], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[7], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[4], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[13], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[34] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[8], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$setup( negedge C_SRST_N[1], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge C[0], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$setup( negedge CDIN[20], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[10], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDSEL_EN, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[36], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[12], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[4], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[13], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[42] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[8] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[3] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[13], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[13], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[5], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[39], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[9], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[27], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[28], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[7] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[22], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[28], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[30], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[30], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[4], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[2], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[31], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B_EN[1], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[6] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[24] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CARRYIN, posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[0] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[43], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[7], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[17], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge ARSHFT17, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[16], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[11], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[16] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[33], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[43], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[2], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[26] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[5], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[17], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[15], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[13], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[23] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[16], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[23], 0.0, NOTIFY_REG );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, negedge ARSHFT17_EN, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[30], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[13] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[33], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[11] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[5], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[42], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[11], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[15], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[8] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[40], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[0] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[24], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[9], 0.0, NOTIFY_REG );
$setup( negedge A_SRST_N[1], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[33], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[11], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A_SRST_N[1], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[0], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[43] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[0], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
$setup( posedge C[28], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[4], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[4], 0.0, NOTIFY_REG );
$setup( posedge CDSEL_EN, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
$setup( negedge A_EN[1], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[0] & ~SIMD )
( A[9] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[16], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[1], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[32], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[42] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[16] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] )
( B[0] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[10], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[7] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[43], 0.0, NOTIFY_REG );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[9], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[7], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, negedge ARSHFT17, 0.0, NOTIFY_REG );
$setup( posedge A[8], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge P_SRST_N[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[2], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$setup( posedge C[12], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[8], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[21] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[1], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[30], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[38], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C_EN[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[12], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[16] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[7], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$setup( negedge C[16], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$setup( negedge A[5], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[16] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[8], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[9], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[29] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[18], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[17], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[7] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[25], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[6], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[8], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] & ~SIMD )
( A[9] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[10], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[7], 0.0, NOTIFY_REG );
$setup( negedge C[1], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[40] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[9], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[32], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[17], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[25], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[14], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[6], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[17], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[29], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[1], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[29], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[6] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[15], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[12], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
$setup( negedge C[8], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[3], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B_EN[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[2], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[43] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[10], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[15], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[25], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[29], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[12], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[5], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[8], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[20], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[13], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[6], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A_SRST_N[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[18], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[37], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[6], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[41], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[3], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[43] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge FDBKSEL, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[3] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[16] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[15], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[17], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[13], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[40], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[3], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[5], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[32] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, posedge FDBKSEL, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[12], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[23], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[24], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[0], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$setup( posedge C[35], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[2], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[5] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[17], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[22], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[28] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[17], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[14], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge P_SRST_N[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[41], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[5], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[7], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[14], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[5] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[6] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[7], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[0] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[17] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[15], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge SUB_AL_N, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B_SRST_N[1], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[15] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[15], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B_SRST_N[1], 0.0, NOTIFY_REG );
$setup( posedge A[1], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[41] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[1] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[16], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[16] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[27], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[37], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[7] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[43], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[33], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[7], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[29] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C_ARST_N[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[5], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, negedge CDSEL_SL_N, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[42], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[3], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[25], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[10], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[4], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[31], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[16] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[8], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[17] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[5], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge CARRYIN, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[25] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge C[8], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[36], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[14], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[39], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[4] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge SUB_SL_N, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
$setup( posedge C[39], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[12], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, negedge CDSEL, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[36], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[17], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[16], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[35], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[15], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[11], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[14], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[14], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[39], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[39], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[42], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[11], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[14] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[15], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[33], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge FDBKSEL_SL_N, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[28], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[5], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[18], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[19], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, posedge FDBKSEL_SL_N, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[8], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[4], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[4], 0.0, NOTIFY_REG );
$setup( negedge A[3], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[0] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[12], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[10], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[6], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[5], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[10], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[5], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[2], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[8], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[18], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[40], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[40], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[6], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$setup( posedge C[33], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[23], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[6], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[13], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[9], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[29] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[14], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[14], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[43], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge C_ARST_N[1], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[9], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[10], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, negedge SUB, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[4], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[13] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[24], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[40], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge CDIN[34], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[2], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[24], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[43], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[11], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$setup( posedge CDIN[43], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[13] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[2], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[11], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[21], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[4], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[4] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B_SRST_N[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[16], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[42], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[30], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CARRYIN, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[24] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[10], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[34], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[15], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[17], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[2], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[17], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[8], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[7], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[10] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[5], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[27] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[18], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[7] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[34], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[24] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[8], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDSEL_SL_N, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[19]+: P[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[28], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[28], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[5], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[3], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[31], 0.0, NOTIFY_REG );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[14], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A_EN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[7], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[36] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[7], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[29], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[11] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge ARSHFT17_EN, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[21] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B_SRST_N[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[3], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[20]+: P[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[7] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[19], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[13], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[12], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[15], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[25], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[25], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge FDBKSEL, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[12], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[33], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[34], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, posedge CDSEL, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[33] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[7], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[23] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[5], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[8], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[17], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[15], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[8], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[2], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[16] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[12], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[0], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[24], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[5], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[5]+: P[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge B[12], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[21], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[32], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[9], 0.0, NOTIFY_REG );
$setup( negedge CDIN[8], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[10], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[3], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, negedge FDBKSEL, 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[42], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[7], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[35], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[17], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[12], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge B[12], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[15] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[37], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C_EN[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[11], 0.0, NOTIFY_REG );
$setup( posedge CDIN[16], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[10], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[6], 0.0, NOTIFY_REG );
$setup( negedge A[7], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[14], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[3], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[13], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
$setup( negedge C[8], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C_EN[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[13], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[10], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[29], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[2], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[2], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[19], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge SUB_EN, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[0]+: P[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[12] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[5], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[3], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[30], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[10], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[19] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A_SRST_N[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[13], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[13], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[6]+: P[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[11], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[27], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[5], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[9], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[3], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[27], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[30] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[21] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[18], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[15], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[17] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[5], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[16] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[20], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[21], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, posedge FDBKSEL_EN, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[11] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge CDSEL_AL_N, posedge CDSEL_CLK &&& ~CDSEL_BYPASS, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[20], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[13] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[0] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B_SRST_N[1], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge SUB_SL_N, posedge SUB_CLK &&& ~SUB_BYPASS, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[13], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, negedge B[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[9], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_1, posedge A[9], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[24], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge A_ARST_N[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[5], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[41], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[24] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[29], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[21], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[33], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[39], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[39], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[2], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[33] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[26], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[41], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[28], 0.0, NOTIFY_REG );
$setup( posedge B[8], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[31] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[5], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[4], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[20], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[42] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[2] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[35] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[43], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[23], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[16], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[15], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[13], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[43], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[8] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[16], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[32], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[39] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[17], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[23] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[23], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[19], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[25], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[10], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[31], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[13], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[19], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[26], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[1], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[25], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[8], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[33] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[9], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge P_SRST_N[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[14] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[23] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[6], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[41], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[37], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[15], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[28], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[7] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge A[6], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[16], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[19], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[40], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[12], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[19], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[28] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[22], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A_EN[0], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[19], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[29], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[9], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[15], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge CARRYIN, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[15] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[25], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, posedge SUB_AL_N, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[7], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[10], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, negedge FDBKSEL_EN, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[20], 0.0, NOTIFY_REG );
$setup( negedge C[11], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[22], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[4] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[8], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[11], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[17] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[12], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[33] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[23], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[12] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[28], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[14]+: CDOUT[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[19], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[15], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[12], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[30], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[6], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[26], 0.0, NOTIFY_REG );
$setup( negedge B[16], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[21], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[4], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C_EN[1], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[8], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[0] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[9], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
$setup( posedge C[41], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[26], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[22], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[18], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, negedge ARSHFT17_SL_N, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[16] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[15] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[7], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[3] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[40] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[38], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[3] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[35], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[30], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[14], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[36], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[16], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge P_ARST_N[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[14] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[40], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[40], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[1], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[16], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge P_EN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[26] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge C_ARST_N[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[17], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[5], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[2], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[7], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[31], 0.0, NOTIFY_REG );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[29]+: P[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[34], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[27]+: CDOUT[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[4], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[2], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[0], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[13] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[10], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[10], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[1], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[17], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[29], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[32], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge C[2], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[5] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[16] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[4], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[14], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[39], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[37], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[22], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[32] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[41]+: P[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[7] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[24], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CARRYIN, posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_0, posedge B[11], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[34] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[34], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[9], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[0], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[16], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B_EN[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[31], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[2], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[29] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[0] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[9], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[22], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[5], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[29] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[23], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[13], 0.0, NOTIFY_REG );
$recovery( posedge FDBKSEL_AL_N, posedge FDBKSEL_CLK &&& ~FDBKSEL_BYPASS, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C_SRST_N[1], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[18] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[0], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[13], 0.0, NOTIFY_REG );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[28]+: CDOUT[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[22]+: P[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[41], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[26]+: CDOUT[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[37], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] )
( B[0] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[1], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[30], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C_SRST_N[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[21] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[31], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[18], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[16], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[41] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[31], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[13], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[11], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[25] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[15], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[7], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[1], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[25], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[3] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[18], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[11] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[0], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[10]+: CDOUT[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[23] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[18]+: CDOUT[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[11], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[24], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[14] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$recovery( posedge B_ARST_N[1], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[36], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[7], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[33] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[12], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[17], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[16], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[17] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[4] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[2] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[6] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[33] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[38], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[38], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge C[10], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[25], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[0] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[3], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
$setup( negedge A[17], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B_EN[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[4]+: P[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[6], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[12], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[15], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[15] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[42], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[9]+: P[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[21]+: P[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[32], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[25] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[37]+: CDOUT[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[10] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[0], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[9], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[22] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[28]+: P[28] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge CDIN[20], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A_SRST_N[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[5], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[10], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[8], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[15] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[13], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[6] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[13], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[43] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_1, negedge A[10], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[12], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[25]+: P[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[9], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge P_SRST_N[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[22], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[37], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[17] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[30], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[21], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[13] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[20], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[10], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[27], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[0]+: CDOUT[0] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[30]+: P[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[21], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$setup( negedge A[3], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[24] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[11] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[16], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[12], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[33] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[10] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[2], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[19] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[27], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[13] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[21], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[0] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[3]+: P[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[14] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[3] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[33], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[28], 0.0, NOTIFY_REG );
$setup( negedge P_SRST_N[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[27], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( P[26]+: P[26] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[37], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[4], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[35]+: P[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[1], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B_ARST_N[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[13], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[32], 0.0, NOTIFY_REG );
$setup( posedge C[26], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$setup( posedge C[18], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[2], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[1] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[10] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[23], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& tim_chk_4, posedge A[3], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[2], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[9], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[27]+: P[27] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[15]+: P[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[29]+: CDOUT[29] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[4]+: CDOUT[4] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[34], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[21]+: CDOUT[21] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[9], posedge P_CLK[1] &&& tim_chk_10, 0.0, NOTIFY_REG );
$setup( negedge A[7], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[6] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[27], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[10], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[30], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C_SRST_N[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[8], 0.0, NOTIFY_REG );
$hold( posedge SUB_CLK &&& ~SUB_BYPASS, posedge SUB, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[7]+: P[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[25] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[6], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[28], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[16] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[6], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, posedge A[12], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[14] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[16], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[38] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[31]+: P[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge P_SRST_N[0], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[12], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[13], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[26] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[40] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[5] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[19]+: CDOUT[19] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[32]+: P[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[16] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A[16], 0.0, NOTIFY_REG );
$setup( negedge C[32], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[24] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, posedge B[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[16] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[35], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[12] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[1], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[7], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[35], 0.0, NOTIFY_REG );
$setup( posedge C[39], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[36], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CARRYIN, posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[15] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( P[12]+: P[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A_SRST_N[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[4], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[34], 0.0, NOTIFY_REG );
$setup( negedge C_EN[1], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[29], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[15] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[14] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge ARSHFT17_EN, posedge ARSHFT17_CLK &&& ~ARSHFT17_BYPASS, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[24] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[39]+: P[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[35], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, negedge C[8], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[8] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_8, posedge C[15], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[17]+: CDOUT[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge P_ARST_N[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[9] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[36] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[4] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[11] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[31] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[34]+: CDOUT[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[2] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[17], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], negedge B[5], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[15]+: CDOUT[15] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[8], 0.0, NOTIFY_REG );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, posedge CDSEL_SL_N, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[14], posedge B_CLK[1] &&& ~B_BYPASS[1], 0.0, NOTIFY_REG );
$setup( posedge C[3], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[27] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( CARRYIN => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[3] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], posedge B[17], 0.0, NOTIFY_REG );
$setup( negedge A[4], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[25]+: CDOUT[25] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[1]+: P[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[39] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[21], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[39], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[13] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[41], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[0] &&& ~B_BYPASS[0], posedge B[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, posedge A[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[22]+: CDOUT[22] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge CDIN[42], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[9]+: CDOUT[9] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[21] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[11], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[41] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[16] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[31], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[22] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[36]+: CDOUT[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[43]+: CDOUT[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[4] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[16] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[0] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[8], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[9] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[0], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[24] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[30] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[11] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[13], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[29], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[11], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[28] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[6] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[4] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[10], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[10] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[10], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[15] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[39], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[13] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[17]+: P[17] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[12] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[22], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[24] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], posedge A_ARST_N[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[0] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[0]  ) == 1 )
( A[9] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[1] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[7] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[14], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[38] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[20], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[7] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[19], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[8] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CARRYIN, posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[39]+: CDOUT[39] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[20] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_7, negedge A[7], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[29], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C[3], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[27] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[5] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[12] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[21] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[33] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, posedge C[0], 0.0, NOTIFY_REG );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[20]+: CDOUT[20] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[17] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], negedge C_SRST_N[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[17], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[5] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[9], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[2] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[23] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[12], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[1] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[18] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[11] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[13], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[35], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[16]+: CDOUT[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~B_BYPASS[1] & P_BYPASS[0] )
( posedge B_CLK[1] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$hold( posedge P_CLK[1] &&& tim_chk_10, posedge B[14], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[3] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[4] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[22], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[18]+: P[18] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[3] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_6, negedge A[11], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[23]+: P[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[3] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[13]+: CDOUT[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[35] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( CDOUT[30]+: CDOUT[30] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] )
( B[0] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[8], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[11] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[7] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[16] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[20] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[25], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[3] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[31], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[23]+: CDOUT[23] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge C[9], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[12] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[12] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[0] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_3, posedge B[2], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[15] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[15], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[41]+: CDOUT[41] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[29] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[42] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$recovery( posedge A_ARST_N[1], posedge A_CLK[1] &&& ~A_BYPASS[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[38] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[3], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[18], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[41] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[6] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => P[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[0] &&& ~A_BYPASS[0], negedge A[6], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[30] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[16], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => P[2] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge CDSEL_CLK &&& ~CDSEL_BYPASS, posedge CDSEL_EN, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[2] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[38]+: P[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[8] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_0, negedge B[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[30] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[5] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[2] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( A[8] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[1] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[29] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[8] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[8], posedge P_CLK[1] &&& tim_chk_3, 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[3]+: CDOUT[3] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[33], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[9] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[27], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge P_EN[0], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[4], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[1] )
( posedge B_CLK[0] => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( posedge A[4], posedge P_CLK[0] &&& tim_chk_4, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[31]+: CDOUT[31] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[23] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[42], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[4] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], posedge CDIN[13], 0.0, NOTIFY_REG );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[14]+: P[14] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[21] => P[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[3] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[16] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[16], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[12] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[17] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[8] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[23] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], negedge C[23], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[7] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[22], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_5, negedge B[3], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[0] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[10] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[37], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_2, negedge C[11], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[3] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[17], posedge P_CLK[0] &&& tim_chk_0, 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[3] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[41], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[1] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( CDOUT[12]+: CDOUT[12] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[23] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[5] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[36], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[8] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[15], posedge P_CLK[1] &&& tim_chk_2, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[29] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( P[34]+: P[34] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge CDIN[32], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[3] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[1] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[7] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[24]+: CDOUT[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A_EN[0], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( B_BYPASS[0] & P_BYPASS[1] )
( B[2] => P[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge A[9], posedge P_CLK[0] &&& tim_chk_6, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[33] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => CDOUT[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[33]+: CDOUT[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[10]+: P[10] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( P[40]+: P[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[34] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[8] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[21] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( P[13]+: P[13] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[9] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[14], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[17] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[1]+: CDOUT[1] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~A_BYPASS[1] & P_BYPASS[0] )
( posedge A_CLK[1] => ( CDOUT[11]+: CDOUT[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[4], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[19] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[11] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[14] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[1] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[16] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[12] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[27] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[1] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], posedge A_ARST_N[1], 0.0, NOTIFY_REG );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[27] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[22] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[28] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[1] )
( posedge P_CLK[1] => ( P[43]+: P[43] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[12], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
$setup( negedge B[2], posedge B_CLK[0] &&& ~B_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[0] )
( B[10] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[8] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge B_CLK[1] &&& ~B_BYPASS[1], negedge B[15], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[15] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[18] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[34] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge A_CLK[1] &&& ~A_BYPASS[1], negedge A[11], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[34] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[6] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[5] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[1] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[17] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[5], 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[14], posedge P_CLK[1] &&& tim_chk_1, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[0] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[1] & P_BYPASS[1] )
( B[13] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_9, posedge C[41], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[31], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[14] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[14] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[0] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[26] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[29] => CDOUT[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge B[7], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[7] => CDOUT[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[19] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[32] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[20] => P[4] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( B[4] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[14] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[3], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[14] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge A[7], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[9] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[18] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[21] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[41], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[37]+: P[37] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[13] => CDOUT[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[19] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge B[7], posedge P_CLK[0] &&& tim_chk_5, 0.0, NOTIFY_REG );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[4] => P[11] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[35] => CDOUT[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[11] => P[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( P[8]+: P[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[1] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[25] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[7] => CDOUT[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[2] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( CARRYIN => CDOUT[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[15] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[3] => P[39] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[0] & P_BYPASS[0] )
( posedge B_CLK[0] => ( CDOUT[8]+: CDOUT[8] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[5] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[13] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => CDOUT[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[23], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[35]+: CDOUT[35] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[40] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( CDOUT[5]+: CDOUT[5] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[25] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[10] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[8] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& tim_chk_4, negedge A[5], 0.0, NOTIFY_REG );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[7]+: CDOUT[7] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => P[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[26], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[12] => CDOUT[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& ~P_BYPASS[1], negedge CDIN[0], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], posedge CDIN[21], 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[26] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( P[33]+: P[33] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[20] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[25] => CDOUT[18] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => CDOUT[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[6] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[0] )
( posedge C_CLK[0] => ( CDOUT[6]+: CDOUT[6] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[26] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( CDOUT[38]+: CDOUT[38] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[6] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[39] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => CDOUT[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[43] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[0]  ) == 1 )
( A[5] => P[9] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[11] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[16] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[17] => P[20] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[42]+: CDOUT[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[2] => P[10] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[5] => CDOUT[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[0] )
( C[12] => CDOUT[15] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[10] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[0] &&& ~P_BYPASS[0], negedge CDIN[26], 0.0, NOTIFY_REG );
$setup( negedge A[4], posedge A_CLK[0] &&& ~A_BYPASS[0], 0.0, NOTIFY_REG );
$setup( negedge C[25], posedge C_CLK[1] &&& ~C_BYPASS[1], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[10] => P[31] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~ARSHFT17_BYPASS & P_BYPASS[0] )
( posedge ARSHFT17_CLK => ( CDOUT[2]+: CDOUT[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[12] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[16] => P[40] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[13] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[10] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[37] => P[32] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[9] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[0] )
( posedge SUB_CLK => ( P[2]+: P[2] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[26] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( P[42]+: P[42] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[0] => CDOUT[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[0] )
( A[15] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge P_CLK[1] &&& tim_chk_10, negedge B[9], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( B[3] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[0] & P_BYPASS[1] )
( posedge C_CLK[0] => ( P[36]+: P[36] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[22] => P[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[30], 0.0, NOTIFY_REG );
$hold( posedge P_CLK[1] &&& tim_chk_9, negedge C[20], 0.0, NOTIFY_REG );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => CDOUT[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[28] => P[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[22] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[9] => CDOUT[29] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[17] => P[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[4] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[13] => CDOUT[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[31] => P[14] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[31] => CDOUT[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[43] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[3] => P[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[0] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[1] => P[33] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[32] => CDOUT[19] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~C_BYPASS[1] & P_BYPASS[1] )
( posedge C_CLK[1] => ( OVFL_CARRYOUT+: OVFL_CARRYOUT ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[15] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[37] => CDOUT[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[4] => P[12] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( posedge C[16], posedge P_CLK[0] &&& tim_chk_8, 0.0, NOTIFY_REG );
if ( P_BYPASS[1] )
( CDIN[37] => P[27] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[0] => CDOUT[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[7] => P[30] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[11] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[22] => P[22] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[9] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[12] => CDOUT[35] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[32] => CDOUT[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[24] => P[24] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[6] => P[17] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[0] => P[0] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[1] & P_BYPASS[1] )
( A[14] => CDOUT[21] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[0] )
( posedge A_CLK[0] => ( P[16]+: P[16] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[19] => CDOUT[13] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[15] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( A_BYPASS[0] & P_BYPASS[1]  ) == 1 )
( A[7] => CDOUT[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[41] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~SUB_BYPASS & P_BYPASS[1] )
( posedge SUB_CLK => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[0] )
( CDIN[5] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[0] )
( A[2] => P[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( A_BYPASS[0] & P_BYPASS[1] )
( A[4] => CDOUT[36] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~B_BYPASS[1] & P_BYPASS[1] )
( posedge B_CLK[1] => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
$setup( negedge A[6], posedge P_CLK[1] &&& tim_chk_7, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[20] => CDOUT[6] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[1] & P_BYPASS[1] )
( posedge A_CLK[1] => ( CDOUT[32]+: CDOUT[32] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[30] => P[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[43], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[16] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[6] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge CDIN[27], posedge P_CLK[0] &&& ~P_BYPASS[0], 0.0, NOTIFY_REG );
if ( ( A_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( A[9] => CDOUT[34] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[26] => P[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[4] => P[5] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[37] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[2] => P[8] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ( B_BYPASS[1] & P_BYPASS[1]  ) == 1 )
( B[11] => CDOUT[28] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[1] & P_BYPASS[1] )
( C[20] => P[41] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[0] )
( CDIN[17] => CDOUT[3] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[16] => P[23] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( ~A_BYPASS[0] & P_BYPASS[1] )
( posedge A_CLK[0] => ( P[24]+: P[24] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~P_BYPASS[0] )
( posedge P_CLK[0] => ( P[11]+: P[11] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( ~ARSHFT17_BYPASS & P_BYPASS[1] )
( posedge ARSHFT17_CLK => ( CDOUT[40]+: CDOUT[40] ) ) = ( tpdLH_CLK_to_Q, tpdHL_CLK_to_Q );
if ( P_BYPASS[1] )
( CDIN[19] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[5] => P[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[2] => CDOUT[38] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( B_BYPASS[0] & P_BYPASS[0] & ~SIMD )
( B[1] => CDOUT[7] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[4] => P[25] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[8] => CDOUT[26] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C_SRST_N[0], posedge C_CLK[0] &&& ~C_BYPASS[0], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[1] &&& ~C_BYPASS[1], posedge C[29], 0.0, NOTIFY_REG );
if ( C_BYPASS[0] & P_BYPASS[1] )
( C[2] => OVFL_CARRYOUT ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
if ( P_BYPASS[1] )
( CDIN[36] => P[42] ) = ( tpdLH_IN_to_OUT, tpdHL_IN_to_OUT );
$setup( negedge C[36], posedge P_CLK[1] &&& tim_chk_9, 0.0, NOTIFY_REG );
$setup( posedge CDIN[15], posedge P_CLK[1] &&& ~P_BYPASS[1], 0.0, NOTIFY_REG );
$hold( posedge C_CLK[0] &&& ~C_BYPASS[0], posedge C[9], 0.0, NOTIFY_REG );

    $period( posedge P_CLK[0] &&& tim_chk_16, 0.0, NOTIFY_REG );
    $period( negedge P_CLK[0] &&& tim_chk_16, 0.0, NOTIFY_REG );
    $period( posedge P_CLK[1] &&& tim_chk_17, 0.0, NOTIFY_REG );
    $period( negedge P_CLK[1] &&& tim_chk_17, 0.0, NOTIFY_REG );
    $period( posedge A_CLK[0], 0.0, NOTIFY_REG );
    $period( negedge A_CLK[0], 0.0, NOTIFY_REG );
    $period( posedge A_CLK[1], 0.0, NOTIFY_REG );
    $period( negedge A_CLK[1], 0.0, NOTIFY_REG );
    $period( posedge B_CLK[0], 0.0, NOTIFY_REG );
    $period( negedge B_CLK[0], 0.0, NOTIFY_REG );
    $period( posedge B_CLK[1], 0.0, NOTIFY_REG );
    $period( negedge B_CLK[1], 0.0, NOTIFY_REG );
    $period( posedge C_CLK[0], 0.0, NOTIFY_REG );
    $period( negedge C_CLK[0], 0.0, NOTIFY_REG );
    $period( posedge C_CLK[1], 0.0, NOTIFY_REG );
    $period( negedge C_CLK[1], 0.0, NOTIFY_REG );
    
    $period( posedge CDSEL_CLK, 0.0, NOTIFY_REG );
    $period( posedge FDBKSEL_CLK, 0.0, NOTIFY_REG );
    $period( posedge ARSHFT17_CLK, 0.0, NOTIFY_REG );
    $period( posedge SUB_CLK, 0.0, NOTIFY_REG );
  endspecify
  
endmodule

`timescale 1ps/1ps
module MACC(// Common
            input [1:0] CLK,
            // A input
            input [17:0] A,
            input [1:0]  A_EN,
            input [1:0]  A_ARST_N,
            input [1:0]  A_SRST_N,
            input [1:0]  A_BYPASS,
            // B input
            input [17:0] B,
            input [1:0]  B_EN,
            input [1:0]  B_ARST_N,
            input [1:0]  B_SRST_N,
            input [1:0]  B_BYPASS,
            // C input
            input [43:0] C,
            input        CARRYIN,
            input [1:0]  C_EN,
            input [1:0]  C_ARST_N,
            input [1:0]  C_SRST_N,
            input [1:0]  C_BYPASS,
            // CDIN input
            input [43:0] CDIN,
            // SUB input
            input       SUB,
            input       SUB_EN,
            input       SUB_AL_N,
            input       SUB_SL_N,
            input       SUB_BYPASS,
            input       SUB_AD,
            input       SUB_SD_N,
            // ARSHFT17 input
            input       ARSHFT17,
            input       ARSHFT17_EN,
            input       ARSHFT17_AL_N,
            input       ARSHFT17_SL_N,
            input       ARSHFT17_BYPASS,
            input       ARSHFT17_AD,
            input       ARSHFT17_SD_N,
            // FDBKSEL input
            input       FDBKSEL,
            input       FDBKSEL_EN,
            input       FDBKSEL_AL_N,
            input       FDBKSEL_SL_N,
            input       FDBKSEL_BYPASS,
            input       FDBKSEL_AD,
            input       FDBKSEL_SD_N,
            // CDSEL input
            input       CDSEL,
            input       CDSEL_EN,
            input       CDSEL_AL_N,
            input       CDSEL_SL_N,
            input       CDSEL_BYPASS,
            input       CDSEL_AD,
            input       CDSEL_SD_N,
            // P controls
            input [1:0] P_EN,
            input [1:0] P_ARST_N,
            input [1:0] P_SRST_N,
            input [1:0] P_BYPASS,
            // Static Signals
            input SIMD,
            input DOTP,
            input OVFL_CARRYOUT_SEL,
            // Outputs
            output [43:0] P,
            output        OVFL_CARRYOUT,
            output [43:0] CDOUT);

  wire [1:0] clka;
  wire [1:0] clkb;
  wire [1:0] clkc;
  wire [1:0] clkp;
  wire [1:0] ea;
  wire [1:0] eb;
  wire [1:0] ec;
  wire [1:0] ep;
  wire [1:0] arsta_b;
  wire [1:0] arstb_b;
  wire [1:0] arstc_b;
  wire [1:0] arstp_b;
  wire [1:0] srsta_b;
  wire [1:0] srstb_b;
  wire [1:0] srstc_b;
  wire [1:0] srstp_b;
  wire       clksub, clkshft, clksel0, clksel1;
  wire       esub, eshft, esel0, esel1;
  wire       alsub_b, alshft_b, alsel0_b, alsel1_b;
  wire       slsub_b, slshft_b, slsel0_b, slsel1_b;

  assign clka = A_BYPASS[0] ? { A_BYPASS[1] ? 1'b1 : CLK[1] , 1'b1 } : { A_BYPASS[1] ? 1'b1 : CLK[1] , CLK[0] };
  assign clkb = B_BYPASS[0] ? { B_BYPASS[1] ? 1'b1 : CLK[1] , 1'b1 } : { B_BYPASS[1] ? 1'b1 : CLK[1] , CLK[0] };
  assign clkc = C_BYPASS[0] ? { C_BYPASS[1] ? 1'b1 : CLK[1] , 1'b1 } : { C_BYPASS[1] ? 1'b1 : CLK[1] , CLK[0] };
  assign clkp = P_BYPASS[0] ? { P_BYPASS[1] ? 1'b1 : CLK[1] , 1'b1 } : { P_BYPASS[1] ? 1'b1 : CLK[1] , CLK[0] };

  assign ea = A_BYPASS[0] ? { A_BYPASS[1] ? 1'b1 : A_EN[1] , 1'b1 } : { A_BYPASS[1] ? 1'b1 : A_EN[1] , A_EN[0] };
  assign eb = B_BYPASS[0] ? { B_BYPASS[1] ? 1'b1 : B_EN[1] , 1'b1 } : { B_BYPASS[1] ? 1'b1 : B_EN[1] , B_EN[0] };
  assign ec = C_BYPASS[0] ? { C_BYPASS[1] ? 1'b1 : C_EN[1] , 1'b1 } : { C_BYPASS[1] ? 1'b1 : C_EN[1] , C_EN[0] };
  assign ep = P_BYPASS[0] ? { P_BYPASS[1] ? 1'b1 : P_EN[1] , 1'b1 } : { P_BYPASS[1] ? 1'b1 : P_EN[1] , P_EN[0] };

  assign arsta_b = A_BYPASS[0] ? { A_BYPASS[1] ? 1'b1 : A_ARST_N[1] , 1'b1 } : { A_BYPASS[1] ? 1'b1 : A_ARST_N[1] , A_ARST_N[0] };
  assign arstb_b = B_BYPASS[0] ? { B_BYPASS[1] ? 1'b1 : B_ARST_N[1] , 1'b1 } : { B_BYPASS[1] ? 1'b1 : B_ARST_N[1] , B_ARST_N[0] };
  assign arstc_b = C_BYPASS[0] ? { C_BYPASS[1] ? 1'b1 : C_ARST_N[1] , 1'b1 } : { C_BYPASS[1] ? 1'b1 : C_ARST_N[1] , C_ARST_N[0] };
  assign arstp_b = P_BYPASS[0] ? { P_BYPASS[1] ? 1'b1 : P_ARST_N[1] , 1'b1 } : { P_BYPASS[1] ? 1'b1 : P_ARST_N[1] , P_ARST_N[0] };
  
  assign srsta_b = A_BYPASS[0] ? { A_BYPASS[1] ? 1'b1 : A_SRST_N[1] , 1'b1 } : { A_BYPASS[1] ? 1'b1 : A_SRST_N[1] , A_SRST_N[0] };
  assign srstb_b = B_BYPASS[0] ? { B_BYPASS[1] ? 1'b1 : B_SRST_N[1] , 1'b1 } : { B_BYPASS[1] ? 1'b1 : B_SRST_N[1] , B_SRST_N[0] };
  assign srstc_b = C_BYPASS[0] ? { C_BYPASS[1] ? 1'b1 : C_SRST_N[1] , 1'b1 } : { C_BYPASS[1] ? 1'b1 : C_SRST_N[1] , C_SRST_N[0] };
  assign srstp_b = P_BYPASS[0] ? { P_BYPASS[1] ? 1'b1 : P_SRST_N[1] , 1'b1 } : { P_BYPASS[1] ? 1'b1 : P_SRST_N[1] , P_SRST_N[0] };

  assign clksub  = SUB_BYPASS      ? 1'b1 : CLK[1];
  assign clkshft = ARSHFT17_BYPASS ? 1'b1 : CLK[1];
  assign clksel0 = FDBKSEL_BYPASS  ? 1'b1 : CLK[1];
  assign clksel1 = CDSEL_BYPASS    ? 1'b1 : CLK[1];

  assign esub  = SUB_BYPASS      ? 1'b1 : SUB_EN;
  assign eshft = ARSHFT17_BYPASS ? 1'b1 : ARSHFT17_EN;
  assign esel0 = FDBKSEL_BYPASS  ? 1'b1 : FDBKSEL_EN;
  assign esel1 = CDSEL_BYPASS    ? 1'b1 : CDSEL_EN;

  assign alsub_b  = SUB_BYPASS      ? 1'b1 : SUB_AL_N;
  assign alshft_b = ARSHFT17_BYPASS ? 1'b1 : ARSHFT17_AL_N;
  assign alsel0_b = FDBKSEL_BYPASS  ? 1'b1 : FDBKSEL_AL_N;
  assign alsel1_b = CDSEL_BYPASS    ? 1'b1 : CDSEL_AL_N;

  assign slsub_b  = SUB_BYPASS      ? 1'b1 : SUB_SL_N;
  assign slshft_b = ARSHFT17_BYPASS ? 1'b1 : ARSHFT17_SL_N;
  assign slsel0_b = FDBKSEL_BYPASS  ? 1'b1 : FDBKSEL_SL_N;
  assign slsel1_b = CDSEL_BYPASS    ? 1'b1 : CDSEL_SL_N;

  MACC_IP u_macc (.A_CLK(clka), .A(A), .A_EN(A_EN), .A_ARST_N(A_ARST_N), .A_SRST_N(A_SRST_N), .A_BYPASS(A_BYPASS),
                  .B_CLK(clkb), .B(B), .B_EN(B_EN), .B_ARST_N(B_ARST_N), .B_SRST_N(B_SRST_N), .B_BYPASS(B_BYPASS),
                  .C_CLK(clkc), .C(C), .C_EN(C_EN), .C_ARST_N(C_ARST_N), .C_SRST_N(C_SRST_N), .C_BYPASS(C_BYPASS),
                  .P_CLK(clkp),        .P_EN(P_EN), .P_ARST_N(P_ARST_N), .P_SRST_N(P_SRST_N), .P_BYPASS(P_BYPASS),
                  .CARRYIN(CARRYIN),
                  .CDIN(CDIN),
                  .SUB_CLK(clksub), .SUB(SUB), .SUB_EN(SUB_EN), .SUB_AL_N(SUB_AL_N), .SUB_SL_N(SUB_SL_N), .SUB_BYPASS(SUB_BYPASS), .SUB_AD(SUB_AD), .SUB_SD_N(SUB_SD_N),
                  .ARSHFT17_CLK(clkshft), .ARSHFT17(ARSHFT17), .ARSHFT17_EN(ARSHFT17_EN), .ARSHFT17_AL_N(ARSHFT17_AL_N), .ARSHFT17_SL_N(ARSHFT17_SL_N), .ARSHFT17_BYPASS(ARSHFT17_BYPASS), .ARSHFT17_AD(ARSHFT17_AD), .ARSHFT17_SD_N(ARSHFT17_SD_N),
                  .FDBKSEL_CLK(clksel0), .FDBKSEL(FDBKSEL), .FDBKSEL_EN(FDBKSEL_EN), .FDBKSEL_AL_N(FDBKSEL_AL_N), .FDBKSEL_SL_N(FDBKSEL_SL_N), .FDBKSEL_BYPASS(FDBKSEL_BYPASS), .FDBKSEL_AD(FDBKSEL_AD), .FDBKSEL_SD_N(FDBKSEL_SD_N),
                  .CDSEL_CLK(clksel1), .CDSEL(CDSEL), .CDSEL_EN(CDSEL_EN), .CDSEL_AL_N(CDSEL_AL_N), .CDSEL_SL_N(CDSEL_SL_N), .CDSEL_BYPASS(CDSEL_BYPASS), .CDSEL_AD(CDSEL_AD), .CDSEL_SD_N(CDSEL_SD_N),
                  .SIMD(SIMD), .DOTP(DOTP), .OVFL_CARRYOUT_SEL(OVFL_CARRYOUT_SEL),
                  .P(P), .OVFL_CARRYOUT(OVFL_CARRYOUT), .CDOUT(CDOUT));

endmodule


