//-----------------------------------------------------------------
//       Actel Verilog Library
//       NAME: smartfusion.v
//       DATE: 8/12/2013
//-----------------------------------------------------------------


//----------------------------------------------------------------------
//---             VERILOG LIBRRAY PRIMITIVE SECTION                     
//----------------------------------------------------------------------

//---- PRIMITIVE Dffpr ----
 //---------------------------------------------------------------------
 // primitibe module (Dffpr) state table definition
 // FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
 //            ASYNCHRONOUS SET AND CLEAR. CLR PRIORITY WHEN BOTH
 //            SET AND CLEAR ARE LOW ( Q OUTPUT UDP ).
 //            Enable active low.

 //----------------------------------------------------------------------
primitive Dffpr (Q, D, CLK, CLR, PRE, E, NOTIFIER_REG);
  output Q;
  input  NOTIFIER_REG;
  input  D, CLK, E, CLR, PRE;
  reg Q;

	table

	//  D   CLK   CLR  PRE   E  NOTIFIER_REG  :   Qt  :  Qt+1

	    1   (01)    1   1    0      ?         :   ?   :   1;  // clocked data
	    0   (01)    1   1    0      ?         :   ?   :   0;  // clocked data
	    1   (01)    1   1    x      ?         :   1   :   1;  // clocked data
	    0   (01)    1   1    x      ?         :   0   :   0; 
	    0   (01)    1   1    x      ?         :   1   :   x;
	    1   (01)    1   1    x      ?         :   0   :   x;
	    0   (01)    x   1    0      ?         :   ?   :   0;  // pessimism
	    1   (01)    1   x    0      ?         :   ?   :   1;  // pessimism
	    ?    ?      1   x    ?      ?         :   1   :   1;  // pessimism
	    0    ?      1   x    ?      ?         :   x   :   x;  // pessimism
	    ?    ?      1   x    ?      ?         :   0   :   x;
	    ?    ?      x   x    ?      ?         :   ?   :   x;
	    ?    ?      x   0    ?      ?         :   ?   :   x;
	    ?    ?      x   1    ?      ?         :   0   :   0;
	    ?    ?      x   1    ?      ?         :   1   :   x;
	    ?    ?      0   ?    ?      ?         :   ?   :   0;
	    ?    ?      1   0    ?      ?         :   ?   :   1;
	    1   (x1)    1   1    0      ?         :   1   :   1;  // reducing pessimism
	    0   (x1)    1   1    0      ?         :   0   :   0;
	    1   (0x)    1   1    0      ?         :   1   :   1;
     0   (0x)    1   1    0      ?         :   0   :   0;
	    1   (x1)    1   1    x      ?         :   1   :   1;  // reducing pessimism
	    0   (x1)    1   1    x      ?         :   0   :   0;
	    1   (0x)    1   1    x      ?         :   1   :   1;
	    0   (0x)    1   1    x      ?         :   0   :   0;
	    ?  (?1)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	    ?  (0x)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	    ?   ?       ?   ?    *      ?         :   ?   :   -;
	    ?   (?0)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	    ?   (1x)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	    *    ?      ?   ?    ?      ?         :   ?   :   -;  // ignore data edges
	    ?   ?     (?1)  ?    ?      ?         :   ?   :   -;  // ignore the edges on
	    ?   ?       ?  (?1)  ?      ?         :   ?   :   -;  //       set and clear
	    ?   ?       ?   ?    ?      *         :   ?   :   x;

	endtable
 endprimitive
//---- END PRIMITIVE Dffpr ----

//---- PRIMITIVE Dffpf ----
 //---------------------------------------------------------------------
 // primitibe module (Dffpf) logic table definition
 // FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
 //            ASYNCHRONOUS SET AND CLEAR. CLR PRIORITY WHEN BOTH
 //            SET AND CLEAR ARE LOW ( Q OUTPUT UDP ).
 //            Enable active low.

 //----------------------------------------------------------------------
primitive Dffpf (Q, D, CLK, CLR, PRE, E, NOTIFIER_REG);
  output Q;
  input  NOTIFIER_REG;
  input  D, CLK, E, CLR, PRE;
  reg Q;

 table

//    D   CLK     CLR PRE  E  NOTIFIER_REG  :   Qt  :  Qt+1	
	     1   (10)    1   1    0      ?         :   ?   :   1;  // clocked data
	     0   (10)    1   1    0      ?         :   ?   :   0;  // clocked data
	     1   (10)    1   1    x      ?         :   1   :   1;  // clocked data
	     0   (10)    1   1    x      ?         :   0   :   0;
	     0   (10)    1   x    x      ?         :   1   :   1;
	     0   (10)    1   1    x      ?         :   1   :   x;
	     1   (10)    1   1    x      ?         :   0   :   x;
	     0   (10)    1   x    0      ?         :   1   :   1;
	     0   (10)    x   1    0      ?         :   ?   :   0;
	     1   (10)    1   ?    0      ?         :   ?   :   1;  // pessimism
	     1    ?      1   x    0      ?         :   1   :   1;  // pessimism
	     ?    ?      1   x    ?      ?         :   0   :   x;
	     0    1      1   x    0      ?         :   1   :   1;  // pessimism
	     0    x      1 (?x)   0      ?         :   1   :   1;  // pessimism
	     0    ?      1 (?x)   0      ?         :   1   :   1;  // baoxian
	     0    ?      x   1    ?      ?         :   0   :   0;
	     0    ?      x   0    ?      ?         :   ?   :   x;
	     0    ?      x   1    ?      ?         :   1   :   x;
	     x    1      1   x    0      ?         :   1   :   1;  // pessimism
	     x    x      1 (?x)   0      ?         :   1   :   1;  // pessimism
	     x    0      1   x    0      ?         :   1   :   1;  // pessimism
	     1    ?      1   x    x      ?         :   1   :   1;  // pessimism
	     0    1      1   x    x      ?         :   1   :   1;  // pessimism
	     0    x      1 (?x)   x      ?         :   1   :   1;  // pessimism
	     0    0      1 (?x)   x      ?         :   1   :   1;  // pessimism
	     x    1      1   x    x      ?         :   1   :   1;  // pessimism
	     x    ?      1   x    x      ?         :   1   :   1;  // pessimism
	     1    0      x   1    0      ?         :   0   :   0;  // pessimism
	     1    x    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     1    1    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     x    0      x   1    0      ?         :   0   :   0;  // pessimism
	     x    x    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     x    1    (?x)  1    0      ?         :   0   :   0;  // pessimism
	     1    0      x   1    x      ?         :   0   :   0;  // pessimism
	     1    x    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     1    1    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     x    0      x   1    x      ?         :   0   :   0;  // pessimism
	     x    x    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     x    1    (?x)  1    x      ?         :   0   :   0;  // pessimism
	     1   (1x)    1   1    0      ?         :   1   :   1;  // reducing pessimism
	     0   (1x)    1   1    0      ?         :   0   :   0;
	     1   (x0)    1   1    0      ?         :   1   :   1;
	     0   (x0)    1   1    0      ?         :   0   :   0;
	     1   (1x)    1   1    x      ?         :   1   :   1;  // reducing pessimism
	     0   (1x)    1   1    x      ?         :   0   :   0;
	     1   (x0)    1   1    x      ?         :   1   :   1;
	     0   (x0)    1   1    x      ?         :   0   :   0;
	     ?   ?       0   1    ?      ?         :   ?   :   0;  // asynchronous clear
	     ?   ?       1   0    ?      ?         :   ?   :   1;  // asynchronous set
	     ?  (?0)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	     ?  (1x)     1   1    1      ?         :   ?   :   -;  //no action for CE = 1
	     ?   (?0)    x   1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?   (1x)    x   1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?    ?    (?x)  1    1      ?         :   0   :   0;  // chip is not enabled pessimism with reset
	     ?   (?0)    1   x    1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?   (1x)    1   x    1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?    ?      1  (?x)  1      ?         :   1   :   1;  // chip is not enabled pessimism with reset
	     ?   ?       ?   ?    *      ?         :   ?   :   -;
	     ?   (?1)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	     ?   (0x)    ?   ?    ?      ?         :   ?   :   -;  // ignore falling clock
	     *    ?      ?   ?    ?      ?         :   ?   :   -;  // ignore data edges
	     ?   ?     (?1)  ?    ?      ?         :   ?   :   -;  // ignore the edges on
	     ?   ?       ?  (?1)  ?      ?         :   ?   :   -;  //       set and clear
	     ?   ?       0   0    ?      ?         :   ?   :   0; // CLR Priority (added 0n 11/12/97)
	     ?   ?       0   x    ?      ?         :   ?   :   0; // CLR Priority (added 0n 11/12/97)
	     ?   ?       ?   ?    ?      *         :   ?   :   x;
	endtable
 endprimitive
//---- END PRIMITIVE Dffpf ----

//---- PRIMITIVE UFPRB ----
//--------------------------------------------------------------------
//-                    cell  UFPRB.v                                  -
//--------------------------------------------------------------------

primitive UFPRB (Q, D, CP, RB, NOTIFIER_REG);

    output Q;
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q;

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).

    table
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1

        1   (01)    1         ?          :   ?   :   1;  // clocked data
        0   (01)    1         ?          :   ?   :   0;

        0   (01)    x         ?          :   ?   :   0;  // pessimism
        0    ?      x         ?          :   0   :   0;  // pessimism

        1    0      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    1    (?x)        ?          :   0   :   0;  // pessimism
        x    0      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    1    (?x)        ?          :   0   :   0;  // pessimism
        1   (x1)    1         ?          :   1   :   1;  // reducing pessimism
        0   (x1)    1         ?          :   0   :   0;
        1   (0x)    1         ?          :   1   :   1;
        0   (0x)    1         ?          :   0   :   0;
        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear
        ?   (?0)    ?         ?          :   ?   :   -;  // ignore falling clock
        ?   (1x)    ?         ?          :   ?   :   -;  // ignore falling clock
        *    ?      ?         ?          :   ?   :   -;  // ignore the edges on data
        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear
        ?    ?      ?         *          :   ?   :   x;
    endtable
endprimitive
//---- END PRIMITIVE UFPRB ----

//---- PRIMITIVE UFNRB ----
//--------------------------------------------------------------------
//-                    cell  UFNRB.v                                  -
//--------------------------------------------------------------------
primitive UFNRB (Q, D, CP, RB, NOTIFIER_REG);
    output Q;
    input  NOTIFIER_REG,
           D, CP, RB;
    reg    Q;
// FUNCTION : NEGATIVE EDGE TRIGGERED D FLIP-FLOP WITH ACTIVE LOW
//            ASYNCHRONOUS CLEAR ( Q OUTPUT UDP ).
    table
    //  D   CP      RB     NOTIFIER_REG  :   Qt  :   Qt+1
        1   (10)    1         ?          :   ?   :   1;  // clocked data
        0   (10)    1         ?          :   ?   :   0;
        0   (10)    x         ?          :   ?   :   0;  // pessimism
        0    ?      x         ?          :   0   :   0;  // pessimism
        1    1      x         ?          :   0   :   0;  // pessimism
        1    x    (?x)        ?          :   0   :   0;  // pessimism
        1    0    (?x)        ?          :   0   :   0;  // pessimism
        x    1      x         ?          :   0   :   0;  // pessimism
        x    x    (?x)        ?          :   0   :   0;  // pessimism
        x    0    (?x)        ?          :   0   :   0;  // pessimism
        1   (1x)    1         ?          :   1   :   1;  // reducing pessimism
        0   (1x)    1         ?          :   0   :   0;
        1   (x0)    1         ?          :   1   :   1;
        0   (x0)    1         ?          :   0   :   0;
        ?   ?       0         ?          :   ?   :   0;  // asynchronous clear
        ?   (?1)    ?         ?          :   ?   :   -;  // ignore falling clock
        ?   (0x)    ?         ?          :   ?   :   -;  // ignore falling clock
        *    ?      ?         ?          :   ?   :   -;  // ignore the edges on data
        ?    ?    (?1)        ?          :   ?   :   -;  // ignore the edges on clear
        ?    ?      ?         *          :   ?   :   x;
    endtable
endprimitive
//---- END PRIMITIVE UFNRB ----

//---- PRIMITIVE DL2C_UDP ----
//------------------------------------------------------------------------
// primitive DL2C_UDP functional description
// FUNCTION : NEGATIVE LEVEL SENSITIVE D-TYPE LATCH WITH ACTIVE HIGH
//            ASYNCHRONOUS SET AND RESET.
//-------------------------------------------------------------------------


primitive DL2C_UDP (q, d, g, c, p, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        g,              // CLOCK
        c,              // CLEAR ACTIVE HIGH
        p,              // SET ACTIVE HIGH
        NOTIFIER_REG;

 reg q;

    table
    //  D     G     C     P  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     1     ?     ?          :   ?   :   0;  // active low clear
        ?     ?     0     1     ?          :   ?   :   1;  // active high preset

        ?     1     0     0     ?          :   ?   :   -;  // latch
        0     0     0     0     ?          :   ?   :   0;  // transparent

        0     0     x     0     ?          :   ?   :   0;  // CLR==x
        ?     1     x     0     ?          :   0   :   0;  // CLR==x
        0     x     ?     0     ?          :   0   :   0;  // CLR,G==x

        1     x     0     ?     ?          :   1   :   1;  // PRE==x/?,G==x
        1     0     0     ?     ?          :   ?   :   1;  // PRE==x/?
        ?     1     0     x     ?          :   1   :   1;  // PRE==x
    endtable


endprimitive
//---- END PRIMITIVE DL2C_UDP ----

//---- PRIMITIVE DLE3B_UDP ----
//--------------------------------------------------------------------------
// primitive DLE3B_UDP
// FUNCTION : D LATCH WITH DUAL CLOCK INPUTS ACTIVE HIGH ASYNCHRONOUS PRESET.
//            TWO CLOCKS: E G
//-------------------------------------------------------------------------

primitive DLE3B_UDP (q, d, g, e, p, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        g,              // CLOCK
        e,              // CLEAR ACTIVE HIGH
        p,              // SET ACTIVE HIGH
        NOTIFIER_REG;

 reg    q;

    table
    //  D     G     E     P  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     ?     1     ?          :   ?   :   1;  // active high preset

        ?     1     ?     0     ?          :   ?   :   -;  // latch
        ?     ?     1     0     ?          :   ?   :   -;  // latch

        1     0     0     0     ?          :   ?   :   1;  // transparent
        0     0     0     0     ?          :   ?   :   0;  // transparent

        1     x     ?     0     ?          :   1   :   1;  // o/p mux pessimism
        1     ?     x     0     ?          :   1   :   1;  // o/p mux pessimism
        0     x     ?     0     ?          :   0   :   0;  // o/p mux pessimism
        0     ?     x     0     ?          :   0   :   0;  // o/p mux pessimism

        1     0     0     x     ?          :   ?   :   1;  // PRE==x
        ?     1     ?     x     ?          :   1   :   1;  // PRE==x
        ?     ?     1     x     ?          :   1   :   1;  // PRE==x
        1     0     x     x     ?          :   1   :   1;  // PRE==x
        1     x     0     x     ?          :   1   :   1;  // PRE==x
        1     x     x     x     ?          :   1   :   1;  // PRE==x
    endtable

endprimitive
//---- END PRIMITIVE DLE3B_UDP ----

//---- PRIMITIVE DLE2B_UDP ----
//--------------------------------------------------------------------------
// primitive DLE2B_UDP
// FUNCTION : D LATCH WITH DUAL CLOCK INPUTS ACTIVE HIGH ASYNCHRONOUS CLEAR.
//            TWO CLOCKS: E G
//-------------------------------------------------------------------------

primitive DLE2B_UDP (q, d, e, g, c, NOTIFIER_REG);

 output q;
 input  d,              // DATA
        e,              // CLOCK
        g,              // CLOCK
        c,              // CLEAR ACTIVE HIGH
        NOTIFIER_REG;

 reg    q;

    table
    //  D     E     G     C  NOTIFIER_REG  :   Qt  :   Qt+1
        ?     ?     ?     0     ?          :   ?   :   0;  // active low clear

        ?     ?     1     1     ?          :   ?   :   -;  // latch
        ?     1     ?     1     ?          :   ?   :   -;  // latch

        1     0     0     1     ?          :   ?   :   1;  // transparent
        0     0     0     1     ?          :   ?   :   0;  // transparent

        0     ?     ?     1     ?          :   0   :   0;  // o/p mux pessimism
        1     ?     ?     1     ?          :   1   :   1;  // o/p mux pessimism

        0     ?     ?     x     ?          :   0   :   0;  // CLR==x, o/p mux pessimism
        ?     ?     1     x     ?          :   0   :   0;  // PRE==x, o/p mux pessimism, latch
        ?     1     ?     x     ?          :   0   :   0;  // PRE==x, o/p mux pessimism, latch
        0     0     0     x     ?          :   ?   :   0;  // PRE==x, o/p mux pessimism
    endtable

endprimitive
//---- END PRIMITIVE DLE2B_UDP ----

//---- PRIMITIVE JKFFF ----
//--------------------------------------------------------------------
//-                 primitive  JKFFF  -- falling edge                -
//--------------------------------------------------------------------

primitive JKFFF (Q, J, K, CP, RB, SB, NOTIFIER_REG);
    output Q;
    reg    Q; 
    input  NOTIFIER_REG,
           J,K,
            CP,                                  // Clock.
            RB,                                  // Clear input
            SB;                                  // Set input
// FUNCTION :NEGATIVE EDGE TRIGGERED JK FLIP FLOP, WITH ACTIVE LOW
//           ASYNCHRONOUS CLEAR AND  SET
//           OUTPUT GOES TO X WHEN BOTH CLEAR AND SET ARE ACTIVE
    table
      // J   K   CP  RB   SB       NOTIFIER_REG  : Qtn : Qtn+1
         0   1  (10) 1    1           ?          :  ?  :   - ;    // Output retains the
         0   0  (10) 1    1           ?          :  ?  :   0 ;    // Clocked J and K.
         0   0  (10) x    1           ?          :  ?  :   0 ;    // pessimism
         ?   ?   ?   x    1           ?          :  0  :   0 ;    // pessimism
         1   1  (10) 1    1           ?          :  ?  :   1 ;
         1   1  (10) 1    x           ?          :  ?  :   1 ;    // pessimism
         ?   ?   ?   1    x           ?          :  1  :   1 ;    // pessimis
         1   0  (10) 1    1           ?          :  0  :   1 ;    // Clocked toggle.
         1   0  (10) 1    1           ?          :  1  :   0 ;
         ?   0  (10) x    1           ?          :  1  :   0 ;    //pessimism
         1   ?  (10) 1    x           ?          :  0  :   1 ;
         0   1  (1x) 1    1           ?          :  ?  :   - ;    //possible clocked JK
         0   0  (1x) 1    1           ?          :  0  :   0 ;
         1   1  (1x) 1    1           ?          :  1  :   1 ;
         0   1  (x0) 1    1           ?          :  ?  :   - ;
         0   0  (x0) 1    1           ?          :  0  :   0 ;
         1   1  (x0) 1    1           ?          :  1  :   1 ;
         *   ?   ?   1    1           ?          :  ?  :   - ;    // Insensitive to
         ?   *   ?   1    1           ?          :  ?  :   - ;    // transitions on J and K
         ?   ?   ?   0    1           ?          :  ?  :   0 ;    // Clear
         ?   ?   ?   1    0           ?          :  ?  :   1 ;    // Set.
         ?   ?   ?   0    0           ?          :  ?  :   x ;    // ILLEGAL
         x   1   f   1    1           ?          :  1  :   1 ;
         x   0   f   1    1           ?          :  1  :   0 ;
         0   x   f   1    1           ?          :  0  :   0 ;
         1   x   f   1    1           ?          :  0  :   1 ;
         x   1 (1x)  1    1           ?          :  1  :   1 ;    //possible clocked with
         0   x (1x)  1    1           ?          :  0  :   0 ;    //possible J & K
         x   1 (x0)  1    1           ?          :  1  :   1 ;
         0   x (x0)  1    1           ?          :  0  :   0 ;
         ?   ? (?1)  ?    ?           ?          :  ?  :   - ;
         ?   ? (0x)  ?    ?           ?          :  ?  :   - ;
         ?   ?   ? (?1)   1           ?          :  ?  :   - ;    //ignore changes on set and
         ?   ?   ?   1  (?1)          ?          :  ?  :   - ;    //reset.
         ?   ?   ?   ?    ?           *          :  ?  :   x ;
    endtable
endprimitive
//---- END PRIMITIVE JKFFF ----

//---- PRIMITIVE JKFFR ----
//--------------------------------------------------------------------
//-                   primitive  JKFFR                                -
//--------------------------------------------------------------------
primitive JKFFR (Q, J, K, CP, RB, SB, NOTIFIER_REG);
    output Q;
    reg    Q; 
    input  NOTIFIER_REG,
           J,K,
           CP,                                  // Clock.
           RB,                                  // Clear input
           SB;                                  // Set input
// FUNCTION :POSITIVE EDGE TRIGGERED JK FLIP FLOP, WITH ACTIVE LOW
//           ASYNCHRONOUS CLEAR AND  SET
//           OUTPUT GOES TO x WHEN BOTH CLEAR AND SET ARE ACTIVE
    table
      // J   K  CP  RB   SB        NOTIFIER_REG  : Qtn : Qtn+1
         0   1  (01) 1    1           ?          :  ?  :   - ;    // Output retains the
         0   0  (01) 1    1           ?          :  ?  :   0 ;    // Clocked J and K.
         0   0  (01) x    1           ?          :  ?  :   0 ;    // pessimism
         ?   ?   ?   x    1           ?          :  0  :   0 ;    // pessimism
         1   1  (01) 1    1           ?          :  ?  :   1 ;
         1   1  (01) 1    x           ?          :  ?  :   1 ;    // pessimism
         ?   ?   ?   1    x           ?          :  1  :   1 ;    // pessimism
         1   0  (01) 1    1           ?          :  0  :   1 ;    // Clocked toggle.
         1   0  (01) 1    1           ?          :  1  :   0 ;
         ?   0  (01) x    1           ?          :  1  :   0 ;     //pessimism
         1   ?  (01) 1    x           ?          :  0  :   1 ;
         0   1  (x1) 1    1           ?          :  ?  :   - ;   //possible clocked JK
         0   0  (x1) 1    1           ?          :  0  :   0 ;
         1   1  (x1) 1    1           ?          :  1  :   1 ;
         0   1  (0x) 1    1           ?          :  ?  :   - ;
         0   0  (0x) 1    1           ?          :  0  :   0 ;
         1   1  (0x) 1    1           ?          :  1  :   1 ;
         *   ?   ?   1    1           ?          :  ?  :   - ;    // Insensitive to
         ?   *   ?   1    1           ?          :  ?  :   - ;    // transitions on J and K
         ?   ?   ?   0    1           ?          :  ?  :   0 ;    // Clear
         ?   ?   ?   1    0           ?          :  ?  :   1 ;    // Set.
         ?   ?   ?   0    0           ?          :  ?  :   x ;    // ILLEGAL
         x   1   r   1    1           ?          :  1  :   1 ;
         x   0   r   1    1           ?          :  1  :   0 ;
         0   x   r   1    1           ?          :  0  :   0 ;
         1   x   r   1    1           ?          :  0  :   1 ;
         x   1 (x1)  1    1           ?          :  1  :   1 ;        //possible clocked with
         0   x (x1)  1    1           ?          :  0  :   0 ;        //possible J & K
         x   1 (0x)  1    1           ?          :  1  :   1 ;
         0   x (0x)  1    1           ?          :  0  :   0 ;
         ?   ? (?0)  1    1           ?          :  ?  :   - ;    //ignore falling clock.
         ?   ? (1x)  1    1           ?          :  ?  :   - ;
         ?   ?   ? (?1)   1           ?          :  ?  :   - ;    //ignore changes on set and
         ?   ?   ?   1  (?1)          ?          :  ?  :   - ;    //reset.
         ?   ?   ?   ?    ?           *          :  ?  :   x ;
    endtable
endprimitive
//---- END PRIMITIVE JKFFR ----

//---- PRIMITIVE UDP_MUX2 ----
 // --------------------------------------------------------------------
 // 2-1 MUX  primitive   
 // FUNCTION : when select signal S= 1, A will be selected, S= 0, B will 
 //            be selected; when S=X, if A=B, A will be selected, if A!=B,
 //            X will be the output!
 // --------------------------------------------------------------------
primitive UDP_MUX2 (Q, A, B, SL);
output Q;
input A, B, SL;

// FUNCTION :  TWO TO ONE MULTIPLEXER

    table
    //  A   B   SL  :   Q
        0   0   ?   :   0 ;
        1   1   ?   :   1 ;

        0   ?   1   :   0 ;
        1   ?   1   :   1 ;

        ?   0   0   :   0 ;
        ?   1   0   :   1 ;

    endtable
endprimitive
//---- END PRIMITIVE UDP_MUX2 ----

//---- PRIMITIVE UDPN_MUX2 ----
primitive UDPN_MUX2 (Q, A, B, SL);
output Q;
input A, B, SL;

// FUNCTION :  TWO TO ONE MULTIPLEXER

    table
    //  A   B   SL  :   Q
        0   0   ?   :   1 ;
        1   1   ?   :   0 ;

        0   ?   1   :   1 ;
        1   ?   1   :   0 ;

        ?   0   0   :   1 ;
        ?   1   0   :   0 ;

    endtable
endprimitive
//---- END PRIMITIVE UDPN_MUX2 ----

`timescale 1 ps/1 ps

module drive_analog_input ( parallel_in, serial_out );

  input  [63:0]  parallel_in;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 )
     begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule

module drive_analog_input_varef ( parallel_in, ADC_varef_sel, serial_out );

  input  [63:0]  parallel_in;
  input          ADC_varef_sel;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( negedge ADC_varef_sel )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 )
     begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule

`timescale 1 ps/1 ps

module drive_current_inputs ( current_vect, resistor_vect, temp_vect, ac, at );

  input  [63:0]  temp_vect;
  input  [63:0]  resistor_vect;
  input  [63:0]  current_vect;
  output         at;
  output         ac;

  reg            at = 1'bz;
  reg            ac = 1'bz;

  integer        i, j;

  reg   [63:0]  ac_vect;
  event start_transmit; 

  always @ (*)
  begin
    ac_vect = ( ( $bitstoreal( resistor_vect ) < 0.0001 ) ||
		( $bitstoreal( resistor_vect ) > 1000 ) ) ? 64'd0 :
	      $realtobits( $bitstoreal( temp_vect ) +
			   ( $bitstoreal( resistor_vect ) * $bitstoreal( current_vect ) ) );
   -> start_transmit;	       
  end	  

// Start transmit is used to synchronise the transmission of ac_vect and
// av_vect   
//   always @( ac_vect )
  always @( start_transmit )
  begin
    #0;
    for ( i = 0; i < 64; i = i+1 ) begin
      ac = ac_vect[i];
      #0;
      ac = 1'bx;
      #0;
    end
    ac = 1'bz;
  end

//  always@( temp_vect )
  always @( start_transmit )
  begin
    #0;
    for ( j = 0; j < 64; j = j+1 ) begin
      at = temp_vect[j];
      #0;
      at = 1'bx;
      #0;
    end
    at = 1'bz;
  end

endmodule
//---- END MODULE drive_current_inputs ----

//---- MODULE drive_differential_inputs ----
/*--------------------------------------------------------------------
 CELL NAME : drive_differential_inputs
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_differential_inputs ( volt_vect, delta_vect, av, ac );

  input  [63:0]  volt_vect;
  input  [63:0]  delta_vect;
  output         av;
  output         ac;

  reg            av = 1'bz;
  reg            ac = 1'bz;

  integer        i, j;
  wire   [63:0]  ac_vect;

  assign ac_vect = $realtobits( $bitstoreal( volt_vect ) - ( $bitstoreal( delta_vect ) ) );

  always @( ac_vect )
  begin
    #0;
    for ( i = 0; i < 64; i = i+1 ) begin
      ac = ac_vect[i];
      #0;
      ac = 1'bx;
      #0;
    end
    ac = 1'bz;
  end

  always @( volt_vect )
  begin
    #0;
    for ( j = 0; j < 64; j = j+1 ) begin
      av = volt_vect[j];
      #0;
      av = 1'bx;
      #0;
    end
    av = 1'bz;
  end

endmodule
//---- END MODULE drive_differential_inputs ----

`timescale 1 ps/1 ps

module drive_varef_out ( parallel_in, en_out, serial_out );

  input  [63:0]  parallel_in;
  input          en_out;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    if ( en_out == 1'b1 ) begin
      #0;
      for ( i=0; i<=63; i=i+1 ) begin
        serial_out = parallel_in[i];
        #0;
        serial_out = 1'bx;
        #0;
        if ( i == 63 )
          serial_out = 1'bz;
      end
    end
  end

endmodule

//---- MODULE drive_analog_io ----
/*--------------------------------------------------------------------
 CELL NAME : drive_analog_io
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module drive_analog_io ( parallel_in, serial_out );

  input  [63:0]  parallel_in;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule
//---- END MODULE drive_analog_io ----

`timescale 1 ps/1 ps

module drive_current_monitor ( temp_vect, resistor_vect, current_vect, serial_out );

  input  [63:0]  temp_vect;
  input  [63:0]  resistor_vect;
  input  [63:0]  current_vect;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;
  wire   [63:0]  parallel_in;

  assign parallel_in = ( ( $bitstoreal(resistor_vect) < 0.0001 ) ||
			 ( $bitstoreal(resistor_vect) > 1000 ) ) ? 64'd0 :
		       $realtobits( $bitstoreal(temp_vect) +
				    ( $bitstoreal(resistor_vect) * $bitstoreal(current_vect) ) );

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) 
     begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule

`timescale 1 ps/1 ps

module drive_temperature_quad ( temp_celsius, serial_out );


  input  [63:0]  temp_celsius;
  output         serial_out;

  reg            serial_out=1'bz;
  integer        i;
  wire   [63:0]  parallel_in;

  //assign parallel_in = $realtobits( ( $bitstoreal(temp_celsius) + 273.15 ) * ( 2.30258 * 0.000087248 ) );
  assign parallel_in = $realtobits( ( $bitstoreal(temp_celsius) + 273.15 ) * ( 2.30258 * 0.000086869213 ) );

  always @ ( parallel_in )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      serial_out = parallel_in[i];
      #0;
      serial_out = 1'bx;
      #0;
      if ( i == 63 )
        serial_out = 1'bz;
    end
  end

endmodule

//---- MODULE read_analog_input ----
/*--------------------------------------------------------------------
 CELL NAME : read_analog_input
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module read_analog_input ( serial_in, read_enb, parallel_out );

  input          serial_in;
  input          read_enb;
  output [63:0]  parallel_out;

  // instantiate read_analog_io module that is already defined 

  read_analog_io read_analog_io_inst ( .serial_in    ( serial_in    ),
                                       .read_enb     ( read_enb     ),
                                       .parallel_out ( parallel_out )
                                     ); 

endmodule
//---- END MODULE read_analog_input ----

module read_analog_io ( serial_in, read_enb, parallel_out );
  input          serial_in;
  input          read_enb;
  output reg [63:0]  parallel_out;
  reg    [63:0]  parallel_out_temp;
  integer        i=0;
 
  always @ ( serial_in )
  begin
    if ( read_enb == 1'b0 )
     begin
    //  if (i == 0)
    //	 parallel_out = 64'd0 ;     
      if ( serial_in !== 1'bz && serial_in !== 1'bx && i < 64 ) 
       begin //{
        parallel_out_temp [i] = serial_in;
        i = i + 1;
	if ( i == 64 ) begin
          i = 0;
          parallel_out = parallel_out_temp;
 	 end
       end  //}
     end
  end

endmodule

//---- MODULE AND2 ----
/*--------------------------------------------------------------------
 CELL NAME : AND2
 CELL TYPE : comb
 CELL LOGIC : Y = A & B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2(Y,A,B);
 input A,B;
 output Y;

 and      U2(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2 ----

//---- MODULE AND2A ----
/*--------------------------------------------------------------------
 CELL NAME : AND2A
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_0(A_, A);
 and      U5(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2A ----

//---- MODULE AND2B ----
/*--------------------------------------------------------------------
 CELL NAME : AND2B
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_1(A_, A);
 not	INV_2(B_, B);
 and      U8(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND2B ----

//---- MODULE AND3 ----
/*--------------------------------------------------------------------
 CELL NAME : AND3
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U15(NET_0_0, A, B);
 and      U16(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3 ----

//---- MODULE AND3A ----
/*--------------------------------------------------------------------
 CELL NAME : AND3A
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_4(A_, A);
 and      U20(NET_0_0, A_, B);
 and      U21(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3A ----

//---- MODULE AND3B ----
/*--------------------------------------------------------------------
 CELL NAME : AND3B
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_5(A_, A);
 not	INV_6(B_, B);
 and      U25(NET_0_0, A_, B_);
 and      U26(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3B ----

//---- MODULE AND3C ----
/*--------------------------------------------------------------------
 CELL NAME : AND3C
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AND3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_7(A_, A);
 not	INV_8(B_, B);
 not	INV_9(C_, C);
 and      U30(NET_0_0, A_, B_);
 and      U31(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AND3C ----

//---- MODULE AO12 ----
/*--------------------------------------------------------------------
 CELL NAME : AO12
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + !A & !C + A & !B & C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO12(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_13(A_, A);
 not	INV_14(B_, B);
 not	INV_15(C_, C);
 UDP_MUX2   U56(NET_0_5, B, NET_0_3, C_);
 and      U59(NET_0_3, A, B_);
 or       U60(Y, NET_0_5, NET_0_2);
 and      U63(NET_0_0, A_, B);
 or       U64(NET_0_2, NET_0_0, NET_0_1);
 and      U66(NET_0_1, A_, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO12 ----

//---- MODULE AO13 ----
/*--------------------------------------------------------------------
 CELL NAME : AO13
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + A & !C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO13(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_16(C_, C);
 and      U71(NET_0_0, A, B);
 or       U72(NET_0_2, NET_0_0, NET_0_1);
 and      U74(NET_0_1, A, C_);
 or       U75(Y, NET_0_2, NET_0_3);
 and      U77(NET_0_3, B, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO13 ----

//---- MODULE AO14 ----
/*--------------------------------------------------------------------
 CELL NAME : AO14
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + A & !C + B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO14(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_17(A_, A);
 not	INV_18(B_, B);
 not	INV_19(C_, C);
 and      U82(NET_0_5, A_, B_);
 UDP_MUX2   U83(NET_0_4, NET_0_5, B, C);
 or       U85(Y, NET_0_4, NET_0_2);
 and      U88(NET_0_0, A, B);
 or       U89(NET_0_2, NET_0_0, NET_0_1);
 and      U91(NET_0_1, A, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO14 ----

//---- MODULE AO15 ----
/*--------------------------------------------------------------------
 CELL NAME : AO15
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B & C + !A & B & C + !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO15(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_20(A_, A);
 not	INV_21(B_, B);
 not	INV_22(C_, C);
 and      U96(NET_0_0, A, B_);
 UDP_MUX2   U97(NET_0_4, NET_0_0, NET_0_5, C);
 and      U100(NET_0_5, A_, B_);
 or       U101(Y, NET_0_4, NET_0_3);
 and      U104(NET_0_2, A_, B);
 and      U105(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO15 ----

//---- MODULE AO16 ----
/*--------------------------------------------------------------------
 CELL NAME : AO16
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO16(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_23(A_, A);
 not	INV_24(B_, B);
 not	INV_25(C_, C);
 and      U109(NET_0_0, A, B);
 UDP_MUX2   U110(Y, NET_0_0, NET_0_2, C_);
 and      U113(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO16 ----

//---- MODULE AO17 ----
/*--------------------------------------------------------------------
 CELL NAME : AO17
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C + !A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO17(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_26(A_, A);
 not	INV_27(B_, B);
 not	INV_28(C_, C);
 and      U118(NET_0_5, A_, B_);
 UDP_MUX2   U119(NET_0_4, NET_0_5, NET_0_2, C);
 and      U122(NET_0_2, A_, B);
 or       U123(Y, NET_0_4, NET_0_1);
 and      U126(NET_0_0, A, B);
 and      U127(NET_0_1, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO17 ----

//---- MODULE AO18 ----
/*--------------------------------------------------------------------
 CELL NAME : AO18
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + !A & !C + B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO18(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_29(A_, A);
 not	INV_30(C_, C);
 and      U132(NET_0_0, A_, B);
 or       U133(NET_0_2, NET_0_0, NET_0_1);
 and      U135(NET_0_1, A_, C_);
 or       U136(Y, NET_0_2, NET_0_3);
 and      U138(NET_0_3, B, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO18 ----

//---- MODULE AO1 ----
/*--------------------------------------------------------------------
 CELL NAME : AO1
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U142(NET_0_0, A, B);
 or       U143(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1 ----

//---- MODULE AO1A ----
/*--------------------------------------------------------------------
 CELL NAME : AO1A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_31(A_, A);
 and      U147(NET_0_0, A_, B);
 or       U148(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1A ----

//---- MODULE AO1B ----
/*--------------------------------------------------------------------
 CELL NAME : AO1B
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_32(C_, C);
 and      U152(NET_0_0, A, B);
 or       U153(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1B ----

//---- MODULE AO1C ----
/*--------------------------------------------------------------------
 CELL NAME : AO1C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_33(A_, A);
 not	INV_34(C_, C);
 and      U157(NET_0_0, A_, B);
 or       U158(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1C ----

//---- MODULE AO1D ----
/*--------------------------------------------------------------------
 CELL NAME : AO1D
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_35(A_, A);
 not	INV_36(B_, B);
 and      U162(NET_0_0, A_, B_);
 or       U163(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1D ----

//---- MODULE AO1E ----
/*--------------------------------------------------------------------
 CELL NAME : AO1E
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AO1E(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_37(A_, A);
 not	INV_38(B_, B);
 not	INV_39(C_, C);
 and      U167(NET_0_0, A_, B_);
 or       U168(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AO1E ----

//---- MODULE AOI1 ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U192(NET_0_0, A, B);
 nor      U193(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1 ----

//---- MODULE AOI1A ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_44(A_, A);
 and      U197(NET_0_0, A_, B);
 nor      U198(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1A ----

//---- MODULE AOI1B ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1B
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_45(C_, C);
 and      U202(NET_0_0, A, B);
 nor      U203(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1B ----

//---- MODULE AOI1C ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_46(A_, A);
 not	INV_47(B_, B);
 and      U207(NET_0_0, A_, B_);
 nor      U208(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1C ----

//---- MODULE AOI1D ----
/*--------------------------------------------------------------------
 CELL NAME : AOI1D
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_48(A_, A);
 not	INV_49(B_, B);
 not	INV_50(C_, C);
 and      U212(NET_0_0, A_, B_);
 nor      U213(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI1D ----

//---- MODULE AOI5 ----
/*--------------------------------------------------------------------
 CELL NAME : AOI5
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B & C + A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AOI5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_54(A_, A);
 not	INV_55(B_, B);
 not	INV_56(C_, C);
 and      U237(NET_0_0, A_, B);
 UDPN_MUX2  U238(Y, NET_0_0, NET_0_2, C);
 and      U241(NET_0_2, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AOI5 ----

//---- MODULE AX1 ----
/*--------------------------------------------------------------------
 CELL NAME : AX1
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_57(A_, A);
 and      U245(NET_0_0, A_, B);
 xor      U246(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1 ----

//---- MODULE AX1A ----
/*--------------------------------------------------------------------
 CELL NAME : AX1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_58(A_, A);
 and      U250(NET_0_0, A_, B);
 xnor     U251(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1A ----

//---- MODULE AX1B ----
/*--------------------------------------------------------------------
 CELL NAME : AX1B
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_59(A_, A);
 not	INV_60(B_, B);
 and      U255(NET_0_0, A_, B_);
 xor      U256(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1B ----

//---- MODULE AX1C ----
/*--------------------------------------------------------------------
 CELL NAME : AX1C
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U260(NET_0_0, A, B);
 xor      U261(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1C ----

//---- MODULE AX1D ----
/*--------------------------------------------------------------------
 CELL NAME : AX1D
 CELL TYPE : comb
 CELL LOGIC : Y = !((!A & !B) ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1D(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_61(A_, A);
 not	INV_62(B_, B);
 and      U265(NET_0_0, A_, B_);
 xnor     U266(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1D ----

//---- MODULE AX1E ----
/*--------------------------------------------------------------------
 CELL NAME : AX1E
 CELL TYPE : comb
 CELL LOGIC : Y = !((A & B) ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AX1E(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U270(NET_0_0, A, B);
 xnor     U271(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AX1E ----

//---- MODULE AXO1 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO1
 CELL TYPE : comb
 CELL LOGIC : Y = A & B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_63(B_, B);
 not	INV_64(C_, C);
 and      U275(NET_0_1_XOR_REXT, B, C_);
 or       U276(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U278(NET_0_1, C, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO1 ----

//---- MODULE AXO2 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO2
 CELL TYPE : comb
 CELL LOGIC : Y = !A & B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO2(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_65(A_, A);
 not	INV_66(B_, B);
 not	INV_67(C_, C);
 and      U283(NET_0_1_XOR_REXT, B, C_);
 or       U284(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U286(NET_0_1, C, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO2 ----

//---- MODULE AXO3 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO3
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_68(B_, B);
 not	INV_69(C_, C);
 and      U291(NET_0_1_XOR_LEXT, B_, C);
 or       U292(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U294(NET_0_1, A, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO3 ----

//---- MODULE AXO5 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO5
 CELL TYPE : comb
 CELL LOGIC : Y =  !A & B + (!B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_70(A_, A);
 not	INV_71(B_, B);
 not	INV_72(C_, C);
 and      U299(NET_0_1_XOR_LEXT, B, C);
 or       U300(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U302(NET_0_1, A_, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO5 ----

//---- MODULE AXO6 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO6
 CELL TYPE : comb
 CELL LOGIC : Y =  A & !B + (!B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO6(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_73(B_, B);
 not	INV_74(C_, C);
 and      U307(NET_0_1_XOR_REXT, B_, C_);
 or       U308(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U310(NET_0_1, C, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO6 ----

//---- MODULE AXO7 ----
/*--------------------------------------------------------------------
 CELL NAME : AXO7
 CELL TYPE : comb
 CELL LOGIC : Y =  !A & !B + (B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXO7(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_75(A_, A);
 not	INV_76(B_, B);
 not	INV_77(C_, C);
 and      U315(NET_0_1_XOR_LEXT, B_, C);
 or       U316(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U318(NET_0_1, A_, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXO7 ----

//---- MODULE AXOI1 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI1
 CELL TYPE : comb
 CELL LOGIC : Y =  !(A & B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_78(B_, B);
 not	INV_79(C_, C);
 and      U323(NET_0_1_XOR_REXT, B, C_);
 nor      U324(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U326(NET_0_1, C, A, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI1 ----

//---- MODULE AXOI2 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI2
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI2(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_80(A_, A);
 not	INV_81(B_, B);
 not	INV_82(C_, C);
 and      U331(NET_0_1_XOR_REXT, B, C_);
 nor      U332(Y, NET_0_1_XOR_REXT, NET_0_1);
 UDP_MUX2   U334(NET_0_1, C, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI2 ----

//---- MODULE AXOI3 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & !B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_83(B_, B);
 not	INV_84(C_, C);
 and      U339(NET_0_1_XOR_LEXT, B_, C);
 nor      U340(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U342(NET_0_1, A, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI3 ----

//---- MODULE AXOI4 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI4
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B + (!B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI4(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_85(B_, B);
 not	INV_86(C_, C);
 and      U347(NET_0_1_XOR_LEXT, B, C);
 nor      U348(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U350(NET_0_1, A, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI4 ----

//---- MODULE AXOI5 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI5
 CELL TYPE : comb
 CELL LOGIC : Y =  !(!A & B + (!B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI5(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_87(A_, A);
 not	INV_88(B_, B);
 not	INV_89(C_, C);
 and      U355(NET_0_1_XOR_LEXT, B, C);
 nor      U356(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U358(NET_0_1, A_, C_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI5 ----

//---- MODULE AXOI7 ----
/*--------------------------------------------------------------------
 CELL NAME : AXOI7
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B + (B ^ C))
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module AXOI7(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_90(A_, A);
 not	INV_91(B_, B);
 not	INV_92(C_, C);
 and      U363(NET_0_1_XOR_LEXT, B_, C);
 nor      U364(Y, NET_0_1_XOR_LEXT, NET_0_1);
 UDP_MUX2   U366(NET_0_1, A_, C_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE AXOI7 ----

//---- MODULE BIBUF ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U370(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF ----

`timescale 1ns/100ps

 module BIBUF_OPEND_MSS(Y,E,PAD);
 input E;
 output Y;
 inout PAD;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;
  
   supply0 gnd_0;
  
 bufif0   U1213(PAD, gnd_0, E);
 buf	BUF_U_01(Y,PAD);

  specify
		(E => PAD ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
  endspecify
  
endmodule

//---- MODULE BIBUF_MSS ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_MSS
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_MSS(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;
  
 bufif1   U370(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_MSS ----

//---- MODULE BIBUF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U373(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12 ----

//---- MODULE BIBUF_F_12D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U376(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12D ----

//---- MODULE BIBUF_F_12U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_12U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U379(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_12U ----

//---- MODULE BIBUF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U382(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16 ----

//---- MODULE BIBUF_F_16D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U385(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16D ----

//---- MODULE BIBUF_F_16U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_16U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U388(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_16U ----

//---- MODULE BIBUF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U391(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24 ----

//---- MODULE BIBUF_F_24D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U394(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24D ----

//---- MODULE BIBUF_F_24U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_24U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U397(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_24U ----

//---- MODULE BIBUF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U400(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8 ----

//---- MODULE BIBUF_F_8D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U403(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8D ----

//---- MODULE BIBUF_F_8U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_8U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U406(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_8U ----

//---- MODULE BIBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U418(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15 ----

//---- MODULE BIBUF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U421(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15D ----

//---- MODULE BIBUF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS15U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U424(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS15U ----

//---- MODULE BIBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U427(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18 ----

//---- MODULE BIBUF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U430(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18D ----

//---- MODULE BIBUF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS18U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U433(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS18U ----

//---- MODULE BIBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U436(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25 ----

//---- MODULE BIBUF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U439(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25D ----

//---- MODULE BIBUF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS25U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U442(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS25U ----

//---- MODULE BIBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U2(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33 ----

//---- MODULE BIBUF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U5(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33D ----

//---- MODULE BIBUF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS33U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U8(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
        (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS33U ----

//---- MODULE BIBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U445(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5 ----

//---- MODULE BIBUF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U448(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5D ----

//---- MODULE BIBUF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVCMOS5U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U451(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVCMOS5U ----

//---- MODULE BIBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PADP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_LVDS(Y,PADP,PADN,D,E);
 input D,E;
 inout PADP,PADN;
 output Y;
 reg NOTIFY_REG;
 reg temp;

   bufif1   U89(PADP, D, E);
   not      U88(D_tmp, D);
   bufif1   U87(PADN, D_tmp, E);
   pmos     U86(Y,temp,1'b0);

   always @(PADP or PADN) begin
     if ((PADP == 1'b1) && (PADN == 1'b0))
        temp = 1'b1;
     else if ((PADP == 1'b0) && (PADN == 1'b1))
        temp = 1'b0;
     else
        temp = 1'bx;
    end


      specify

	specparam tpdLH_E_to_PADP = ( 0.0:0.0:0.0 );
	specparam tpdHL_E_to_PADP = ( 0.0:0.0:0.0 );
        specparam tpdLZ_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PADP = ( 0.1:0.1:0.1 );
	specparam tpdLH_E_to_PADN = ( 0.0:0.0:0.0 );
	specparam tpdHL_E_to_PADN = ( 0.0:0.0:0.0 );
        specparam tpdLZ_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PADP = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PADN = ( 0.1:0.1:0.1 );
        specparam tpdLH_PADP_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_PADP_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdLH_PADN_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_PADN_to_Y = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP );
        ( E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN );

        ( D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP );
        ( D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN );

        ( D => Y )    = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( E => Y )    = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( PADP => Y ) = ( tpdLH_PADP_to_Y, tpdHL_PADP_to_Y );
        ( PADN => Y ) = ( tpdLH_PADN_to_Y, tpdHL_PADN_to_Y );

        $width( negedge PADP, 0.0, 0, NOTIFY_REG );
        $width( posedge PADP, 0.0, 0, NOTIFY_REG );
        $width( negedge PADN, 0.0, 0, NOTIFY_REG );
        $width( posedge PADN, 0.0, 0, NOTIFY_REG );
        $width( negedge D, 0.0, 0, NOTIFY_REG );
        $width( posedge D, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_LVDS ----

//---- MODULE BIBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_PCI(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U454(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_PCI ----

//---- MODULE BIBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_PCIX(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U457(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_PCIX ----

//---- MODULE BIBUF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U472(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12 ----

//---- MODULE BIBUF_S_12D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U475(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12D ----

//---- MODULE BIBUF_S_12U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_12U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U478(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_12U ----

//---- MODULE BIBUF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U481(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16 ----

//---- MODULE BIBUF_S_16D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U484(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16D ----

//---- MODULE BIBUF_S_16U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_16U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U487(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_16U ----

//---- MODULE BIBUF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U490(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24 ----

//---- MODULE BIBUF_S_24D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U493(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24D ----

//---- MODULE BIBUF_S_24U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_24U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U496(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_24U ----

//---- MODULE BIBUF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U499(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8 ----

//---- MODULE BIBUF_S_8D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U502(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8D ----

//---- MODULE BIBUF_S_8U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_8U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U505(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_8U ----

//---- MODULE CLKBUF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf    BUF_U_00(Y,PAD);

       specify

                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF ----

//---- MODULE CLKBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS15(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS15 ----

//---- MODULE CLKBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS18(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS18 ----

//---- MODULE CLKBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS25 ----

//---- MODULE CLKBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS33 ----

//---- MODULE CLKBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVCMOS5(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVCMOS5 ----

//---- MODULE CLKBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVDS (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;

    reg temp;

    pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "clkbuf_lvds";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
          (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVDS ----

//---- MODULE CLKBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_LVPECL (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;

    buf b1(Y, PADP);

    always @(PADP or PADN) begin
       if (PADP != ~PADN) begin
        $display(" -- Error: two inputs should be complement with each other!\n");
        //$finish;
       end
    end

    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "clkbuf_lvpecl";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
          (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule


`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_LVPECL ----

//---- MODULE CLKBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_PCI(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_PCI ----

//---- MODULE CLKBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBUF_PCIX(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBUF_PCIX ----

//---- MODULE DFI0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0(CLK, QN,D);
 input D,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0 ----

//---- MODULE DFI0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0C0(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0C0 ----

//---- MODULE DFI0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0C1(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0C1 ----

//---- MODULE DFI0E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0 ----

//---- MODULE DFI0E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0C0 ----

//---- MODULE DFI0E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0C1 ----

//---- MODULE DFI0E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0P0 ----

//---- MODULE DFI0E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E0P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E0P1 ----

//---- MODULE DFI0E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1 ----

//---- MODULE DFI0E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1C0 ----

//---- MODULE DFI0E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1C1 ----

//---- MODULE DFI0E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1P0 ----

//---- MODULE DFI0E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0E1P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0E1P1 ----

//---- MODULE DFI0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P0(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P0 ----

//---- MODULE DFI0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P1(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(q_tmp, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P1 ----

//---- MODULE DFI0P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI0P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, _CLK=CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI0P1C1(PRE, CLR, CLK, QN,D);
 input D,PRE,CLR,CLK;
 output QN;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(q_tmp, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI0P1C1 ----

//---- MODULE DFI1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1(CLK, QN,D);
 input D,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1 ----

//---- MODULE DFI1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1C0(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1C0 ----

//---- MODULE DFI1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1C1(CLR, CLK, QN,D);
 input D,CLR,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1C1 ----

//---- MODULE DFI1E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0 ----

//---- MODULE DFI1E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0C0 ----

//---- MODULE DFI1E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0C1 ----

//---- MODULE DFI1E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0P0 ----

//---- MODULE DFI1E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E0P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E0P1 ----

//---- MODULE DFI1E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1(E, CLK, QN,D);
 input D,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1 ----

//---- MODULE DFI1E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1C0(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1C0 ----

//---- MODULE DFI1E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1C1(CLR, E, CLK, QN,D);
 input D,CLR,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1C1 ----

//---- MODULE DFI1E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1P0(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1P0 ----

//---- MODULE DFI1E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1E1P1(PRE, E, CLK, QN,D);
 input D,PRE,E,CLK;
 output QN;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1E1P1 ----

//---- MODULE DFI1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P0(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P0 ----

//---- MODULE DFI1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P1(PRE, CLK, QN,D);
 input D,PRE,CLK;
 output QN;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(q_tmp, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P1 ----

//---- MODULE DFI1P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFI1P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[QN=QN, CLK =CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFI1P1C1(PRE, CLR, CLK, QN,D);
 input D,PRE,CLR,CLK;
 output QN;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(q_tmp, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);
  not INV_Q_0(QN,q_tmp);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_QN = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (QN +: D))=(tpdLH_CLK_to_QN, tpdHL_CLK_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFI1P1C1 ----

//---- MODULE DFN0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0(CLK, Q,D);
 input D,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0 ----

//---- MODULE DFN0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0C0(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0C0 ----

//---- MODULE DFN0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0C1(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(negedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0C1 ----

//---- MODULE DFN0E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0 ----

//---- MODULE DFN0E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0C0 ----

//---- MODULE DFN0E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0C1 ----

//---- MODULE DFN0E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0P0 ----

//---- MODULE DFN0E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E0P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E0P1 ----

//---- MODULE DFN0E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK,  0.0, NOTIFY_REG);
	$hold(negedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK, 0.0, NOTIFY_REG);
	$hold(negedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1 ----

//---- MODULE DFN0E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1C0 ----

//---- MODULE DFN0E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1C1 ----

//---- MODULE DFN0E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1P0 ----

//---- MODULE DFN0E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0E1P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,negedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,negedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0E1P1 ----

//---- MODULE DFN0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P0(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpf DF_0(Q, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P0 ----

//---- MODULE DFN0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P1(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpf DF_0(Q, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P1 ----

//---- MODULE DFN0P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN0P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,_CLK=CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN0P1C1(PRE, CLR, CLK, Q,D);
 input D,PRE,CLR,CLK;
 output Q;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpf DF_0(Q, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I0 (_CLK0, CLK);
      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(negedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,negedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(negedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(negedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, negedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, negedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN0P1C1 ----

//---- MODULE DFN1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1(CLK, Q,D);
 input D,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1 ----

//---- MODULE DFN1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1C0(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,CLR);
       buf U_c2 (Enable02, CLR);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1C0 ----

//---- MODULE DFN1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1C1(CLR, CLK, Q,D);
 input D,CLR,CLK;
 output Q;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 UFPRB DF_0( Q, D, CLK, CLR_0, NOTIFY_REG );

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge CLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1C1 ----

//---- MODULE DFN1E0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I3 (_E0, E);
      buf U_c0 (Enable01,_E0);
      buf U_c2 (Enable02, _E0);
      buf U_c4 (Enable04, _E0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0 ----

//---- MODULE DFN1E0C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, CLR);
      and U_c2 (Enable02, _E0, CLR);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0C0 ----

//---- MODULE DFN1E0C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Q, D,CLK,CLR_0, VCC_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _CLR0);
      and U_c2 (Enable02, _E0, _CLR0);
      buf U_c4 (Enable04, _E0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0C1 ----

//---- MODULE DFN1E0P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, PRE);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0P0 ----

//---- MODULE DFN1E0P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E0P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E0P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, E, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I3 (_E0, E);
      and U_c0 (Enable01, _E0, _PRE0);
      buf U_c2 (Enable02, _E0);
      and U_c4 (Enable04, _E0, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E0P1 ----

//---- MODULE DFN1E1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1(E, CLK, Q,D);
 input D,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,E);
      buf U_c2 (Enable02, E);
      buf U_c4 (Enable04, E);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK,  0.0, NOTIFY_REG);
	$hold(posedge CLK, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK, 0.0, NOTIFY_REG);
	$hold(posedge CLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK,0,  0, NOTIFY_REG);
	$width(negedge CLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1 ----

//---- MODULE DFN1E1C0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1C0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, _CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1C0(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,CLR, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, CLR);
      and U_c2 (Enable02, E, CLR);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, posedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1C0 ----

//---- MODULE DFN1E1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, CLR=CLR, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1C1(CLR, E, CLK, Q,D);
 input D,CLR,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,CLR_0, VCC_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, E, _CLR0);
      and U_c2 (Enable02, E, _CLR0);
      buf U_c4 (Enable04, E);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1C1 ----

//---- MODULE DFN1E1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1P0(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, PRE);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1P0 ----

//---- MODULE DFN1E1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1E1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, E=E, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1E1P1(PRE, E, CLK, Q,D);
 input D,PRE,E,CLK;
 output Q;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(E_0, E);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, E_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, E, _PRE0);
      buf U_c2 (Enable02, E);
      and U_c4 (Enable04, E, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge E,posedge CLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, posedge E,0.0, NOTIFY_REG);
	$setup(negedge E,posedge CLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable05, negedge E,0.0, NOTIFY_REG);

	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1E1P1 ----

//---- MODULE DFN1P0 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P0
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, _PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P0(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Q, D,CLK,VCC_0, PRE, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, PRE);       buf U_c4 (Enable04, PRE);
       buf U_c6 (Enable05, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, posedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(posedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P0 ----

//---- MODULE DFN1P1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P1(PRE, CLK, Q,D);
 input D,PRE,CLK;
 output Q;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Q, D,CLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P1 ----

//---- MODULE DFN1P1C1 ----
/*--------------------------------------------------------------
 CELL NAME : DFN1P1C1
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Q,CLK =CLK, CLR=CLR, PRE=PRE, D=D ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DFN1P1C1(PRE, CLR, CLK, Q,D);
 input D,PRE,CLR,CLK;
 output Q;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Q, D,CLK,CLR_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, _CLR0, _PRE0);
       buf U_c2 (Enable02, _CLR0);
       buf U_c4 (Enable04, _PRE0);
      and U_c6 (Enable05, _CLR0, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLK_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Q = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge CLK => (Q +: D))=(tpdLH_CLK_to_Q, tpdHL_CLK_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge CLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge CLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);
	$hold(posedge CLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge CLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge CLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& ~CLR,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge CLK &&& Enable02, 0.0, NOTIFY_REG);
	$recovery(negedge CLR, posedge CLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DFN1P1C1 ----

//---- MODULE DLI0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, D=D ];
-----------------------------------------------------------------*/

module DLI0(G, QN,D);
 input D,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 DL2C_UDP DL_U0(QN_, D, G, GND, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	buf U_c1 (Enable2, _G);
	buf U_c3 (Enable4, _G);
	buf U_c5 (Enable6, _G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0 ----

//---- MODULE DLI0C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI0C0(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR_, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, _G, CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, _G, CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0C0 ----

//---- MODULE DLI0C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI0C1(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, _G, _CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0C1 ----

//---- MODULE DLI0P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P0(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(QN_, D, G, GND, PRE_, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, _G, PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, _G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G )
       (posedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P0 ----

//---- MODULE DLI0P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P1(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(QN_, D, G, GND, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, _G, _PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P1 ----

//---- MODULE DLI0P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI0P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, _CLK=G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI0P1C1(PRE, CLR, G, QN,D);
 input D,PRE,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(QN_, D, G, CLR, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, _G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(negedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	if (!CLR)
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (!G && !CLR )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, posedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI0P1C1 ----

//---- MODULE DLI1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, D=D ];
-----------------------------------------------------------------*/

module DLI1(G, QN,D);
 input D,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	buf U_c1 (Enable2, G);
	buf U_c3 (Enable4, G);
	buf U_c5 (Enable6, G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1 ----

//---- MODULE DLI1C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI1C0(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR_, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, G,CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, G, CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(posedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1C0 ----

//---- MODULE DLI1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLI1C1(CLR, G, QN,D);
 input D,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR, GND, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, G,_CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !CLR )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1C1 ----

//---- MODULE DLI1P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P0(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, PRE_, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, G, PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(negedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G )
       (posedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P0 ----

//---- MODULE DLI1P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P1(PRE, G, QN,D);
 input D,PRE,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, GND, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, G, _PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P1 ----

//---- MODULE DLI1P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLI1P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[QN=QN, CLK =G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLI1P1C1(PRE, CLR, G, QN,D);
 input D,PRE,CLR,G;
 output QN;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(QN_, D, G_, CLR, PRE, NOTIFY_REG);
  not INV_Q(QN, QN_);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_QN = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_QN = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_QN = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_QN = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && !CLR && !PRE )
        (D => QN) = (tpdLH_D_to_QN, tpdHL_D_to_QN);

	if (Enable1)
	(posedge G => (QN+:D))=(tpdLH_G_to_QN, tpdHL_G_to_QN);
	(posedge CLR => (QN +: 1'b0)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	(negedge CLR => (QN+:D)) = (tpdLH_CLR_to_QN, tpdHL_CLR_to_QN);
	if (!CLR)
	(posedge PRE => (QN +: 1'b1)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);
       if (G && !CLR )
	(negedge PRE => (QN+:D)) = (tpdLH_PRE_to_QN, tpdHL_PRE_to_QN);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, negedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLI1P1C1 ----

//---- MODULE DLN0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, D=D ];
-----------------------------------------------------------------*/

module DLN0(G, Q,D);
 input D,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 DL2C_UDP DL_U0(Q, D, G, GND, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	buf U_c1 (Enable2, _G);
	buf U_c3 (Enable4, _G);
	buf U_c5 (Enable6, _G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G, 0.0, NOTIFY_REG);
	$hold(posedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0 ----

//---- MODULE DLN0C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN0C0(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR_, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, _G, CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, _G, CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0C0 ----

//---- MODULE DLN0C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN0C1(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, _G, _CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c5 (Enable6, _G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0C1 ----

//---- MODULE DLN0P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P0(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(Q, D, G, GND, PRE_, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, _G, PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, _G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
       if (!G )
       (posedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P0 ----

//---- MODULE DLN0P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P1(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 DL2C_UDP DL_U0(Q, D, G, GND, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, _G, _PRE);
	buf U_c3 (Enable4, _G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (!G && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
       if (!G )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G, 0.0, NOTIFY_REG);
	$hold (posedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(posedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P1 ----

//---- MODULE DLN0P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN0P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,_CLK=G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN0P1C1(PRE, CLR, G, Q,D);
 input D,PRE,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 DL2C_UDP DL_U0(Q, D, G, CLR, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I0 (_G, G);
	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, _G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, _G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, _G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (!G && !CLR && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(negedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	if (!CLR)
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (!G && !CLR )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,posedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(negedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, posedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, posedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (posedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(posedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN0P1C1 ----

//---- MODULE DLN1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, D=D ];
-----------------------------------------------------------------*/

module DLN1(G, Q,D);
 input D,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	buf U_c1 (Enable2, G);
	buf U_c3 (Enable4, G);
	buf U_c5 (Enable6, G);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (G )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G, 0.0, NOTIFY_REG);
	$hold(negedge G, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G, 0.0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1 ----

//---- MODULE DLN1C0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1C0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, _CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN1C0(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR_, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,CLR);
	and U_c1 (Enable2, G,CLR);
	buf U_c2 (Enable3, CLR);
	and U_c3 (Enable4, G, CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output



	if (G && CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(posedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1C0 ----

//---- MODULE DLN1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, CLR=CLR, D=D ];
-----------------------------------------------------------------*/

module DLN1C1(CLR, G, Q,D);
 input D,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR, GND, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I2 (_CLR, CLR);
	buf U_c0 (Enable1,_CLR);
	and U_c1 (Enable2, G,_CLR);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c5 (Enable6, G);
	buf U_c6 (Enable7, _CLR);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !CLR )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge CLR, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge CLR, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1C1 ----

//---- MODULE DLN1P0 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P0
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, _PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P0(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, PRE_, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,PRE);	and U_c1 (Enable2, G, PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, PRE);
	and U_c5 (Enable6, G, PRE);
	buf U_c6 (Enable7, PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(negedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G )
        (posedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(negedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (posedge  PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, posedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G, posedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P0 ----

//---- MODULE DLN1P1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P1(PRE, G, Q,D);
 input D,PRE,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, GND, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	buf U_c0 (Enable1,_PRE);
	and U_c1 (Enable2, G, _PRE);
	buf U_c3 (Enable4, G);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	buf U_c6 (Enable7, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G, 0.0, NOTIFY_REG);
	$hold (negedge G, negedge PRE, 0.0, NOTIFY_REG);
	$hold(negedge G,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P1 ----

//---- MODULE DLN1P1C1 ----
/*---------------------------------------------------------------
 CELL NAME : DLN1P1C1
 CELL TYPE : D-Latch Logic
 CELL SEQ EQN : DL[Q=Q,CLK =G, CLR=CLR, PRE=PRE, D=D ];
-----------------------------------------------------------------*/

module DLN1P1C1(PRE, CLR, G, Q,D);
 input D,PRE,CLR,G;
 output Q;
 supply1 VCC;
 supply0 GND;
 reg NOTIFY_REG;

 not INV_PRE(PRE_, PRE);
 not INV_CLR(CLR_, CLR);
 not INV_CLK(G_, G);
 DL2C_UDP DL_U0(Q, D, G_, CLR, PRE, NOTIFY_REG);

// some temp signals created for timing checking sections

	not U_I1 (_PRE, PRE);
	not U_I2 (_CLR, CLR);
	and U_c0 (Enable1, _CLR, _PRE);
	and U_c1 (Enable2, G, _CLR, _PRE);
	buf U_c2 (Enable3, _CLR);
	and U_c3 (Enable4, G, _CLR);
	buf U_c4 (Enable5, _PRE);
	and U_c5 (Enable6, G, _PRE);
	and U_c6 (Enable7, _CLR, _PRE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam    LibName	="smartfusion";
	specparam    macroType   ="seq_dlatch";
	specparam    InputLoad$G = 0.0;
	specparam    InputLoad$PRE = 0.0;
	specparam    InputLoad$D = 0.0;
        specparam    tpdLH_D_to_Q = (0.1:0.1:0.1);
        specparam    tpdHL_D_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_G_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_CLR_to_Q = (0.1:0.1:0.1);
	specparam    tpdLH_PRE_to_Q = (0.1:0.1:0.1);
	specparam    tpdHL_PRE_to_Q = (0.1:0.1:0.1);

        //check timing delay for output

	if (G && !CLR && !PRE )
        (D => Q) = (tpdLH_D_to_Q, tpdHL_D_to_Q);

	if (Enable1)
	(posedge G => (Q+:D))=(tpdLH_G_to_Q, tpdHL_G_to_Q);
	(posedge CLR => (Q +: 1'b0)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	(negedge CLR => (Q+:D)) = (tpdLH_CLR_to_Q, tpdHL_CLR_to_Q);
	if (!CLR)
	(posedge PRE => (Q +: 1'b1)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);
        if (G && !CLR )
	(negedge PRE => (Q+:D)) = (tpdLH_PRE_to_Q, tpdHL_PRE_to_Q);

	//checking setup and hold timing for inputs

	$setup(posedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, posedge D,0.0, NOTIFY_REG);
	$setup(negedge D,negedge G &&& Enable1, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable1, negedge D,0.0, NOTIFY_REG);

	// check signal width

	$width(posedge G &&& Enable1, 0.0, 0, NOTIFY_REG);
	$width(posedge PRE &&& Enable3, 0.0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	$recovery (negedge PRE, negedge G &&&  Enable3, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable3 , negedge PRE, 0.0, NOTIFY_REG);
	$recovery (negedge CLR, negedge G &&& Enable5, 0.0, NOTIFY_REG);
	$hold (negedge G &&& Enable5, negedge CLR, 0.0, NOTIFY_REG);
	$hold(negedge G &&& Enable3,  negedge PRE, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DLN1P1C1 ----

//---- MODULE GND ----
/*--------------------------------------------------------------------
 CELL NAME : GND
 CELL TYPE : comb
 CELL LOGIC : Y=0
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module GND(Y);
 output Y;

 supply0	Y;

       specify

		specparam MacroType = "comb";

		//pin to pin path delay 

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE GND ----

//---- MODULE INBUF ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF ----

//---- MODULE INBUF_MSS ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_MSS
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_MSS(Y,PAD);
 input PAD;
 output Y;
 reg 	NOTIFY_REG;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_MSS ----

//---- MODULE INBUF_MCCC ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_MCCC
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_MCCC(Y,PAD);
 input PAD;
 output Y;
 reg 	NOTIFY_REG;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_MCCC ----

//---- MODULE INBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15 ----

//---- MODULE INBUF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15D ----

//---- MODULE INBUF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS15U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS15U ----

//---- MODULE INBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18 ----

//---- MODULE INBUF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18D ----

//---- MODULE INBUF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS18U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS18U ----

//---- MODULE INBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25 ----

//---- MODULE INBUF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25D ----

//---- MODULE INBUF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS25U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS25U ----

//---- MODULE INBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33 ----

//---- MODULE INBUF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33D ----

//---- MODULE INBUF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS33U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

      specify

        specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
        specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS33U ----

//---- MODULE INBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5 ----

//---- MODULE INBUF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : Y#Down=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5D(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5D ----

//---- MODULE INBUF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVCMOS5U(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVCMOS5U ----

//---- MODULE INBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps


module INBUF_LVDS (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;
 
   pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "inbuf_lvds";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVDS ----

//---- MODULE INBUF_LVDS_MCCC ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVDS_MCCC
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps


module INBUF_LVDS_MCCC (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;

   parameter ACT_PIN    = "";
 
   pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;



        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);


    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVDS_MCCC ----

//---- MODULE INBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVPECL (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;

    pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;

         specparam   MacroType = "inbuf_lvpecl";


        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVPECL ----

//---- MODULE INBUF_LVPECL_MCCC ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_LVPECL_MCCC
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_LVPECL_MCCC (PADP,PADN,Y);
  
    input PADP,PADN;
    output Y;
 reg NOTIFY_REG;
    reg temp;

     parameter ACT_PIN    = "";

    pmos p1(Y,temp,1'b0);
    always @(PADP or PADN) begin

    if ((PADP == 1'b1) && (PADN == 1'b0))
       temp = 1'b1;
    else if ((PADP == 1'b0) && (PADN == 1'b1))
       temp = 1'b0;
    else
       temp = 1'bx;
    end


    specify

         specparam   LibName       = "smartfusion";
         specparam   InputLoad$PADP = 0;
         specparam   InputLoad$PADN = 0;
         specparam   OutputLoad$Y  = 0;



        (PADP => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (PADN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge PADP, 0.0, 0, NOTIFY_REG);
         $width(posedge PADP, 0.0, 0, NOTIFY_REG);
         $width(negedge PADN, 0.0, 0, NOTIFY_REG);
         $width(posedge PADN, 0.0, 0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_LVPECL_MCCC ----

//---- MODULE INBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_PCI(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf    BUF_U_00(Y,PAD);

       specify

                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_PCI ----

//---- MODULE INBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_PCIX(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_PCIX ----

//---- MODULE INV ----
/*--------------------------------------------------------------------
 CELL NAME : INV
 CELL TYPE : comb
 CELL LOGIC : Y = !A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INV(Y,A);
 input A;
 output Y;

 not	INV_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INV ----

//---- MODULE MAJ3 ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3
 CELL TYPE : comb
 CELL LOGIC : Y = (A & B) + (B & C) + (A & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 and      U510(NET_0_0, A, B);
 or       U511(NET_0_2, NET_0_0, NET_0_1);
 and      U513(NET_0_1, B, C);
 or       U514(Y, NET_0_2, NET_0_3);
 and      U516(NET_0_3, A, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3 ----

//---- MODULE MAJ3X ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3X
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & !C + A & !B & C + !A & B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3X(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_93(A_, A);
 not	INV_94(B_, B);
 not	INV_95(C_, C);
 and      U521(NET_0_0, A, B);
 UDP_MUX2   U522(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U525(NET_0_5, A_, B);
 or       U526(Y, NET_0_4, NET_0_3);
 and      U529(NET_0_2, A, B_);
 and      U530(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3X ----

//---- MODULE MAJ3XI ----
/*--------------------------------------------------------------------
 CELL NAME : MAJ3XI
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & !C + A & !B & C + !A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MAJ3XI(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_96(A_, A);
 not	INV_97(B_, B);
 not	INV_98(C_, C);
 and      U535(NET_0_0, A, B);
 UDP_MUX2   U536(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U539(NET_0_5, A_, B);
 nor      U540(Y, NET_0_4, NET_0_3);
 and      U543(NET_0_2, A, B_);
 and      U544(NET_0_3, NET_0_2, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MAJ3XI ----

//---- MODULE MIN3 ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3
 CELL TYPE : comb
 CELL LOGIC : Y = !A & !B + !A & !C + !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_99(A_, A);
 not	INV_100(B_, B);
 not	INV_101(C_, C);
 and      U549(NET_0_0, A_, B_);
 or       U550(NET_0_2, NET_0_0, NET_0_1);
 and      U552(NET_0_1, A_, C_);
 or       U553(Y, NET_0_2, NET_0_3);
 and      U555(NET_0_3, B_, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3 ----

//---- MODULE MIN3X ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3X
 CELL TYPE : comb
 CELL LOGIC : Y = A & !B & !C + !A & B & !C + !A & !B & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3X(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_102(A_, A);
 not	INV_103(B_, B);
 not	INV_104(C_, C);
 and      U560(NET_0_0, A, B_);
 UDP_MUX2   U561(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U564(NET_0_5, A_, B_);
 or       U565(Y, NET_0_4, NET_0_3);
 and      U568(NET_0_2, A_, B);
 and      U569(NET_0_3, NET_0_2, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3X ----

//---- MODULE MIN3XI ----
/*--------------------------------------------------------------------
 CELL NAME : MIN3XI
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & !B & !C + !A & B & !C + !A & !B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MIN3XI(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3, NET_0_4, NET_0_5;
 wire NET_0_6;

 not	INV_105(A_, A);
 not	INV_106(B_, B);
 not	INV_107(C_, C);
 and      U574(NET_0_0, A, B_);
 UDP_MUX2   U575(NET_0_4, NET_0_0, NET_0_5, C_);
 and      U578(NET_0_5, A_, B_);
 nor      U579(Y, NET_0_4, NET_0_3);
 and      U582(NET_0_2, A_, B);
 and      U583(NET_0_3, NET_0_2, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MIN3XI ----

//---- MODULE MX2 ----
/*--------------------------------------------------------------------
 CELL NAME : MX2
 CELL TYPE : comb
 CELL LOGIC : Y = (A & !S) + (B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_110(S_, S);
 UDP_MUX2   U594(Y, A, B, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2 ----

//---- MODULE MX2A ----
/*--------------------------------------------------------------------
 CELL NAME : MX2A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !S) + (B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2A(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_111(A_, A);
 not	INV_112(S_, S);
 UDP_MUX2   U598(Y, A_, B, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2A ----

//---- MODULE MX2B ----
/*--------------------------------------------------------------------
 CELL NAME : MX2B
 CELL TYPE : comb
 CELL LOGIC : Y = (A & !S) + (!B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2B(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_113(S_, S);
 not	INV_114(B_, B);
 UDP_MUX2   U602(Y, A, B_, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2B ----

//---- MODULE MX2C ----
/*--------------------------------------------------------------------
 CELL NAME : MX2C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A & !S) + (!B & S)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MX2C(Y,A,S,B);
 input A,S,B;
 output Y;
 wire NET_0_0, NET_0_1;

 not	INV_115(A_, A);
 not	INV_116(S_, S);
 not	INV_117(B_, B);
 UDP_MUX2   U606(Y, A_, B_, S_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_S_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_S_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(S => Y ) = ( tpdLH_S_to_Y, tpdHL_S_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MX2C ----

//---- MODULE NAND2 ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2(Y,A,B);
 input A,B;
 output Y;

 nand     U610(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2 ----

//---- MODULE NAND2A ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_118(A_, A);
 nand     U613(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2A ----

//---- MODULE NAND2B ----
/*--------------------------------------------------------------------
 CELL NAME : NAND2B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_119(A_, A);
 not	INV_120(B_, B);
 nand     U616(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND2B ----

//---- MODULE NAND3 ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 and      U620(NET_0_0, A, B);
 nand     U621(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3 ----

//---- MODULE NAND3A ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_121(A_, A);
 and      U625(NET_0_0, A_, B);
 nand     U626(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3A ----

//---- MODULE NAND3B ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_122(A_, A);
 not	INV_123(B_, B);
 and      U630(NET_0_0, A_, B_);
 nand     U631(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3B ----

//---- MODULE NAND3C ----
/*--------------------------------------------------------------------
 CELL NAME : NAND3C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NAND3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_124(A_, A);
 not	INV_125(B_, B);
 not	INV_126(C_, C);
 and      U635(NET_0_0, A_, B_);
 nand     U636(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NAND3C ----

//---- MODULE NOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2(Y,A,B);
 input A,B;
 output Y;

 nor      U649(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2 ----

//---- MODULE NOR2A ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_130(A_, A);
 nor      U652(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2A ----

//---- MODULE NOR2B ----
/*--------------------------------------------------------------------
 CELL NAME : NOR2B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_131(A_, A);
 not	INV_132(B_, B);
 nor      U655(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR2B ----

//---- MODULE NOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A + B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U662(NET_0_0, A, B);
 nor      U663(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3 ----

//---- MODULE NOR3A ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_134(A_, A);
 or       U667(NET_0_0, A_, B);
 nor      U668(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3A ----

//---- MODULE NOR3B ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3B
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B + C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_135(A_, A);
 not	INV_136(B_, B);
 or       U672(NET_0_0, A_, B_);
 nor      U673(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3B ----

//---- MODULE NOR3C ----
/*--------------------------------------------------------------------
 CELL NAME : NOR3C
 CELL TYPE : comb
 CELL LOGIC : Y = !(!A + !B + !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module NOR3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_137(A_, A);
 not	INV_138(B_, B);
 not	INV_139(C_, C);
 or       U677(NET_0_0, A_, B_);
 nor      U678(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NOR3C ----

//---- MODULE OA1 ----
/*--------------------------------------------------------------------
 CELL NAME : OA1
 CELL TYPE : comb
 CELL LOGIC : Y = (A + B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U692(NET_0_0, A, B);
 and      U693(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1 ----

//---- MODULE OA1A ----
/*--------------------------------------------------------------------
 CELL NAME : OA1A
 CELL TYPE : comb
 CELL LOGIC : Y = (!A + B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_143(A_, A);
 or       U697(NET_0_0, A_, B);
 and      U698(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1A ----

//---- MODULE OA1B ----
/*--------------------------------------------------------------------
 CELL NAME : OA1B
 CELL TYPE : comb
 CELL LOGIC : Y = !C & (A + B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1B(Y,C,A,B);
 input C,A,B;
 output Y;
 wire NET_0_0;

 not	INV_144(C_, C);
 and      U701(Y, C_, NET_0_0);
 or       U703(NET_0_0, A, B);

       specify

		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1B ----

//---- MODULE OA1C ----
/*--------------------------------------------------------------------
 CELL NAME : OA1C
 CELL TYPE : comb
 CELL LOGIC : Y = (!A + B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OA1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_145(A_, A);
 not	INV_146(C_, C);
 or       U707(NET_0_0, A_, B);
 and      U708(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OA1C ----

//---- MODULE OAI1 ----
/*--------------------------------------------------------------------
 CELL NAME : OAI1
 CELL TYPE : comb
 CELL LOGIC : Y = !((A + B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OAI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U732(NET_0_0, A, B);
 nand     U733(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OAI1 ----

//---- MODULE OR2 ----
/*--------------------------------------------------------------------
 CELL NAME : OR2
 CELL TYPE : comb
 CELL LOGIC : Y = A + B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2(Y,A,B);
 input A,B;
 output Y;

 or       U756(Y, A, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2 ----

//---- MODULE OR2A ----
/*--------------------------------------------------------------------
 CELL NAME : OR2A
 CELL TYPE : comb
 CELL LOGIC : Y = !A + B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2A(Y,A,B);
 input A,B;
 output Y;

 not	INV_156(A_, A);
 or       U759(Y, A_, B);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2A ----

//---- MODULE OR2B ----
/*--------------------------------------------------------------------
 CELL NAME : OR2B
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR2B(Y,A,B);
 input A,B;
 output Y;

 not	INV_157(A_, A);
 not	INV_158(B_, B);
 or       U762(Y, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR2B ----

//---- MODULE OR3 ----
/*--------------------------------------------------------------------
 CELL NAME : OR3
 CELL TYPE : comb
 CELL LOGIC : Y = A + B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 or       U769(NET_0_0, A, B);
 or       U770(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3 ----

//---- MODULE OR3A ----
/*--------------------------------------------------------------------
 CELL NAME : OR3A
 CELL TYPE : comb
 CELL LOGIC : Y = !A + B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_160(A_, A);
 or       U774(NET_0_0, A_, B);
 or       U775(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3A ----

//---- MODULE OR3B ----
/*--------------------------------------------------------------------
 CELL NAME : OR3B
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_161(A_, A);
 not	INV_162(B_, B);
 or       U779(NET_0_0, A_, B_);
 or       U780(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3B ----

//---- MODULE OR3C ----
/*--------------------------------------------------------------------
 CELL NAME : OR3C
 CELL TYPE : comb
 CELL LOGIC : Y = !A + !B + !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OR3C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_163(A_, A);
 not	INV_164(B_, B);
 not	INV_165(C_, C);
 or       U784(NET_0_0, A_, B_);
 or       U785(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OR3C ----

//---- MODULE OUTBUF ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF ----

//---- MODULE OUTBUF_MSS ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_MSS
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_MSS(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;
  
 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_MSS ----

//---- MODULE OUTBUF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_12(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_12 ----

//---- MODULE OUTBUF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_16(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_16 ----

//---- MODULE OUTBUF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_24(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_24 ----

//---- MODULE OUTBUF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_8(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_8 ----

//---- MODULE OUTBUF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS15(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS15 ----

//---- MODULE OUTBUF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS18(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS18 ----

//---- MODULE OUTBUF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS25(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS25 ----

//---- MODULE OUTBUF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS33(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

      specify

        specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS33 ----

//---- MODULE OUTBUF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVCMOS5(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVCMOS5 ----

//---- MODULE OUTBUF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVDS(D, PADP,PADN);

input   D;
output  PADP,PADN;
 reg NOTIFY_REG;


        buf b1(PADP,D);
        not n1(PADN,D);

specify

         specparam   LibName        = "smartfusion";
         specparam   InputLoad$D    = 1;
         specparam   OutputLoad$PADP = 0;
         specparam   OutputLoad$PADN = 0;
         specparam   MacroType      = "io";

        (D => PADP) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (D => PADN) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge D, 0.0, 0, NOTIFY_REG);
         $width(posedge D, 0.0, 0, NOTIFY_REG);


endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVDS ----

//---- MODULE OUTBUF_LVPECL ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_LVPECL
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_LVPECL(D, PADP,PADN);

input   D;
output  PADP,PADN;
 reg NOTIFY_REG;


        buf b1(PADP,D);
        not n1(PADN,D);
specify

         specparam   LibName        = "smartfusion";
         specparam   InputLoad$D    = 1;
         specparam   OutputLoad$PADP = 0;
         specparam   OutputLoad$PADN = 0;
         specparam   MacroType      = "io";

        (D => PADP) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (D => PADN) = (0.1:0.1:0.1, 0.1:0.1:0.1);

         $width(negedge D, 0.0, 0, NOTIFY_REG);
         $width(posedge D, 0.0, 0, NOTIFY_REG);


endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_LVPECL ----

//---- MODULE OUTBUF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_PCI(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_PCI ----

//---- MODULE OUTBUF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_PCIX(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_PCIX ----

//---- MODULE OUTBUF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_12(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_12 ----

//---- MODULE OUTBUF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_16(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_16 ----

//---- MODULE OUTBUF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_24(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_24 ----

//---- MODULE OUTBUF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_8(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_8 ----

//---- MODULE TRIBUFF ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U798(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF ----

//---- MODULE TRIBUFF_MSS ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_MSS
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_MSS(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

   parameter ACT_PIN    = "";
   parameter ACT_CONFIG = 0;
  
 bufif1   U798(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_MSS ----

//---- MODULE TRIBUFF_F_12 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U801(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12 ----

//---- MODULE TRIBUFF_F_12D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U804(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12D ----

//---- MODULE TRIBUFF_F_12U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_12U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U807(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_12U ----

//---- MODULE TRIBUFF_F_16 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U810(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16 ----

//---- MODULE TRIBUFF_F_16D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U813(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16D ----

//---- MODULE TRIBUFF_F_16U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_16U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U816(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_16U ----

//---- MODULE TRIBUFF_F_24 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U819(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24 ----

//---- MODULE TRIBUFF_F_24D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U822(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24D ----

//---- MODULE TRIBUFF_F_24U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_24U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U825(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_24U ----

//---- MODULE TRIBUFF_F_8 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U828(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8 ----

//---- MODULE TRIBUFF_F_8D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U831(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8D ----

//---- MODULE TRIBUFF_F_8U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_8U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U834(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_8U ----

//---- MODULE TRIBUFF_LVCMOS15 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U846(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15 ----

//---- MODULE TRIBUFF_LVCMOS15D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U849(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15D ----

//---- MODULE TRIBUFF_LVCMOS15U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS15U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS15U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U852(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS15U ----

//---- MODULE TRIBUFF_LVCMOS18 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U855(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18 ----

//---- MODULE TRIBUFF_LVCMOS18D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U858(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18D ----

//---- MODULE TRIBUFF_LVCMOS18U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS18U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS18U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U861(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS18U ----

//---- MODULE TRIBUFF_LVCMOS25 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U864(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25 ----

//---- MODULE TRIBUFF_LVCMOS25D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U867(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25D ----

//---- MODULE TRIBUFF_LVCMOS25U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS25U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS25U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U870(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS25U ----

//---- MODULE TRIBUFF_LVCMOS33 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U11(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33 ----

//---- MODULE TRIBUFF_LVCMOS33D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U14(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33D ----

//---- MODULE TRIBUFF_LVCMOS33U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS33U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS33U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U17(PAD, D, E);

      specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
        specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

      //if(~D)
        (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS33U ----

//---- MODULE TRIBUFF_LVCMOS5 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U873(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5 ----

//---- MODULE TRIBUFF_LVCMOS5D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U876(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5D ----

//---- MODULE TRIBUFF_LVCMOS5U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVCMOS5U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVCMOS5U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U879(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVCMOS5U ----

//---- MODULE TRIBUFF_LVDS ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_LVDS
 CELL TYPE : comb
 CELL LOGIC : PADP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_LVDS(PADP,PADN,D,E);
 input D,E;
 output PADP,PADN;
 reg NOTIFY_REG;

 bufif1   U99(PADP, D, E);
 not      U98(D_tmp, D);
 bufif1   U97(PADN, D_tmp, E);

      specify

	specparam tpdLH_E_to_PADP = (0.0:0.0:0.0);
	specparam tpdHL_E_to_PADP = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PADP = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PADP = (0.1:0.1:0.1);
	specparam tpdLH_E_to_PADN = (0.0:0.0:0.0);
	specparam tpdHL_E_to_PADN = (0.0:0.0:0.0);
        specparam tpdLZ_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdZL_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdHZ_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdZH_E_to_PADN = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PADP = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PADP = (0.1:0.1:0.1);
        specparam tpdLH_D_to_PADN = (0.1:0.1:0.1);
        specparam tpdHL_D_to_PADN = (0.1:0.1:0.1);
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        (E => PADP ) = ( tpdLH_E_to_PADP,tpdHL_E_to_PADP,tpdLZ_E_to_PADP,tpdZH_E_to_PADP,tpdHZ_E_to_PADP,tpdZL_E_to_PADP);
        (E => PADN ) = ( tpdLH_E_to_PADN,tpdHL_E_to_PADN,tpdLZ_E_to_PADN,tpdZH_E_to_PADN,tpdHZ_E_to_PADN,tpdZL_E_to_PADN);

        (D => PADP ) = ( tpdLH_D_to_PADP,tpdHL_D_to_PADP);
        (D => PADN ) = ( tpdLH_D_to_PADN,tpdHL_D_to_PADN);

        $width(negedge D, 0.0, 0, NOTIFY_REG);
        $width(posedge D, 0.0, 0, NOTIFY_REG);
        $width(negedge E, 0.0, 0, NOTIFY_REG);
        $width(posedge E, 0.0, 0, NOTIFY_REG);


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_LVDS ----

//---- MODULE TRIBUFF_PCI ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_PCI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_PCI(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U882(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_PCI ----

//---- MODULE TRIBUFF_PCIX ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_PCIX
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_PCIX(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U885(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_PCIX ----

//---- MODULE TRIBUFF_S_12 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U900(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12 ----

//---- MODULE TRIBUFF_S_12D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U903(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12D ----

//---- MODULE TRIBUFF_S_12U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_12U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_12U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U906(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_12U ----

//---- MODULE TRIBUFF_S_16 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U909(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16 ----

//---- MODULE TRIBUFF_S_16D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U912(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16D ----

//---- MODULE TRIBUFF_S_16U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_16U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_16U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U915(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_16U ----

//---- MODULE TRIBUFF_S_24 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U918(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24 ----

//---- MODULE TRIBUFF_S_24D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U921(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24D ----

//---- MODULE TRIBUFF_S_24U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_24U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_24U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U924(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_24U ----

//---- MODULE TRIBUFF_S_8 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U927(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8 ----

//---- MODULE TRIBUFF_S_8D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U930(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8D ----

//---- MODULE TRIBUFF_S_8U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_8U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_8U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U933(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_8U ----

//---- MODULE VCC ----
/*--------------------------------------------------------------------
 CELL NAME : VCC
 CELL TYPE : comb
 CELL LOGIC : Y=1
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module VCC(Y);
 output Y;

 supply1    Y;

       specify

		specparam MacroType = "comb";

		//pin to pin path delay 

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE VCC ----

//---- MODULE XA1 ----
/*--------------------------------------------------------------------
 CELL NAME : XA1
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_169(A_, A);
 not	INV_170(B_, B);
 UDP_MUX2   U937(NET_0_0, B, B_, A_);
 and      U939(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1 ----

//---- MODULE XA1A ----
/*--------------------------------------------------------------------
 CELL NAME : XA1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) & C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_171(A_, A);
 not	INV_172(B_, B);
 UDPN_MUX2  U943(NET_0_0, B, B_, A_);
 and      U945(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1A ----

//---- MODULE XA1B ----
/*--------------------------------------------------------------------
 CELL NAME : XA1B
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1B(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_173(A_, A);
 not	INV_174(B_, B);
 not	INV_175(C_, C);
 UDP_MUX2   U949(NET_0_0, B, B_, A_);
 and      U951(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1B ----

//---- MODULE XA1C ----
/*--------------------------------------------------------------------
 CELL NAME : XA1C
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XA1C(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_176(A_, A);
 not	INV_177(B_, B);
 not	INV_178(C_, C);
 UDPN_MUX2  U955(NET_0_0, B, B_, A_);
 and      U957(Y, NET_0_0, C_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XA1C ----

//---- MODULE XAI1 ----
/*--------------------------------------------------------------------
 CELL NAME : XAI1
 CELL TYPE : comb
 CELL LOGIC : Y = !((A ^ B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XAI1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_179(A_, A);
 not	INV_180(B_, B);
 UDP_MUX2   U961(NET_0_0, B, B_, A_);
 nand     U963(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XAI1 ----

//---- MODULE XAI1A ----
/*--------------------------------------------------------------------
 CELL NAME : XAI1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(!(A ^ B) & C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XAI1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_181(A_, A);
 not	INV_182(B_, B);
 UDPN_MUX2  U967(NET_0_0, B, B_, A_);
 nand     U969(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XAI1A ----

//---- MODULE XNOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : XNOR2
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XNOR2(Y,A,B);
 input A,B;
 output Y;

 not	INV_183(A_, A);
 not	INV_184(B_, B);
 UDPN_MUX2  U972(Y, B, B_, A_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XNOR2 ----

//---- MODULE XNOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : XNOR3
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B ^ C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XNOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_187(A_, A);
 not	INV_188(B_, B);
 UDP_MUX2   U981(NET_0_0, B, B_, A_);
 xnor     U983(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XNOR3 ----

//---- MODULE XO1 ----
/*--------------------------------------------------------------------
 CELL NAME : XO1
 CELL TYPE : comb
 CELL LOGIC : Y = (A ^ B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XO1(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_189(A_, A);
 not	INV_190(B_, B);
 UDP_MUX2   U987(NET_0_0, B, B_, A_);
 or       U989(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XO1 ----

//---- MODULE XO1A ----
/*--------------------------------------------------------------------
 CELL NAME : XO1A
 CELL TYPE : comb
 CELL LOGIC : Y = !(A ^ B) + C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XO1A(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_191(A_, A);
 not	INV_192(B_, B);
 UDPN_MUX2  U993(NET_0_0, B, B_, A_);
 or       U995(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XO1A ----

//---- MODULE XOR2 ----
/*--------------------------------------------------------------------
 CELL NAME : XOR2
 CELL TYPE : comb
 CELL LOGIC : Y = A ^ B
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XOR2(Y,A,B);
 input A,B;
 output Y;

 not	INV_193(A_, A);
 not	INV_194(B_, B);
 UDP_MUX2   U998(Y, B, B_, A_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XOR2 ----

//---- MODULE XOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : XOR3
 CELL TYPE : comb
 CELL LOGIC : Y = A ^ B ^ C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module XOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0;

 not	INV_197(A_, A);
 not	INV_198(B_, B);
 UDP_MUX2   U1007(NET_0_0, B, B_, A_);
 xor      U1009(Y, NET_0_0, C);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE XOR3 ----

//---- MODULE ZOR3 ----
/*--------------------------------------------------------------------
 CELL NAME : ZOR3
 CELL TYPE : comb
 CELL LOGIC : Y = A & B & C + !A & !B & !C
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module ZOR3(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_199(A_, A);
 not	INV_200(B_, B);
 not	INV_201(C_, C);
 and      U1013(NET_0_0, A, B);
 UDP_MUX2   U1014(Y, NET_0_0, NET_0_2, C);
 and      U1017(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE ZOR3 ----

//---- MODULE ZOR3I ----
/*--------------------------------------------------------------------
 CELL NAME : ZOR3I
 CELL TYPE : comb
 CELL LOGIC : Y = !(A & B & C + !A & !B & !C)
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module ZOR3I(Y,A,B,C);
 input A,B,C;
 output Y;
 wire NET_0_0, NET_0_1, NET_0_2, NET_0_3;

 not	INV_202(A_, A);
 not	INV_203(B_, B);
 not	INV_204(C_, C);
 and      U1021(NET_0_0, A, B);
 UDPN_MUX2  U1022(Y, NET_0_0, NET_0_2, C);
 and      U1025(NET_0_2, A_, B_);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_B_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_B_to_Y = (0.1:0.1:0.1);
		specparam tpdLH_C_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_C_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
		(B => Y ) = ( tpdLH_B_to_Y, tpdHL_B_to_Y );
		(C => Y ) = ( tpdLH_C_to_Y, tpdHL_C_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE ZOR3I ----

//---- MODULE BUFF ----
/*--------------------------------------------------------------------
 CELL NAME : BUFF
 CELL TYPE : comb
 CELL LOGIC : Y = A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BUFF(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BUFF ----

//---- MODULE CLKINT ----
/*--------------------------------------------------------------------
 CELL NAME : CLKINT
 CELL TYPE : comb
 CELL LOGIC : Y = A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKINT(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKINT ----

//---- MODULE IOIN_IB ----
/*--------------------------------------------------------------------
 CELL NAME : IOIN_IB
 CELL TYPE : comb
 CELL LOGIC : Y = YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IB(Y,YIN);
 input YIN;
 output Y;

 buf	BUF_U_00(Y,YIN);

       specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IB ----

//---- MODULE IOIN_IB_UUSER ----
/*--------------------------------------------------------------------
 CELL NAME : IOIN_IB_UUSER
 CELL TYPE : comb
 CELL LOGIC : Y = YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IB_UUSER(Y,YIN);
 input YIN;
 output Y;

 buf	BUF_U_00(Y,YIN);

       specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IB_UUSER ----

//---- MODULE IOIN_IB_DIFF ----
/*--------------------------------------------------------------------
 CELL NAME : IOIN_IB_DIFF
 CELL TYPE : comb
 CELL LOGIC : Y = YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IB_DIFF(Y,YIN);
 input YIN;
 output Y;

 buf	BUF_U_00(Y,YIN);

       specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IB_DIFF ----

//---- MODULE IOIN_IRC ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, CLR=CLR, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRC(CLR, ICLK, Y,YIN);
 input YIN,CLR,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(Y, YIN,ICLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRC ----

//---- MODULE IOIN_IRP ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, PRE=PRE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRP(PRE, ICLK, Y,YIN);
 input YIN,PRE,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRP ----

//---- MODULE IOIN_IREC ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IREC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, CLR=CLR, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IREC(CLR, ICE, ICLK, Y,YIN);
 input YIN,CLR,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,CLR_0, VCC_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, ICE, _CLR0);
      and U_c2 (Enable02, ICE, _CLR0);
      buf U_c4 (Enable04, ICE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IREC ----

//---- MODULE IOIN_IREP ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IREP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, PRE=PRE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IREP(PRE, ICE, ICLK, Y,YIN);
 input YIN,PRE,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, PRE_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, ICE, _PRE0);
      buf U_c2 (Enable02, ICE);
      and U_c4 (Enable04, ICE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable05, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IREP ----

//---- MODULE IOTRI_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OB_EB
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EB(DOUT,EOUT,D,E);
 input D,E;
 output DOUT,EOUT;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EB ----

//---- MODULE IOTRI_OB_EB_UUSER ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OB_EB_UUSER
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EB_UUSER(DOUT,EOUT,D,E);
 input D,E;
 output DOUT,EOUT;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EB_UUSER ----
//---- MODULE IOTRI_OB_EB_DIFF ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OB_EB_DIFF
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EB_DIFF(DOUT,EOUT,D,E);
 input D,E;
 output DOUT,EOUT;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EB_DIFF ----

//---- MODULE IOTRI_OB_ERC ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, CLR=CLR, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERC(CLR, OCLK, EOUT,DOUT,E,D);
 input E,D,CLR,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(EOUT, E,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERC ----

//---- MODULE IOTRI_OB_ERP ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, PRE=PRE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERP(PRE, OCLK, EOUT,DOUT,E,D);
 input E,D,PRE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERP ----

//---- MODULE IOTRI_OB_EREC ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_EREC
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, CLR=CLR, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EREC(CLR, OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,CLR,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EREC ----

//---- MODULE IOTRI_OB_EREP ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_EREP
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, PRE=PRE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_EREP(PRE, OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,PRE,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_EREP ----

//---- MODULE IOTRI_ORC_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORC_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, CLR=CLR, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORC_EB(CLR, OCLK, DOUT,EOUT,D,E);
 input D,E,CLR,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
       buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORC_EB ----

//---- MODULE IOTRI_ORP_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORP_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, PRE=PRE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORP_EB(PRE, OCLK, DOUT,EOUT,D,E);
 input D,E,PRE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
       buf U_c4 (Enable04, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORP_EB ----

//---- MODULE IOTRI_OREC_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OREC_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, CLR=CLR, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREC_EB(CLR, OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,CLR,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREC_EB ----

//---- MODULE IOTRI_OREP_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OREP_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, PRE=PRE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREP_EB(PRE, OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,PRE,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREP_EB ----

//---- MODULE IOTRI_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORC_ERC(DOUT,EOUT,D,OCLK,CLR,E);
 input D,OCLK,CLR,E;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& ~CLR ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& ~CLR, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& ~CLR, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& ~CLR, negedge E,0.0, NOTIFY_REG);



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORC_ERC ----

//---- MODULE IOTRI_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREC_EREC(DOUT,EOUT,D,OCLK,CLR,OCE,E);
 input D,OCLK,CLR,OCE,E;
 output DOUT,EOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREC_EREC ----

//---- MODULE IOTRI_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORP_ERP(DOUT,EOUT,D,OCLK,PRE,E);
 input D,OCLK,PRE,E;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c4 (Enable04, _PRE0);
      buf U_c6 (Enable05, _PRE0);





//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORP_ERP ----

//---- MODULE IOTRI_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OREP_EREP(DOUT,EOUT,D,OCLK,OCE,PRE,E);
 input D,OCLK,OCE,PRE,E;
 output DOUT,EOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OREP_EREP ----

//---- MODULE IOBI_IB_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EB
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E;Y=YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EB(DOUT,EOUT,Y,D,E,YIN);
 input D,E,YIN;
 output DOUT,EOUT,Y;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);
 buf	BUF_U_02(Y,YIN);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EB ----

//---- MODULE IOBI_IB_OB_EB_UUSER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EB_UUSER
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E;Y=YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EB_UUSER(DOUT,EOUT,Y,D,E,YIN);
 input D,E,YIN;
 output DOUT,EOUT,Y;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);
 buf	BUF_U_02(Y,YIN);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EB_UUSER ----
//---- MODULE IOBI_IB_OB_EB_DIFF ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EB_DIFF
 CELL TYPE : comb
 CELL LOGIC : DOUT=D;EOUT=E;Y=YIN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EB_DIFF(DOUT,EOUT,Y,D,E,YIN);
 input D,E,YIN;
 output DOUT,EOUT,Y;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_01(EOUT,E);
 buf	BUF_U_02(Y,YIN);

       specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );
		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );
		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EB_DIFF ----

//---- MODULE IOBI_IB_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN);
 input D,E,OCLK,CLR,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
       buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERC ----

//---- MODULE IOBI_IB_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN);
 input D,E,OCLK,CLR,OCE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c2 (Enable12, OCE, _CLR1);
      buf U_c4 (Enable14, OCE);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

        	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
        	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	        specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	        specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EREC ----

//---- MODULE IOBI_IB_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN);
 input D,E,OCLK,PRE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c4 (Enable14, _PRE1);
      buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERP ----

//---- MODULE IOBI_IB_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN);
 input D,E,OCLK,OCE,PRE,YIN;
 output DOUT,EOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_EREP ----

//---- MODULE IOBI_IB_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_IB_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OD_EB(DR, DF, CLR, E, OCLK, YIN, DOUT, EOUT, Y);
input DR, DF, CLR, E, OCLK, YIN;
output DOUT, EOUT, Y;

wire tmp1_zd, tmp2_zd;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    buf buf_D(Y, YIN);
    buf buf_E(EOUT, E);
 
    not INV_CLR(CLR_, CLR);
    Dffpr DF_1(tmp1_zd, DR, OCLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp2_zd, DF, OCLK, CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT, tmp1_zd, tmp2_zd , OCLK);

    specify

        //check timing delay for output

        (YIN => Y )  = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        
        (posedge CLR  => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        //(posedge OCLK => (DOUT +: DR))   = (0.1:0.1:0.1, 0.1:0.1:0.1);   //for consistency with other DDR_IN macros
        //(negedge OCLK => (DOUT +: DF))   = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR, posedge OCLK, 0.0, NOTIFY_REG);
        $setup(negedge DR, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, posedge DR, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge DR, 0.0, NOTIFY_REG);

        $setup(posedge DF, posedge OCLK, 0.0, NOTIFY_REG);
        $setup(negedge DF, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, posedge DF, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge DF, 0.0, NOTIFY_REG);

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);
        $hold(posedge OCLK, negedge CLR, 0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK, 0, 0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR,  0, 0, NOTIFY_REG);

    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OD_EB ----

//---- MODULE IOBI_IB_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN);
 input E,D,OCLK,CLR,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
       buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORC_EB ----

//---- MODULE IOBI_IB_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN);
 input E,D,OCLK,CLR,OCE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c2 (Enable12, OCE, _CLR1);
      buf U_c4 (Enable14, OCE);
      buf U_c6 (Enable15, _CLR1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	        specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
         	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	        specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREC_EB ----

//---- MODULE IOBI_IB_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN);
 input E,D,OCLK,PRE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
       buf U_c4 (Enable14, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORP_EB ----

//---- MODULE IOBI_IB_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN);
 input E,D,OCLK,OCE,PRE,YIN;
 output EOUT,DOUT,Y;

 supply1 VCC_1;



 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
       buf U_c6 (Enable15, _PRE1);




//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREP_EB ----

//---- MODULE IOBI_IB_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN);
 input D,OCLK,CLR,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c2 (Enable02, _CLR0);
      buf U_c6 (Enable05, _CLR0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


		//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORC_ERC ----

//---- MODULE IOBI_IB_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN);
 input D,OCLK,CLR,OCE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;



 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c2 (Enable02, OCE, _CLR0);
      buf U_c4 (Enable04, OCE);
      buf U_c6 (Enable05, _CLR0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);


		//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREC_EREC ----

//---- MODULE IOBI_IB_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN);
 input D,OCLK,PRE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;



 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c4 (Enable04, _PRE0);
      buf U_c6 (Enable05, _PRE0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORP_ERP ----

//---- MODULE IOBI_IB_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN);
 input D,OCLK,OCE,PRE,E,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;



 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 buf	BUF_U_20(Y,YIN);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c2 (Enable02, OCE);
      and U_c4 (Enable04, OCE, _PRE0);
       buf U_c6 (Enable05, _PRE0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OREP_EREP ----

//---- MODULE IOBI_IRC_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,CLR);
 input D,E,YIN,ICLK,CLR;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I2 (_CLR2, CLR);
      buf U_c0 (Enable21,_CLR2);
      buf U_c2 (Enable22, _CLR2);
      buf U_c6 (Enable25, _CLR2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_EB ----

//---- MODULE IOBI_IREC_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,CLR,ICE);
 input D,E,YIN,ICLK,CLR,ICE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I2 (_CLR2, CLR);
      and U_c0 (Enable21, ICE, _CLR2);
      and U_c2 (Enable22, ICE, _CLR2);
      buf U_c4 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_EB ----

//---- MODULE IOBI_IRP_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,PRE);
 input D,E,YIN,ICLK,PRE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I1 (_PRE2, PRE);
      buf U_c0 (Enable21, _PRE2);
       buf U_c4 (Enable24, _PRE2);
       buf U_c6 (Enable25, _PRE2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_EB ----

//---- MODULE IOBI_IREP_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,ICE,PRE);
 input D,E,YIN,ICLK,ICE,PRE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      not U2_I1 (_PRE2, PRE);
      and U_c0 (Enable21, ICE, _PRE2);
      buf U_c2 (Enable22, ICE);
      and U_c4 (Enable24, ICE, _PRE2);
       buf U_c6 (Enable25, _PRE2);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_EB ----

//---- MODULE IOBI_IRC_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN,ICLK);
 input D,E,OCLK,CLR,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, negedge YIN,0.0, NOTIFY_REG);

        $hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);
        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

	$width(posedge ICLK &&& Enable12, 0, 0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable12, 0, 0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_ERC ----

//---- MODULE IOBI_IREC_OB_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_ERC(DOUT,EOUT,Y,D,E,OCLK,CLR,YIN,ICLK,ICE);
 input D,E,OCLK,CLR,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      and U_c00 (Enable21, ICE, _CLR1);
      and U_c02 (Enable22, ICE, _CLR1);
      buf U_c04 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable15, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable15, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_ERC ----

//---- MODULE IOBI_IRC_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN,ICLK);
 input D,E,OCLK,CLR,OCE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I02 (_CLR1, CLR);
      and U_c00 (Enable11, OCE, _CLR1);
      and U_c02 (Enable12, OCE, _CLR1);
      buf U_c04 (Enable14, OCE);
      buf U_c06 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      buf U_c0 (Enable21,_CLR1);
      buf U_c2 (Enable22, _CLR1);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

		specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
		specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
		specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OB_EREC ----

//---- MODULE IOBI_IREC_OB_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OB_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OB_EREC(DOUT,EOUT,Y,D,E,OCLK,CLR,OCE,YIN,ICLK,ICE);
 input D,E,OCLK,CLR,OCE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I02 (_CLR1, CLR);
      and U_c00 (Enable11, OCE, _CLR1);
      and U_c02 (Enable12, OCE, _CLR1);
      buf U_c04 (Enable14, OCE);
      buf U_c06 (Enable15, _CLR1);


// some temp signals created for timing checking sections

      and U_c0 (Enable21, ICE, _CLR1);
      and U_c2 (Enable22, ICE, _CLR1);
      buf U_c4 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OB_EREC ----

//---- MODULE IOBI_IRP_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN,ICLK);
 input D,E,OCLK,PRE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c4 (Enable14, _PRE1);
      buf U_c6 (Enable15, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable11, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_ERP ----

//---- MODULE IOBI_IREP_OB_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_ERP(DOUT,EOUT,Y,D,E,OCLK,PRE,YIN,ICLK,ICE);
 input D,E,OCLK,PRE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I01 (_PRE1, PRE);
      buf U_c00 (Enable11, _PRE1);
      buf U_c04 (Enable14, _PRE1);
      buf U_c06 (Enable15, _PRE1);

      and U_c0 (Enable21, ICE, _PRE1);
      buf U_c2 (Enable22, ICE);
      and U_c4 (Enable24, ICE, _PRE1);
      buf U_c6 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_ERP ----

//---- MODULE IOBI_IRP_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN,ICLK);
 input D,E,OCLK,OCE,PRE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c00 (Enable11, OCE, _PRE1);
      buf U_c02 (Enable12, OCE);
      and U_c04 (Enable14, OCE, _PRE1);
      buf U_c06 (Enable15, _PRE1);

      buf U_c0 (Enable21, _PRE1);
      buf U_c4 (Enable24, _PRE1);
      buf U_c6 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OB_EREP ----

//---- MODULE IOBI_IREP_OB_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OB_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OB_EREP(DOUT,EOUT,Y,D,E,OCLK,OCE,PRE,YIN,ICLK,ICE);
 input D,E,OCLK,OCE,PRE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c2 (Enable12, OCE);
      and U_c4 (Enable14, OCE, _PRE1);
      buf U_c6 (Enable15, _PRE1);

      and U_c7 (Enable21, ICE, _PRE1);
      buf U_c8 (Enable22, ICE);
      and U_c9 (Enable24, ICE, _PRE1);
      buf U_c10 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OB_EREP ----

//---- MODULE IOBI_IRC_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN,ICLK);
 input E,D,OCLK,CLR,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c2 (Enable12, _CLR1);
      buf U_c6 (Enable15, _CLR1);

      buf U_c3 (Enable21,_CLR1);
      buf U_c4 (Enable22, _CLR1);
      buf U_c5 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_ORC_EB ----

//---- MODULE IOBI_IREC_ORC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_ORC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_ORC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,YIN,ICLK,ICE);
 input E,D,OCLK,CLR,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      buf U_c0 (Enable11,_CLR1);
      buf U_c1 (Enable12, _CLR1);
      buf U_c2 (Enable15, _CLR1);

      and U_c3 (Enable21, ICE, _CLR1);
      and U_c4 (Enable22, ICE, _CLR1);
      buf U_c5 (Enable24, ICE);
      buf U_c6 (Enable25, _CLR1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);




	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_ORC_EB ----

//---- MODULE IOBI_IRC_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN,ICLK);
 input E,D,OCLK,CLR,OCE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c1 (Enable12, OCE, _CLR1);
      buf U_c2 (Enable14, OCE);
      buf U_c3 (Enable15, _CLR1);

      buf U_c4 (Enable21,_CLR1);
      buf U_c5 (Enable22, _CLR1);
      buf U_c6 (Enable25, _CLR1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OREC_EB ----

//---- MODULE IOBI_IREC_OREC_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OREC_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OREC_EB(EOUT,DOUT,Y,E,D,OCLK,CLR,OCE,YIN,ICLK,ICE);
 input E,D,OCLK,CLR,OCE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U1_I2 (_CLR1, CLR);
      and U_c0 (Enable11, OCE, _CLR1);
      and U_c1 (Enable12, OCE, _CLR1);
      buf U_c2 (Enable14, OCE);
      buf U_c3 (Enable15, _CLR1);

      and U_c4 (Enable21, ICE, _CLR1);
      and U_c5 (Enable22, ICE, _CLR1);
      buf U_c6 (Enable24, ICE);
      buf U_c7 (Enable25, _CLR1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable14, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable14, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OREC_EB ----

//---- MODULE IOBI_IRP_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN,ICLK);
 input E,D,OCLK,PRE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c1 (Enable14, _PRE1);
      buf U_c2 (Enable15, _PRE1);

      buf U_c3 (Enable21, _PRE1);
      buf U_c4 (Enable24, _PRE1);
      buf U_c5 (Enable25, _PRE1);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_ORP_EB ----

//---- MODULE IOBI_IRP_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN,ICLK);
 input E,D,OCLK,OCE,PRE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c1 (Enable12, OCE);
      and U_c2 (Enable14, OCE, _PRE1);
      buf U_c3 (Enable15, _PRE1);

      buf U_c4 (Enable21, _PRE1);
      buf U_c5 (Enable24, _PRE1);
      buf U_c6 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OREP_EB ----

//---- MODULE IOBI_IREP_ORP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_ORP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_ORP_EB(EOUT,DOUT,Y,E,D,OCLK,PRE,YIN,ICLK,ICE);
 input E,D,OCLK,PRE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      buf U_c0 (Enable11, _PRE1);
      buf U_c1 (Enable14, _PRE1);
      buf U_c2 (Enable15, _PRE1);

      and U_c3 (Enable21, ICE, _PRE1);
      buf U_c4 (Enable22, ICE);
      and U_c5 (Enable24, ICE, _PRE1);
      buf U_c6 (Enable25, _PRE1);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_ORP_EB ----

//---- MODULE IOBI_IREP_OREP_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OREP_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OREP_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,PRE,YIN,ICLK,ICE);
 input E,D,OCLK,OCE,PRE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      not U1_I1 (_PRE1, PRE);
      and U_c0 (Enable11, OCE, _PRE1);
      buf U_c1 (Enable12, OCE);
      and U_c2 (Enable14, OCE, _PRE1);
      buf U_c3 (Enable15, _PRE1);

      and U_c4 (Enable21, ICE, _PRE1);
      buf U_c5 (Enable22, ICE);
      and U_c6 (Enable24, ICE, _PRE1);
      buf U_c7 (Enable25, _PRE1);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable15,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable15, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable15, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable12, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable15 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable15, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable12, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OREP_EB ----

//---- MODULE IOBI_IRC_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN,ICLK);
 input D,OCLK,CLR,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c1 (Enable02, _CLR0);
      buf U_c2 (Enable05, _CLR0);

      buf U_c3 (Enable11,_CLR0);
      buf U_c4 (Enable12, _CLR0);
      buf U_c5 (Enable15, _CLR0);

      buf U_c6 (Enable21,_CLR0);
      buf U_c7 (Enable22, _CLR0);
      buf U_c8 (Enable25, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_ORC_ERC ----

//---- MODULE IOBI_IRC_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRC_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRC_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN,ICLK);
 input D,OCLK,CLR,OCE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c1 (Enable02, OCE, _CLR0);
      buf U_c2 (Enable04, OCE);
      buf U_c3 (Enable05, _CLR0);

      and U_c4 (Enable11, OCE, _CLR0);
      and U_c5 (Enable12, OCE, _CLR0);
      buf U_c6 (Enable14, OCE);
      buf U_c7 (Enable15, _CLR0);

      buf U_c8 (Enable21,_CLR0);
      buf U_c9 (Enable22, _CLR0);
      buf U_c10 (Enable25, _CLR0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge ICLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRC_OREC_EREC ----

//---- MODULE IOBI_IREC_ORC_ERC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_ORC_ERC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_ORC_ERC(DOUT,EOUT,Y,D,OCLK,CLR,E,YIN,ICLK,ICE);
 input D,OCLK,CLR,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, GND_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      buf U_c0 (Enable01,_CLR0);
      buf U_c1 (Enable02, _CLR0);
      buf U_c2 (Enable05, _CLR0);

      buf U_c3 (Enable11,_CLR0);
      buf U_c4 (Enable12, _CLR0);
      buf U_c5 (Enable15, _CLR0);

      and U_c6 (Enable21, ICE, _CLR0);
      and U_c7 (Enable22, ICE, _CLR0);
      buf U_c8 (Enable24, ICE);
      buf U_c9 (Enable25, _CLR0);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge CLR,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_ORC_ERC ----

//---- MODULE IOBI_IREC_OREC_EREC ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREC_OREC_EREC
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREC_OREC_EREC(DOUT,EOUT,Y,D,OCLK,CLR,OCE,E,YIN,ICLK,ICE);
 input D,OCLK,CLR,OCE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_CLR_0(CLR_0, CLR);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,CLR_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_CLR_1(CLR_1, CLR);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,CLR_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_CLR_2(CLR_2, CLR);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,CLR_2, VCC_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I2 (_CLR0, CLR);
      and U_c0 (Enable01, OCE, _CLR0);
      and U_c1 (Enable02, OCE, _CLR0);
      buf U_c2 (Enable04, OCE);
      buf U_c3 (Enable05, _CLR0);

      and U_c4 (Enable11, OCE, _CLR0);
      and U_c5 (Enable12, OCE, _CLR0);
      buf U_c6 (Enable14, OCE);
      buf U_c7 (Enable15, _CLR0);

      and U_c8 (Enable21, ICE, _CLR0);
      and U_c9 (Enable22, ICE, _CLR0);
      buf U_c10 (Enable24, ICE);
      buf U_c11 (Enable25, _CLR0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_CLR_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_CLR_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge CLR => (DOUT +: 1'b0)) = (tpdLH_CLR_to_DOUT, tpdHL_CLR_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable04, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge CLR, 0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge OCLK &&& Enable04, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge CLR => (EOUT +: 1'b0)) = (tpdLH_CLR_to_EOUT, tpdHL_CLR_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge CLR => (Y +: 1'b0)) = (tpdLH_CLR_to_Y, tpdHL_CLR_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable24, negedge CLR,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge CLR, posedge ICLK &&& Enable24, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREC_OREC_EREC ----

//---- MODULE IOBI_IRP_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN,ICLK);
 input D,OCLK,PRE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c1 (Enable04, _PRE0);
      buf U_c2 (Enable05, _PRE0);

      buf U_c3 (Enable11, _PRE0);
      buf U_c4 (Enable14, _PRE0);
      buf U_c5 (Enable15, _PRE0);

      buf U_c6 (Enable21, _PRE0);
      buf U_c7 (Enable24, _PRE0);
      buf U_c8 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);
	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_ORP_ERP ----

//---- MODULE IOBI_IRP_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRP_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRP_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN,ICLK);
 input D,OCLK,OCE,PRE,E,YIN,ICLK;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c1 (Enable02, OCE);
      and U_c2 (Enable04, OCE, _PRE0);
      buf U_c3 (Enable05, _PRE0);

      and U_c4 (Enable11, OCE, _PRE0);
      buf U_c5 (Enable12, OCE);
      and U_c6 (Enable14, OCE, _PRE0);
      buf U_c7 (Enable15, _PRE0);

      buf U_c8 (Enable21, _PRE0);
      buf U_c9 (Enable24, _PRE0);
      buf U_c10 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	$hold(posedge ICLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK, 0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRP_OREP_EREP ----

//---- MODULE IOBI_IREP_ORP_ERP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_ORP_ERP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_ORP_ERP(DOUT,EOUT,Y,D,OCLK,PRE,E,YIN,ICLK,ICE);
 input D,OCLK,PRE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, GND_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, GND_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      buf U_c0 (Enable01, _PRE0);
      buf U_c1 (Enable04, _PRE0);
      buf U_c2 (Enable05, _PRE0);

      buf U_c3 (Enable11, _PRE0);
      buf U_c4 (Enable14, _PRE0);
      buf U_c5 (Enable15, _PRE0);

      and U_c6 (Enable21, ICE, _PRE0);
      buf U_c7 (Enable22, ICE);
      and U_c8 (Enable24, ICE, _PRE0);
      buf U_c9 (Enable25, _PRE0);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$hold(posedge OCLK, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK, 0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_ORP_ERP ----

//---- MODULE IOBI_IREP_OREP_EREP ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IREP_OREP_EREP
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IREP_OREP_EREP(DOUT,EOUT,Y,D,OCLK,OCE,PRE,E,YIN,ICLK,ICE);
 input D,OCLK,OCE,PRE,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_PRE_0(PRE_0, PRE);
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, PRE_0, OCE_0, NOTIFY_REG);

 not INV_PRE_1(PRE_1, PRE);
 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, PRE_1, OCE_1, NOTIFY_REG);

 not INV_PRE_2(PRE_2, PRE);
 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, PRE_2, ICE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      not U0_I1 (_PRE0, PRE);
      and U_c0 (Enable01, OCE, _PRE0);
      buf U_c1 (Enable02, OCE);
      and U_c2 (Enable04, OCE, _PRE0);
      buf U_c3 (Enable05, _PRE0);

      not U1_I4 (_PRE1, PRE);
      and U_c4 (Enable11, OCE, _PRE0);
      buf U_c5 (Enable12, OCE);
      and U_c6 (Enable14, OCE, _PRE0);
      buf U_c7 (Enable15, _PRE0);

      and U_c8 (Enable21, ICE, _PRE0);
      buf U_c9 (Enable22, ICE);
      and U_c10 (Enable24, ICE, _PRE0);
      buf U_c11 (Enable25, _PRE0);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdLH_PRE_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_PRE_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);
	(posedge PRE => (DOUT +: 1'b1)) = (tpdLH_PRE_to_DOUT, tpdHL_PRE_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK &&& Enable05,  0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK &&& Enable05, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable05, negedge OCE,0.0, NOTIFY_REG);

	$hold(posedge OCLK &&& Enable02, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK &&& Enable05 ,0,  0, NOTIFY_REG);
	$width(negedge OCLK &&& Enable05, 0, 0, NOTIFY_REG);
	$width(posedge PRE,  0.0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge OCLK &&& Enable02, 0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);
	(posedge PRE => (EOUT +: 1'b1)) = (tpdLH_PRE_to_EOUT, tpdHL_PRE_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);
	(posedge PRE => (Y +: 1'b1)) = (tpdLH_PRE_to_Y, tpdHL_PRE_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK &&& Enable25,  0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK &&& Enable25, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable25, negedge ICE,0.0, NOTIFY_REG);

	$hold(posedge ICLK &&& Enable22, negedge PRE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK &&& Enable25 ,0,  0, NOTIFY_REG);
	$width(negedge ICLK &&& Enable25, 0, 0, NOTIFY_REG);

	//checing the recovery data

	$recovery(negedge PRE, posedge ICLK &&& Enable22, 0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IREP_OREP_EREP ----

//---- MODULE IOPAD_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN ----

//---- MODULE IOPADP_IN ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADP_IN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_IN(PAD,N2PIN,Y);

output  Y;
input  PAD,N2PIN;
    
 reg NOTIFY_REG;

     buf          BF1   (Y, PAD);

specify 
    specparam   LibName       = "smartfusion";
    specparam   InputLoad$PAD = 1;
    specparam   OutputLoad$Y  = 0;
    specparam   MacroType     = "io";

 
        (PAD => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1); 
        (N2PIN => Y) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$N2PIN$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge N2PIN, 0.0, 0, NOTIFY_REG);
                $width(posedge N2PIN, 0.0, 0, NOTIFY_REG);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);


endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_IN ----

//---- MODULE IOPADN_IN ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADN_IN
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_IN(PAD,N2POUT);

output  N2POUT;
input  PAD;

 reg NOTIFY_REG;
    
     buf          BF1   (N2POUT, PAD);

specify 
    specparam   LibName       = "smartfusion";
    specparam   InputLoad$PAD = 1;
    specparam   OutputLoad$Y  = 0;
    specparam   MacroType     = "io";

 
        (PAD => N2POUT) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$PAD$N2POUT = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_IN ----

//---- MODULE IOPAD_TRI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 bufif1   U1210(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI ----

//---- MODULE IOPADP_TRI ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADP_TRI
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_TRI(D, E, PAD);

output  PAD;
input  D, E;

 reg NOTIFY_REG;

   bufif1       BF1   (PAD, D, E);

specify 
 
         specparam   LibName     = "smartfusion";
         specparam   OutputLoad$PAD = 0;
         specparam   InputLoad$D = 1;
         specparam   InputLoad$E = 1;
 
         specparam   MacroType = "io";

        (E => PAD) = (0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1); 
        (D => PAD) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

 
endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_TRI ----

//---- MODULE IOPADN_TRI ----
/*--------------------------------------------------------------------
 CELL NAME  : IOPADN_TRI
---------------------------------------------------------------------*/      

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_TRI(DB, E, PAD);

output  PAD;
input  DB, E;

 reg NOTIFY_REG;

   not          INVT (net1,DB);
   bufif1       BF1  (PAD, net1, E);

specify 
 
         specparam   LibName     = "smartfusion";
         specparam   OutputLoad$PAD = 0;
         specparam   InputLoad$DB = 1;
         specparam   InputLoad$E = 1;
 
         specparam   MacroType = "io";


        (E  => PAD) = (0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1,0.1:0.1:0.1); 
        (DB => PAD) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                specparam PATHPULSE$DB$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge DB, 0.0, 0, NOTIFY_REG);
                $width(posedge DB, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

 
endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_TRI ----

//---- MODULE IOPAD_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 bufif1   U1213(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI ----

//---- MODULE IOPADP_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADP_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADP_BI(Y,PAD,N2PIN,D,E);
 input D,E,N2PIN;
 inout PAD;
 output Y;
 reg NOTIFY_REG;
 reg temp;

   bufif1   U89(PAD, D, E);
   pmos     U86(Y,temp,1'b0);

   always @(PAD or N2PIN) begin
     if ((PAD == 1'b1) && (N2PIN == 1'b0))
        temp = 1'b1;
     else if ((PAD == 1'b0) && (N2PIN == 1'b1))
        temp = 1'b0;
     else
        temp = 1'bx;
    end


      specify

	specparam tpdLH_E_to_PAD   = ( 0.1:0.1:0.1 );
	specparam tpdHL_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLZ_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLH_D_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdHL_D_to_PAD   = ( 0.1:0.1:0.1 );
        specparam tpdLH_PAD_to_Y   = ( 0.1:0.1:0.1 );
        specparam tpdHL_PAD_to_Y   = ( 0.1:0.1:0.1 );
        specparam tpdLH_N2PIN_to_Y = ( 0.1:0.1:0.1 );
        specparam tpdHL_N2PIN_to_Y = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PAD )   = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
        ( D => PAD )   = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD );

        ( D => Y )     = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( E => Y )     = ( 0.1:0.1:0.1, 0.1:0.1:0.1 );
        ( PAD   => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
        ( N2PIN => Y ) = ( tpdLH_N2PIN_to_Y, tpdHL_N2PIN_to_Y );

        specparam PATHPULSE$D$PAD = (0.1, 0.1);
        specparam PATHPULSE$E$PAD = (0.1, 0.1);
        specparam PATHPULSE$PAD$Y = (0.1, 0.1);
        specparam PATHPULSE$D$Y   = (0.1, 0.1);
        specparam PATHPULSE$E$Y   = (0.1, 0.1);

        $width( negedge PAD, 0.0, 0, NOTIFY_REG );
        $width( posedge PAD, 0.0, 0, NOTIFY_REG );
        $width( negedge N2PIN, 0.0, 0, NOTIFY_REG );
        $width( posedge N2PIN, 0.0, 0, NOTIFY_REG );
        $width( negedge D, 0.0, 0, NOTIFY_REG );
        $width( posedge D, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADP_BI ----

//---- MODULE IOPADN_BI ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADN_BI
 CELL TYPE : comb
 CELL LOGIC : PAD=!DB@E ; N2POUT=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_BI(N2POUT,PAD,DB,E);
 input DB,E;
 inout PAD;
 output N2POUT;
 reg NOTIFY_REG;
 reg temp;

   not      U79(DB_tmp,DB);
   bufif1   U78(PAD, DB_tmp, E);
   buf      U77(N2POUT,PAD);

      specify

	specparam tpdLH_E_to_PAD  = ( 0.1:0.1:0.1 );
	specparam tpdHL_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdLZ_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdZL_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdHZ_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdZH_E_to_PAD  = ( 0.1:0.1:0.1 );
        specparam tpdLH_DB_to_PAD = ( 0.1:0.1:0.1 );
        specparam tpdHL_DB_to_PAD = ( 0.1:0.1:0.1 );
        specparam tpdLH_PAD_to_N2POUT = ( 0.1:0.1:0.1 );
        specparam tpdHL_PAD_to_N2POUT = ( 0.1:0.1:0.1 );
        specparam MacroType = "comb";

        //pin to pin path delay 

        //if(~D)
        ( E => PAD )  = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD );
        ( DB => PAD ) = ( tpdLH_DB_to_PAD,tpdHL_DB_to_PAD );

        ( PAD   => N2POUT ) = ( tpdLH_PAD_to_N2POUT, tpdHL_PAD_to_N2POUT );

        specparam PATHPULSE$DB$PAD     = (0.1, 0.1);
        specparam PATHPULSE$E$PAD      = (0.1, 0.1);
        specparam PATHPULSE$PAD$N2POUT = (0.1, 0.1);

        $width( negedge PAD, 0.0, 0, NOTIFY_REG );
        $width( posedge PAD, 0.0, 0, NOTIFY_REG );
        $width( negedge DB, 0.0, 0, NOTIFY_REG );
        $width( posedge DB, 0.0, 0, NOTIFY_REG );
        $width( negedge E, 0.0, 0, NOTIFY_REG );
        $width( posedge E, 0.0, 0, NOTIFY_REG );


      endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_BI ----

//---- MODULE IOPAD_IN_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN_U
 CELL TYPE : comb
 CELL LOGIC : Y#UP=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN_U(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 pullup	UP(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN_U ----

//---- MODULE IOPAD_IN_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_IN_D
 CELL TYPE : comb
 CELL LOGIC : Y#DOWN=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_IN_D(Y,PAD);
 input PAD;
 output Y;

 reg NOTIFY_REG;

 pulldown	DN(PAD);
 buf	BUF_U_00(Y,PAD);

       specify

		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_IN_D ----

//---- MODULE IOPAD_TRI_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI_U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI_U(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U2089(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI_U ----

//---- MODULE IOPAD_TRI_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_TRI_D
 CELL TYPE : comb
 CELL LOGIC : PAD#DOWN=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_TRI_D(PAD,D,E);
 input D,E;
 output PAD;

 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U2092(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_TRI_D ----

//---- MODULE IOPAD_BI_U ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI_U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI_U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U2095(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI_U ----

//---- MODULE IOPAD_BI_D ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_BI_D
 CELL TYPE : comb
 CELL LOGIC : PAD#DOWN=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_BI_D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;

 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U2098(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if(~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
                specparam PATHPULSE$D$PAD = (0.1, 0.1);
                specparam PATHPULSE$E$PAD = (0.1, 0.1);
                specparam PATHPULSE$D$Y = (0.1, 0.1);
                specparam PATHPULSE$E$Y = (0.1, 0.1);
                specparam PATHPULSE$PAD$Y = (0.1, 0.1);
                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_BI_D ----

//---- MODULE IOPADN_OUT ----
/*--------------------------------------------------------------------
 CELL NAME : IOPADN_OUT
 CELL TYPE : comb
 CELL LOGIC : PAD=!DB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPADN_OUT(PAD,DB);
 input DB;
 output PAD;

 reg NOTIFY_REG;

 not	INV_U_00(PAD,DB);

       specify

		specparam tpdLH_DB_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_DB_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(DB => PAD ) = ( tpdLH_DB_to_PAD, tpdHL_DB_to_PAD );

                specparam PATHPULSE$DB$PAD = (0.1, 0.1);
                $width(negedge DB, 0.0, 0, NOTIFY_REG);
                $width(posedge DB, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPADN_OUT ----

//---- MODULE BIBUF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1052(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2 ----

//---- MODULE BIBUF_F_2D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1055(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2D ----

//---- MODULE BIBUF_F_2U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_2U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_2U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1058(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_2U ----

//---- MODULE BIBUF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1061(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4 ----

//---- MODULE BIBUF_F_4D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1064(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4D ----

//---- MODULE BIBUF_F_4U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_4U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_4U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1067(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_4U ----

//---- MODULE BIBUF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1079(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6 ----

//---- MODULE BIBUF_F_6D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1082(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6D ----

//---- MODULE BIBUF_F_6U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_F_6U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_F_6U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1085(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_F_6U ----

//---- MODULE BIBUF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1103(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2 ----

//---- MODULE BIBUF_S_2D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1106(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2D ----

//---- MODULE BIBUF_S_2U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_2U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_2U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1109(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_2U ----

//---- MODULE BIBUF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1112(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4 ----

//---- MODULE BIBUF_S_4D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1115(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4D ----

//---- MODULE BIBUF_S_4U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_4U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_4U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1118(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_4U ----

//---- MODULE BIBUF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1121(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6 ----

//---- MODULE BIBUF_S_6D ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6D
 CELL TYPE : comb
 CELL LOGIC : PAD#Down=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6D(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1124(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6D ----

//---- MODULE BIBUF_S_6U ----
/*--------------------------------------------------------------------
 CELL NAME : BIBUF_S_6U
 CELL TYPE : comb
 CELL LOGIC : PAD#UP=D@E ; Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BIBUF_S_6U(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1127(PAD, D, E);
 buf	BUF_U_01(Y,PAD);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
		(D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
		(PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BIBUF_S_6U ----

//---- MODULE OUTBUF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_2(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_2 ----

//---- MODULE OUTBUF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_4(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_4 ----

//---- MODULE OUTBUF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_F_6(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_F_6 ----

//---- MODULE OUTBUF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_2(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_2 ----

//---- MODULE OUTBUF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_4(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_4 ----

//---- MODULE OUTBUF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_S_6(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

       specify

		specparam tpdLH_D_to_PAD = (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_S_6 ----

//---- MODULE TRIBUFF_F_2 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1139(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2 ----

//---- MODULE TRIBUFF_F_2D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1142(PAD, D, E);
 tri0 PAD;

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2D ----

//---- MODULE TRIBUFF_F_2U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_2U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_2U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1145(PAD, D, E);
       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_2U ----

//---- MODULE TRIBUFF_F_4 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1148(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4 ----

//---- MODULE TRIBUFF_F_4D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1151(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4D ----

//---- MODULE TRIBUFF_F_4U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_4U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_4U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1154(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_4U ----

//---- MODULE TRIBUFF_F_6 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1157(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6 ----

//---- MODULE TRIBUFF_F_6D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1160(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6D ----

//---- MODULE TRIBUFF_F_6U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_F_6U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_F_6U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1163(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_F_6U ----

//---- MODULE TRIBUFF_S_2 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1190(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2 ----

//---- MODULE TRIBUFF_S_2D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1193(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2D ----

//---- MODULE TRIBUFF_S_2U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_2U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_2U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1196(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_2U ----

//---- MODULE TRIBUFF_S_4 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1199(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4 ----

//---- MODULE TRIBUFF_S_4D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1202(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4D ----

//---- MODULE TRIBUFF_S_4U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_4U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_4U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1205(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_4U ----

//---- MODULE TRIBUFF_S_6 ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 bufif1   U1208(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6 ----

//---- MODULE TRIBUFF_S_6D ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6D
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6D(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri0 PAD;
 bufif1   U1211(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6D ----

//---- MODULE TRIBUFF_S_6U ----
/*--------------------------------------------------------------------
 CELL NAME : TRIBUFF_S_6U
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module TRIBUFF_S_6U(PAD,D,E);
 input D,E;
 output PAD;
 reg NOTIFY_REG;

 tri1 PAD;
 bufif1   U1214(PAD, D, E);

       specify

		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
		specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
		specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

	    //if (~D)
		(E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

	        (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);

                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE TRIBUFF_S_6U ----

//---- MODULE BUFD ----
/*--------------------------------------------------------------------
 CELL NAME : BUFD
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module BUFD(Y,A);
 input A;
 output Y;

 buf	BUF_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE BUFD ----

//---- MODULE INVD ----
/*--------------------------------------------------------------------
 CELL NAME : INVD
 CELL TYPE : comb
 CELL LOGIC : Y=!A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INVD(Y,A);
 input A;
 output Y;

 not	INV_U_00(Y,A);

       specify

		specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
		specparam MacroType = "comb";

		//pin to pin path delay 

		(A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INVD ----

//---- MODULE IOIN_IR ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IR
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IR(ICLK, Y,YIN);
 input YIN,ICLK;
 output Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;


 Dffpr DF_0(Y, YIN,ICLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IR ----

//---- MODULE IOIN_IRE ----
/*--------------------------------------------------------------
 CELL NAME : IOIN_IRE
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=Y,CLK =ICLK, E=ICE, D=YIN ];
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_IRE(ICE, ICLK, Y,YIN);
 input YIN,ICE,ICLK;
 output Y;
 supply1 VCC_0;
 reg NOTIFY_REG;

 not INV_EN_0(ICE_0, ICE);

 Dffpr DF_0(Y, YIN,ICLK,VCC_0, VCC_0, ICE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,ICE);
      buf U_c2 (Enable02, ICE);
      buf U_c4 (Enable04, ICE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable01, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_IRE ----

//---- MODULE IOTRI_OB_ER ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ER
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ER(OCLK, EOUT,DOUT,E,D);
 input E,D,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ER ----

//---- MODULE IOTRI_OB_ERE ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OB_ERE
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=EOUT,CLK =OCLK, E=OCE, D=E ];
 CELL COMB EQN : "DOUT = D"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OB_ERE(OCE, OCLK, EOUT,DOUT,E,D);
 input E,D,OCE,OCLK;
 output EOUT,DOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_DOUT_0(DOUT,D);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_D_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(D => DOUT) = (tpdLH_D_to_DOUT, tpdHL_D_to_DOUT);

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OB_ERE ----

//---- MODULE IOTRI_OR_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_OR_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OR_EB(OCLK, DOUT,EOUT,D,E);
 input D,E,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OR_EB ----

//---- MODULE IOTRI_ORE_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOTRI_ORE_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, E=OCE, D=D ];
 CELL COMB EQN : "EOUT = E"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORE_EB(OCE, OCLK, DOUT,EOUT,D,E);
 input D,E,OCE,OCLK;
 output DOUT,EOUT;
 supply1 VCC_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);

	// create the sequential logic -- DFF flip-flop plus comb input logic
 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORE_EB ----

//---- MODULE IOTRI_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_ORE_ERE(EOUT,DOUT,E,OCLK,OCE,D);
 input E,OCLK,OCE,D;
 output EOUT,DOUT;
 supply1 VCC_0;

 supply1 VCC_1;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c3 (Enable11,OCE);
      buf U_c5 (Enable12, OCE);
      buf U_c6 (Enable14, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_ORE_ERE ----

//---- MODULE IOTRI_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOTRI_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OR_ER(EOUT,DOUT,E,OCLK,D);
 input E,OCLK,D;
 output EOUT,DOUT;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OR_ER ----

//---- MODULE IOBI_IB_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ER(DOUT,Y,EOUT,D,YIN,E,OCLK);
 input D,YIN,E,OCLK;
 output DOUT,Y,EOUT;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(Y,YIN);


 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ER ----

//---- MODULE IOBI_IB_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OB_ERE(DOUT,Y,EOUT,D,YIN,E,OCLK,OCE);
 input D,YIN,E,OCLK,OCE;
 output DOUT,Y,EOUT;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(Y,YIN);

 not INV_EN_2(OCE_2, OCE);

 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,OCE);
      buf U_c2 (Enable22, OCE);
      buf U_c4 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
		specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OB_ERE ----

//---- MODULE IOBI_IB_OR_EB ----
/*--------------------------------------------------------------
 CELL NAME : IOBI_IB_OR_EB
 CELL TYPE : sequential Logic
 CELL SEQ EQN : DFF[Q=DOUT,CLK =OCLK, D=D ];
 CELL COMB EQN : "EOUT = E, Y = YIN"
----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OR_EB(OCLK, DOUT,Y, EOUT,D,E, YIN);
 input D,E,OCLK,YIN;
 output DOUT,EOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;
 reg NOTIFY_REG;

	// create Logics for combinatorial output Logics! 

 buf BUF_EOUT_0(EOUT,E);
 buf U0 (Y,YIN);

	// create the sequential logic -- DFF flip-flop plus comb input logic

 Dffpr DF_0(DOUT, D,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);

// some temp signals created for timing checking sections


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_E_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

        // checking timing path for combinatorial output

	(E => EOUT) = (tpdLH_E_to_EOUT, tpdHL_E_to_EOUT);

        (YIN => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OR_EB ----

//---- MODULE IOBI_IB_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORE_EB(EOUT,Y,DOUT,E,YIN,D,OCLK,OCE);
 input E,YIN,D,OCLK,OCE;
 output EOUT,Y,DOUT;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);

 buf	BUF_U_10(Y,YIN);

 not INV_EN_2(OCE_2, OCE);

 Dffpr DF_2(DOUT, D,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);




// some temp signals created for timing checking sections

      buf U_c0 (Enable21,OCE);
      buf U_c2 (Enable22, OCE);
      buf U_c4 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
		specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORE_EB ----

//---- MODULE IOBI_IB_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_OR_ER(Y,DOUT,EOUT,YIN,D,OCLK,E);
 input YIN,D,OCLK,E;
 output Y,DOUT,EOUT;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(Y,YIN);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

		specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
		specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

		specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
		specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

		specparam MacroType = "multi";

		//pin to pin path delay 

		(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );




	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_OR_ER ----

//---- MODULE IOBI_IB_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IB_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IB_ORE_ERE(Y,DOUT,EOUT,YIN,D,OCLK,OCE,E);
 input YIN,D,OCLK,OCE,E;
 output Y,DOUT,EOUT;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(Y,YIN);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(OCE_2, OCE);
 Dffpr DF_2(EOUT, E,OCLK,VCC_2, VCC_2, OCE_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,OCE);
      buf U_c3 (Enable22, OCE);
      buf U_c5 (Enable24, OCE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_YIN_to_Y = (0.1:0.1:0.1);
	specparam tpdHL_YIN_to_Y = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(YIN => Y ) = ( tpdLH_YIN_to_Y, tpdHL_YIN_to_Y );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable21, negedge E,0.0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IB_ORE_ERE ----

//---- MODULE IOBI_IR_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK);
 input D,E,YIN,ICLK;
 output DOUT,EOUT,Y;


 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 buf	BUF_U_10(EOUT,E);


 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_EB ----

//---- MODULE IOBI_IRE_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_EB(DOUT,EOUT,Y,D,E,YIN,ICLK,ICE);
 input D,E,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;


 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);
 buf	BUF_U_10(EOUT,E);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

		//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

		//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_EB ----

//---- MODULE IOBI_IR_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_ER(DOUT,EOUT,Y,D,E,OCLK,YIN,ICLK);
 input D,E,OCLK,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);


 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_ER ----

//---- MODULE IOBI_IRE_OB_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_ER(DOUT,EOUT,Y,D,E,OCLK,YIN,ICLK,ICE);
 input D,E,OCLK,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);


 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);

 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );


	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_ER ----

//---- MODULE IOBI_IR_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OB_ERE(DOUT,EOUT,Y,D,E,OCLK,OCE,YIN,ICLK);
 input D,E,OCLK,OCE,YIN,ICLK;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );




	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OB_ERE ----

//---- MODULE IOBI_IRE_OB_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OB_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OB_ERE(DOUT,EOUT,Y,D,E,OCLK,OCE,YIN,ICLK,ICE);
 input D,E,OCLK,OCE,YIN,ICLK,ICE;
 output DOUT,EOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(DOUT,D);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(EOUT, E,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);

 not INV_EN_2(ICE_2, ICE);

 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);



// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,ICE);
      buf U_c3 (Enable22, ICE);
      buf U_c5 (Enable24, ICE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_D_to_DOUT = (0.1:0.1:0.1);
	specparam tpdHL_D_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";

	//pin to pin path delay 

	(D => DOUT ) = ( tpdLH_D_to_DOUT, tpdHL_D_to_DOUT );

	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OB_ERE ----

//---- MODULE IOBI_IR_OR_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OR_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OR_EB(EOUT,DOUT,Y,E,D,OCLK,YIN,ICLK);
 input E,D,OCLK,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OR_EB ----

//---- MODULE IOBI_IRE_OR_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OR_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OR_EB(EOUT,DOUT,Y,E,D,OCLK,YIN,ICLK,ICE);
 input E,D,OCLK,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);


 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OR_EB ----

//---- MODULE IOBI_IR_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_ORE_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,YIN,ICLK);
 input E,D,OCLK,OCE,YIN,ICLK;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_ORE_EB ----

//---- MODULE IOBI_IRE_ORE_EB ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_ORE_EB
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_ORE_EB(EOUT,DOUT,Y,E,D,OCLK,OCE,YIN,ICLK,ICE);
 input E,D,OCLK,OCE,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 buf	BUF_U_00(EOUT,E);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable11,OCE);
      buf U_c2 (Enable12, OCE);
      buf U_c4 (Enable14, OCE);

      buf U_c1 (Enable21,ICE);
      buf U_c3 (Enable22, ICE);
      buf U_c5 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam tpdLH_E_to_EOUT = (0.1:0.1:0.1);
	specparam tpdHL_E_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

	specparam MacroType = "multi";

	//pin to pin path delay 

	(E => EOUT ) = ( tpdLH_E_to_EOUT, tpdHL_E_to_EOUT );


	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_ORE_EB ----

//---- MODULE IOBI_IR_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_OR_ER(EOUT,DOUT,Y,E,OCLK,D,YIN,ICLK);
 input E,OCLK,D,YIN,ICLK;
 output EOUT,DOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);

//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);

	//checking timing for control signals

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_OR_ER ----

//---- MODULE IOBI_IR_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IR_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IR_ORE_ERE(EOUT,DOUT,Y,E,OCLK,OCE,D,YIN,ICLK);
 input E,OCLK,OCE,D,YIN,ICLK;
 output EOUT,DOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;
 supply0 GND_2;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);

 not INV_EN_1(OCE_1, OCE);

 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);


 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, GND_2, NOTIFY_REG);


// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c1 (Enable11,OCE);
      buf U_c3 (Enable12, OCE);
      buf U_c5 (Enable14, OCE);


//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);



	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

	//checing the recovery data



 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IR_ORE_ERE ----

//---- MODULE IOBI_IRE_OR_ER ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_OR_ER
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_OR_ER(EOUT,DOUT,Y,E,OCLK,D,YIN,ICLK,ICE);
 input E,OCLK,D,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;
 supply1 VCC_0;
 supply0 GND_0;

 supply1 VCC_1;
 supply0 GND_1;

 supply1 VCC_2;


 reg NOTIFY_REG;


 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, GND_0, NOTIFY_REG);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, GND_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

      buf U_c0 (Enable21,ICE);
      buf U_c2 (Enable22, ICE);
      buf U_c4 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals


	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge D,0.0, NOTIFY_REG);


	//check timing delay for output

	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);

 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_OR_ER ----

//---- MODULE IOBI_IRE_ORE_ERE ----
/*--------------------------------------------------------------------
 CELL NAME : IOBI_IRE_ORE_ERE
 CELL TYPE : multi
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_IRE_ORE_ERE(EOUT,DOUT,Y,E,OCLK,OCE,D,YIN,ICLK,ICE);
 input E,OCLK,OCE,D,YIN,ICLK,ICE;
 output EOUT,DOUT,Y;
 supply1 VCC_0;

 supply1 VCC_1;

 supply1 VCC_2;


 reg NOTIFY_REG;

 not INV_EN_0(OCE_0, OCE);

 Dffpr DF_0(EOUT, E,OCLK,VCC_0, VCC_0, OCE_0, NOTIFY_REG);
 not INV_EN_1(OCE_1, OCE);
 Dffpr DF_1(DOUT, D,OCLK,VCC_1, VCC_1, OCE_1, NOTIFY_REG);
 not INV_EN_2(ICE_2, ICE);
 Dffpr DF_2(Y, YIN,ICLK,VCC_2, VCC_2, ICE_2, NOTIFY_REG);

// some temp signals created for timing checking sections

      buf U_c0 (Enable01,OCE);
      buf U_c2 (Enable02, OCE);
      buf U_c4 (Enable04, OCE);

      buf U_c1 (Enable11,OCE);
      buf U_c3 (Enable12, OCE);
      buf U_c5 (Enable14, OCE);

      buf U_c6 (Enable21,ICE);
      buf U_c7 (Enable22, ICE);
      buf U_c8 (Enable24, ICE);



//--------------------------------------------------------------
//              Timing Checking Section 
//-------------------------------------------------------------

 specify

	specparam   tpdLH_OCLK_to_EOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_EOUT = (0.1:0.1:0.1);

	specparam   tpdLH_OCLK_to_DOUT = (0.1:0.1:0.1);
	specparam   tpdHL_OCLK_to_DOUT = (0.1:0.1:0.1);

	specparam   tpdLH_ICLK_to_Y = (0.1:0.1:0.1);
	specparam   tpdHL_ICLK_to_Y = (0.1:0.1:0.1);

		specparam MacroType = "multi";



	//check timing delay for output

	(posedge OCLK => (EOUT +: E))=(tpdLH_OCLK_to_EOUT, tpdHL_OCLK_to_EOUT);

	//checking setup and hold timing for inputs

	$setup(posedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$setup(negedge E,posedge OCLK &&& Enable01, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, posedge E,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable01, negedge E,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge OCE,posedge OCLK,  0.0, NOTIFY_REG);
	$hold(posedge OCLK, posedge OCE,0.0, NOTIFY_REG);
	$setup(negedge OCE,posedge OCLK, 0.0, NOTIFY_REG);
	$hold(posedge OCLK, negedge OCE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge OCLK,0,  0, NOTIFY_REG);
	$width(negedge OCLK, 0, 0, NOTIFY_REG);

	//check timing delay for output

	(posedge OCLK => (DOUT +: D))=(tpdLH_OCLK_to_DOUT, tpdHL_OCLK_to_DOUT);

	//checking setup and hold timing for inputs

	$setup(posedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$setup(negedge D,posedge OCLK &&& Enable11, 0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, posedge D,0.0, NOTIFY_REG);
	$hold(posedge OCLK &&& Enable11, negedge D,0.0, NOTIFY_REG);


	(posedge ICLK => (Y +: YIN))=(tpdLH_ICLK_to_Y, tpdHL_ICLK_to_Y);

	//checking setup and hold timing for inputs

	$setup(posedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$setup(negedge YIN,posedge ICLK &&& Enable21, 0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, posedge YIN,0.0, NOTIFY_REG);
	$hold(posedge ICLK &&& Enable21, negedge YIN,0.0, NOTIFY_REG);

	//checking timing for control signals

	$setup(posedge ICE,posedge ICLK,  0.0, NOTIFY_REG);
	$hold(posedge ICLK, posedge ICE,0.0, NOTIFY_REG);
	$setup(negedge ICE,posedge ICLK, 0.0, NOTIFY_REG);
	$hold(posedge ICLK, negedge ICE,0.0, NOTIFY_REG);

	//checking the pulse width

	$width(posedge ICLK,0,  0, NOTIFY_REG);
	$width(negedge ICLK, 0, 0, NOTIFY_REG);


 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_IRE_ORE_ERE ----

//---- MODULE CLKBIBUF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKBIBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D@E % Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKBIBUF(Y,D,E,PAD);
 input D,E;
 output Y;
 inout PAD;
 reg NOTIFY_REG;

 bufif1   U1583(PAD, D, E);
 buf    BUF_U1(Y,PAD);

        specify
		specparam tpdLH_E_to_PAD = (0.0:0.0:0.0);
		specparam tpdHL_E_to_PAD = (0.0:0.0:0.0);
                specparam tpdLZ_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdZL_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdHZ_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdZH_E_to_PAD = (0.1:0.1:0.1);
                specparam tpdLH_D_to_PAD= (0.1:0.1:0.1);
                specparam tpdHL_D_to_PAD = (0.1:0.1:0.1);
                specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

            //if (~D)
                (E => PAD ) = ( tpdLH_E_to_PAD,tpdHL_E_to_PAD,tpdLZ_E_to_PAD,tpdZH_E_to_PAD,tpdHZ_E_to_PAD,tpdZL_E_to_PAD);

                (D => PAD ) = ( tpdLH_D_to_PAD,tpdHL_D_to_PAD);
                (D => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                (E => Y ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
                (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

                $width(negedge PAD, 0.0, 0, NOTIFY_REG);
                $width(posedge PAD, 0.0, 0, NOTIFY_REG);
                $width(negedge D, 0.0, 0, NOTIFY_REG);
                $width(posedge D, 0.0, 0, NOTIFY_REG);
                $width(negedge E, 0.0, 0, NOTIFY_REG);
                $width(posedge E, 0.0, 0, NOTIFY_REG);

        endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKBIBUF ----

//---- MODULE DDR_OUT ----
/*--------------------------------------------------------------------
 CELL NAME  : DDR_OUT
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DDR_OUT(Q,CLK,CLR,DR,DF);
input CLK,CLR,DR,DF;
output Q;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_1(tmp_out0, DR,CLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,CLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(Q,tmp_out0,tmp_out1,CLK);



 specify

         specparam   LibName     = "smartfusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$CLK = 2;
         specparam   OutputLoad$Q = 2;

         specparam   MacroType = "ddr_out";

          //check timing delay for output

        (CLK => Q)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (Q +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge DF,0.0, NOTIFY_REG);

           //checking timing for control signals


        $hold(posedge CLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge CLK,0,  0, NOTIFY_REG);
        $width(negedge CLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DDR_OUT ----

//---- MODULE DDR_REG ----
/*--------------------------------------------------------------------
 CELL NAME  : DDR_REG
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module DDR_REG(D,CLK,CLR,QR,QF);
input D, CLR, CLK;
output QR,QF;

wire tmp_out;
supply1 VCC;
supply0 GND;
reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
  
    Dffpf DF_0(tmp_out, D,       CLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_1(QF,      tmp_out, CLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(QR,      D,       CLK, CLR_, VCC, GND, NOTIFY_REG);


 specify

         specparam   LibName     = "smartfusion";
         specparam   InputLoad$YIN = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$ICLK = 2;
         specparam   OutputLoad$YR = 2;
         specparam   OutputLoad$YF = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (posedge CLK => (QR +: D))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (QR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (CLK => QF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (QF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge D,posedge CLK,0.0, NOTIFY_REG);
        $setup(negedge D,posedge CLK,0.0, NOTIFY_REG);
        $hold(posedge CLK,posedge D,0.0, NOTIFY_REG);
        $hold(posedge CLK,negedge D,0.0, NOTIFY_REG);

        $setup(posedge D,negedge CLK,0.0, NOTIFY_REG);
        $setup(negedge D,negedge CLK,0.0, NOTIFY_REG);
        $hold(negedge CLK,negedge D,0.0, NOTIFY_REG);
        $hold(negedge CLK,posedge D,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge CLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge CLK,0,  0, NOTIFY_REG);
        $width(negedge CLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge CLK, 0.0, NOTIFY_REG);


    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE DDR_REG ----

//---- MODULE IOBI_ID_OB_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OB_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OB_EB(D, CLR, E, ICLK, YIN, DOUT, EOUT, YR, YF);
input D, CLR, E, ICLK, YIN;
output DOUT, EOUT, YR, YF;

wire tmp_zd;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    buf buf_D(DOUT, D);
    buf buf_E(EOUT, E);
 
    not INV_CLR(CLR_, CLR);
    Dffpf DF_1(tmp_zd, YIN,    ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_2(YF,     tmp_zd, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_3(YR,     YIN,    ICLK, CLR_, VCC, GND, NOTIFY_REG);

    specify

        //check timing delay for output

        (D => DOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        
        (posedge CLR  => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR  => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        //(posedge ICLK => (YF +: YIN))  = (0.1:0.1:0.1, 0.1:0.1:0.1); // is this right??? no, negedge; no-edge is safe 
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge ICLK => (YR +: YIN))  = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN, posedge ICLK, 0.0, NOTIFY_REG);
        $setup(negedge YIN, posedge ICLK, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, posedge YIN, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, negedge YIN, 0.0, NOTIFY_REG);

        $setup(posedge YIN, negedge ICLK, 0.0, NOTIFY_REG);
        $setup(negedge YIN, negedge ICLK, 0.0, NOTIFY_REG);
        $hold(negedge ICLK, negedge YIN, 0.0, NOTIFY_REG);
        $hold(negedge ICLK, posedge YIN, 0.0, NOTIFY_REG);

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);
        $hold(posedge ICLK, negedge CLR, 0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK, 0, 0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR,  0, 0, NOTIFY_REG);

    endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OB_EB ----

//---- MODULE IOBI_ID_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OD_EB(E,DOUT,OCLK,CLR,DR,DF,YR,YF,ICLK,YIN,EOUT);
input YIN,E,OCLK,CLR,DR,DF,ICLK;
output DOUT,EOUT,YR,YF;

wire tmp_out, tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
    buf buf_inst(EOUT,E);
 
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

    Dffpf DF_3(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_4(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_5(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);




    specify

        //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

      //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);



    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OD_EB ----

//---- MODULE IOBI_ID_OD_ERC ----
/*--------------------------------------------------------------------
 CELL NAME  : IOBI_ID_OD_ERC
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOBI_ID_OD_ERC(E,DOUT,OCLK,CLR,DR,DF,YR,YF,ICLK,YIN,EOUT);
input E,OCLK,CLR,DR,DF,YIN,ICLK;
output DOUT,EOUT,YR,YF;

wire tmp_out, tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

    Dffpf DF_3(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_4(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_5(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);

    Dffpr DF_6(EOUT, E,OCLK,CLR_, VCC, GND, NOTIFY_REG);



   specify

        //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (EOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

      //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

        $setup(posedge E,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge E,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge E,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge E,0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOBI_ID_OD_ERC ----

//---- MODULE IOIN_ID ----
/*--------------------------------------------------------------------
 CELL NAME  : IOIN_ID
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOIN_ID(YIN,ICLK,CLR,YR,YF);
input YIN, CLR, ICLK;
output YR,YF;

wire tmp_out;
supply1 VCC;
supply0 GND;
reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
   
    Dffpf DF_0(tmp_out, YIN,     ICLK, VCC,  VCC, GND, NOTIFY_REG);
    Dffpr DF_1(YF,      tmp_out, ICLK, CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(YR,      YIN,     ICLK, CLR_, VCC, GND, NOTIFY_REG);


 specify

         specparam   LibName     = "smartfusion";
         specparam   InputLoad$YIN = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$ICLK = 2;
         specparam   OutputLoad$YR = 2;
         specparam   OutputLoad$YF = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (posedge ICLK => (YR +: YIN))=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YR +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (ICLK => YF) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (YF +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,posedge ICLK,0.0, NOTIFY_REG);
        $hold(posedge ICLK,posedge YIN,0.0, NOTIFY_REG);
        $hold(posedge ICLK,negedge YIN,0.0, NOTIFY_REG);

        $setup(posedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $setup(negedge YIN,negedge ICLK,0.0, NOTIFY_REG);
        $hold(negedge ICLK,negedge YIN,0.0, NOTIFY_REG);
        $hold(negedge ICLK,posedge YIN,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge ICLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge ICLK,0,  0, NOTIFY_REG);
        $width(negedge ICLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge ICLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOIN_ID ----

//---- MODULE IOTRI_OD_EB ----
/*--------------------------------------------------------------------
 CELL NAME  : IOTRI_OD_EB
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OD_EB(E,EOUT,DOUT,OCLK,CLR,DR,DF);
input E,OCLK,CLR,DR,DF;
output DOUT, EOUT;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);
    buf buf_inst(EOUT,E);
   
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);

specify

         specparam   LibName     = "smartfusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$OCLK = 2;
         specparam   OutputLoad$DOUT = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (E => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);


        //checking timing for control signals


        $hold(posedge OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);


    endspecify


endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OD_EB ----

//---- MODULE IOTRI_OD_ERC ----
/*--------------------------------------------------------------------
 CELL NAME  : IOTRI_OD_ERC
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOTRI_OD_ERC(E,EOUT,DOUT,OCLK,CLR,DR,DF);
input E,OCLK,CLR,DR,DF;
output DOUT, EOUT;

wire tmp_out0,tmp_out1;
supply1 VCC;
supply0 GND;

reg NOTIFY_REG;

    not INV_CLR(CLR_, CLR);

    Dffpr DF_0(EOUT,E,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_1(tmp_out0, DR,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    Dffpr DF_2(tmp_out1, DF,OCLK,CLR_, VCC, GND, NOTIFY_REG);
    UDP_MUX2 mux1(DOUT,tmp_out0,tmp_out1,OCLK);



 specify

         specparam   LibName     = "smartfusion";
         specparam   InputLoad$DR = 2;
         specparam   InputLoad$DF = 2;
         specparam   InputLoad$CLR = 6;
         specparam   InputLoad$OCLK = 2;
         specparam   OutputLoad$DOUT = 2;

         specparam   MacroType = "ddr";
         specparam   SeqType   = "flipflop";

          //check timing delay for output

        (OCLK => DOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (OCLK => EOUT)=(0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (DOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);
        (posedge CLR => (EOUT +: 1'b0)) = (0.1:0.1:0.1, 0.1:0.1:0.1);

        //checking setup and hold timing for inputs

        $setup(posedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DR,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DR,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DR,0.0, NOTIFY_REG);

        $setup(posedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge DF,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge DF,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge DF,0.0, NOTIFY_REG);

        //checking timing for control signals

        $hold(posedge   OCLK,negedge CLR,0.0, NOTIFY_REG);

        //checking the pulse width

        $width(posedge OCLK,0,  0, NOTIFY_REG);
        $width(negedge OCLK, 0, 0, NOTIFY_REG);
        $width(posedge CLR, 0.0, 0, NOTIFY_REG);

        //checing the recovery data

        $recovery(negedge CLR, posedge OCLK, 0.0, NOTIFY_REG);

        $setup(posedge E,posedge OCLK,0.0, NOTIFY_REG);
        $setup(negedge E,posedge OCLK,0.0, NOTIFY_REG);
        $hold(posedge OCLK,posedge E,0.0, NOTIFY_REG);
        $hold(posedge OCLK,negedge E,0.0, NOTIFY_REG);

   endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOTRI_OD_ERC ----

//---- MODULE FIFO4K18 ----
/*---------------------------------------------------------------
 CELL NAME : FIFO4K18
 CELL TYPE : FIFO
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 10 ps

module FIFO4K18 (AEVAL11, AEVAL10, AEVAL9, AEVAL8, AEVAL7, AEVAL6, 
                 AEVAL5, AEVAL4, AEVAL3, AEVAL2, AEVAL1, AEVAL0, 
                 AFVAL11, AFVAL10, AFVAL9, AFVAL8, AFVAL7, AFVAL6, 
                 AFVAL5, AFVAL4, AFVAL3, AFVAL2, AFVAL1, AFVAL0, 
                 REN, RBLK, RCLK, RESET, RPIPE, WEN, WBLK, WCLK,
                 RW2, RW1, RW0, WW2, WW1, WW0, ESTOP, FSTOP,
                 WD17, WD16, WD15, WD14, WD13, WD12, WD11, WD10, 
                 WD9, WD8, WD7, WD6, WD5, WD4, WD3, WD2, WD1, WD0, 
                 RD17, RD16, RD15, RD14, RD13, RD12, RD11, RD10, 
                 RD9, RD8, RD7, RD6, RD5, RD4, RD3, RD2, RD1, RD0, 
                 FULL, AFULL, EMPTY, AEMPTY
                );

input AEVAL11, AEVAL10, AEVAL9, AEVAL8, AEVAL7, AEVAL6;
input AEVAL5, AEVAL4, AEVAL3, AEVAL2, AEVAL1, AEVAL0;
input AFVAL11, AFVAL10, AFVAL9, AFVAL8, AFVAL7, AFVAL6;
input AFVAL5, AFVAL4, AFVAL3, AFVAL2, AFVAL1, AFVAL0;
input REN, RBLK, RCLK, RESET, RPIPE, WEN, WBLK, WCLK;
input RW2, RW1, RW0, WW2, WW1, WW0, ESTOP, FSTOP;
input WD17, WD16, WD15, WD14, WD13, WD12, WD11, WD10;
input WD9, WD8, WD7, WD6, WD5, WD4, WD3, WD2, WD1, WD0;

output RD17, RD16, RD15, RD14, RD13, RD12, RD11, RD10;
output RD9, RD8, RD7, RD6, RD5, RD4, RD3, RD2, RD1, RD0;
output FULL, AFULL, EMPTY, AEMPTY;

reg FULLP, AFULLP, EMPTYP, AEMPTYP;
reg [18:0] FIFO[0:512];
reg NOTIFY_REG;

wire AEVAL11_int, AEVAL10_int, AEVAL9_int, AEVAL8_int, AEVAL7_int;
wire AEVAL6_int, AEVAL5_int, AEVAL4_int, AEVAL3_int, AEVAL2_int;
wire AEVAL1_int, AEVAL0_int;
wire AFVAL11, AFVAL10_int, AFVAL9_int, AFVAL8_int, AFVAL7_int;
wire AFVAL6_int, AFVAL5_int, AFVAL4_int, AFVAL3_int, AFVAL2_int;
wire AFVAL1_int, AFVAL0_int;
wire REN_int, RBLK_int, RCLK_int, RESET_int, RPIPE_int;
wire WEN_int, WBLK_int, WCLK_int;
wire RW2_int, RW1_int, RW0_int;
wire WW2_int, WW1_int, WW0_int;
wire ESTOP_int, FSTOP_int;  
wire WD17_int, WD16_int, WD15_int, WD14_int, WD13_int, WD12_int;
wire WD11_int, WD10_int, WD9_int, WD8_int, WD7_int, WD6_int;
wire WD5_int, WD4_int, WD3_int, WD2_int, WD1_int, WD0_int;

reg RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9;
reg RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0;

reg RD17_stg, RD16_stg, RD15_stg, RD14_stg, RD13_stg, RD12_stg;
reg RD11_stg, RD10_stg, RD9_stg, RD8_stg, RD7_stg;
reg RD6_stg, RD5_stg, RD4_stg, RD3_stg, RD2_stg, RD1_stg, RD0_stg;

`define RDATAP_WIDTH_18 {RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9, RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0}
`define RWIDTH_CFG_VECTOR {RW2_int, RW1_int, RW0_int}
`define WWIDTH_CFG_VECTOR {WW2_int, WW1_int, WW0_int}
`define AEMPTY_CFG_VECTOR {AEVAL11_int, AEVAL10_int, AEVAL9_int, AEVAL8_int, AEVAL7_int, AEVAL6_int, AEVAL5_int, AEVAL4_int, AEVAL3_int, AEVAL2_int, AEVAL1_int, AEVAL0_int}
`define AFULL_CFG_VECTOR  {AFVAL11_int, AFVAL10_int, AFVAL9_int, AFVAL8_int, AFVAL7_int, AFVAL6_int, AFVAL5_int, AFVAL4_int, AFVAL3_int, AFVAL2_int, AFVAL1_int, AFVAL0_int}

integer MAX_DEPTH;

  
reg [4095:0] MEM;
reg [511 :0] MEM9;

wire WENABLE; 
wire RENABLE;

reg [3:0] mask;
reg RCLK_prev, WCLK_prev;  
reg RBLK_lastvalue = 1, RBLK_hold = 1;
reg WBLK_lastvalue = 1, WBLK_hold=1;
reg REN_lastvalue = 0, REN_hold=0;
reg WEN_lastvalue = 1, WEN_hold=1;
reg issue_WEN = 0;
reg issue_WBLK = 0;
reg issue_RBLK = 0;
reg issue_REN = 0; 
reg issue_afval = 0;
reg issue_aeval = 0;
reg [11:0] AFVAL_lastvalue = 0;
reg [11:0] AEVAL_lastvalue = 0;
reg [11:0] AFVAL_hold = 0;
reg [11:0] AEVAL_hold = 0;  
reg xor_aeval, xor_afval;
  
buf AFU0  (AFVAL0_int,  AFVAL0);
buf AFU1  (AFVAL1_int,  AFVAL1);
buf AFU2  (AFVAL2_int,  AFVAL2);
buf AFU3  (AFVAL3_int,  AFVAL3);
buf AFU4  (AFVAL4_int,  AFVAL4);
buf AFU5  (AFVAL5_int,  AFVAL5);
buf AFU6  (AFVAL6_int,  AFVAL6);
buf AFU7  (AFVAL7_int,  AFVAL7);
buf AFU8  (AFVAL8_int,  AFVAL8);
buf AFU9  (AFVAL9_int,  AFVAL9);
buf AFU10 (AFVAL10_int, AFVAL10);
buf AFU11 (AFVAL11_int, AFVAL11);

buf AEU0  (AEVAL0_int,  AEVAL0);
buf AEU1  (AEVAL1_int,  AEVAL1);
buf AEU2  (AEVAL2_int,  AEVAL2);
buf AEU3  (AEVAL3_int,  AEVAL3);
buf AEU4  (AEVAL4_int,  AEVAL4);
buf AEU5  (AEVAL5_int,  AEVAL5);
buf AEU6  (AEVAL6_int,  AEVAL6);
buf AEU7  (AEVAL7_int,  AEVAL7);
buf AEU8  (AEVAL8_int,  AEVAL8);
buf AEU9  (AEVAL9_int,  AEVAL9);
buf AEU10 (AEVAL10_int, AEVAL10);
buf AEU11 (AEVAL11_int, AEVAL11);

buf WDU0  (WD0_int,     WD0);
buf WDU1  (WD1_int,     WD1);
buf WDU2  (WD2_int,     WD2);
buf WDU3  (WD3_int,     WD3);
buf WDU4  (WD4_int,     WD4);
buf WDU5  (WD5_int,     WD5);
buf WDU6  (WD6_int,     WD6);
buf WDU7  (WD7_int,     WD7);
buf WDU8  (WD8_int,     WD8);
buf WDU9  (WD9_int,     WD9);
buf WDU10 (WD10_int,    WD10);
buf WDU11 (WD11_int,    WD11);
buf WDU12 (WD12_int,    WD12);
buf WDU13 (WD13_int,    WD13);
buf WDU14 (WD14_int,    WD14);
buf WDU15 (WD15_int,    WD15);
buf WDU16 (WD16_int,    WD16);
buf WDU17 (WD17_int,    WD17);

buf WWU2  (WW2_int,     WW2);
buf WWU1  (WW1_int,     WW1);
buf WWU0  (WW0_int,     WW0);

buf RWU2  (RW2_int,     RW2);
buf RWU1  (RW1_int,     RW1);
buf RWU0  (RW0_int,     RW0);

buf RENU  (REN_int,     REN);
buf WENU  (WEN_int,     WEN);
buf RBLKU (RBLK_int,    RBLK);
buf WBLKU (WBLK_int,    WBLK);

buf WCLKU (WCLK_int,    WCLK);
buf RCLKU (RCLK_int,    RCLK);

buf RESETU (RESET_int,  RESET);
buf ESTOPU (ESTOP_int,  ESTOP);
buf FSTOPU (FSTOP_int,  FSTOP);
buf RPIPEU (RPIPE_int,  RPIPE);


pmos RDU0  (RD0,  RDP0,  0);
pmos RDU1  (RD1,  RDP1,  0);
pmos RDU2  (RD2,  RDP2,  0);
pmos RDU3  (RD3,  RDP3,  0);
pmos RDU4  (RD4,  RDP4,  0);
pmos RDU5  (RD5,  RDP5,  0);
pmos RDU6  (RD6,  RDP6,  0);
pmos RDU7  (RD7,  RDP7,  0);
pmos RDU8  (RD8,  RDP8,  0);
pmos RDU9  (RD9,  RDP9,  0);
pmos RDU10 (RD10, RDP10, 0);
pmos RDU11 (RD11, RDP11, 0);
pmos RDU12 (RD12, RDP12, 0);
pmos RDU13 (RD13, RDP13, 0);
pmos RDU14 (RD14, RDP14, 0);
pmos RDU15 (RD15, RDP15, 0);
pmos RDU16 (RD16, RDP16, 0);
pmos RDU17 (RD17, RDP17, 0);

pmos AEMPTYU (AEMPTY, AEMPTYP, 0);
pmos EMPTYU  (EMPTY,  EMPTYP,  0);
pmos AFULLU  (AFULL,  AFULLP,  0);
pmos FULLU   (FULL,   FULLP,   0);

integer MAX_ADDR;
integer WADDR;
integer WADDR_P1;
integer WADDR_P2;
integer RADDR;
integer RADDR_P1;
integer RADDR_P2;
integer BIT_WADDR;
integer BIT_RADDR;
integer WADDR_wrap;
integer WADDR_wrap_P1;
integer WADDR_wrap_P2;
integer RADDR_wrap;
integer RADDR_wrap_P1;
integer RADDR_wrap_P2;

integer AEVAL;
integer AFVAL;

integer wdepth;
integer rdepth;


assign WENABLE = RESET_int & ~WEN_int & ~WBLK_int; 
assign RENABLE = RESET_int &  REN_int & ~RBLK_int; 

  always @(WCLK_int or RESET_int)
      begin
	  if (WCLK_int === 1'bx && RESET_int == 1 ) begin
	      $display("Warning : WCLK went unknown at time %0.1f\n", $realtime);
	  end
      end

  always @(RCLK_int or RESET_int or RENABLE)
      begin
	  if (RCLK_int === 1'bx && RESET_int == 1 ) begin
	      $display("Warning : RCLK went unknown at time %0.1f\n", $realtime);
	      if (RENABLE == 1'b1) begin
		  `RDATAP_WIDTH_18 <= 18'bx;
	      end // if (RENABLE == 1'b1)
	  end 
      end 
    
always @(WCLK_int)
    begin
	WCLK_prev <= WCLK_int;
    end 
  
always @(RCLK_int)
    begin
	RCLK_prev <= RCLK_int;
    end 

  always @(RBLK_int)
      begin
	  RBLK_hold <=  RBLK_int;
	  RBLK_lastvalue <= RBLK_hold;
      end 

 always @(REN_int)
      begin
	  REN_hold <=  REN_int;
	  REN_lastvalue <= REN_hold;
      end  

  always @(WBLK_int)
      begin
	  WBLK_lastvalue <= WBLK_hold;	  
	  WBLK_hold <=  WBLK_int;
      end 
 
 always @(WEN_int)
      begin
	  WEN_hold <=  WEN_int;
	  WEN_lastvalue <= WEN_hold;
      end 

 always @(`AFULL_CFG_VECTOR)
      begin
	  AFVAL_hold <=  `AFULL_CFG_VECTOR;
	  AFVAL_lastvalue <= AFVAL_hold;
      end       

always @(`AEMPTY_CFG_VECTOR)
      begin
	  AEVAL_hold <=  `AEMPTY_CFG_VECTOR;
	  AEVAL_lastvalue <= AEVAL_hold;
      end       
  
// FIFO RESET behavior section

always @(RESET_int) begin
  if (RESET_int == 1'b0) begin
    WADDR         <= 0;
    WADDR_P1      <= 0;
    WADDR_P2      <= 0;
    WADDR_wrap    <= 0;
    WADDR_wrap_P1 <= 0;
    WADDR_wrap_P2 <= 0;
    RADDR         <= 0;
    RADDR_P1      <= 0;
    RADDR_P2      <= 0;
    RADDR_wrap    <= 0;
    RADDR_wrap_P1 <= 1;
    RADDR_wrap_P2 <= 1;
    FULLP         <= 1'b0;
    EMPTYP        <= 1'b1;
    AFULLP        <= 1'b0;
    AEMPTYP       <= 1'b1;
    `RDATAP_WIDTH_18 <= 18'b0;
    RD0_stg       <= 1'b0;
    RD1_stg       <= 1'b0;
    RD2_stg       <= 1'b0;
    RD3_stg       <= 1'b0;
    RD4_stg       <= 1'b0;
    RD5_stg       <= 1'b0;
    RD6_stg       <= 1'b0;
    RD7_stg       <= 1'b0;
    RD8_stg       <= 1'b0;
    RD9_stg       <= 1'b0;
    RD10_stg      <= 1'b0;
    RD11_stg      <= 1'b0;
    RD12_stg      <= 1'b0;
    RD13_stg      <= 1'b0;
    RD14_stg      <= 1'b0;
    RD15_stg      <= 1'b0;
    RD16_stg      <= 1'b0;
    RD17_stg      <= 1'b0;
      
  end else if (RESET_int === 1'bx) begin
      if ($time > 0) begin
	  $display("Warning : RESET went unknown at time %0.1f\n", $realtime);
      end
  end
end

  // FIFO WRITE behavior section

always @(posedge WCLK_int ) begin
  if (RESET_int == 1'b1 && WCLK_prev == 1'b0 && WCLK_int == 1'b1 ) begin
    // Synchronizer needs two WCLKs to generate empty flag
      RADDR_P2 = RADDR_P1;
      RADDR_P1 = RADDR;
      RADDR_wrap_P2 = RADDR_wrap_P1;
 if (RADDR_wrap == 0) 
      RADDR_wrap_P1 = 1;
    else
      RADDR_wrap_P1 = 0;

    if ((WBLK_int == 1'b0) && (WEN_int == 1'b0)) begin
      if ( ! ((FULLP == 1'b1) && (FSTOP_int == 1'b1))) begin
        case (`WWIDTH_CFG_VECTOR)
          3'b000 : begin
            MEM[WADDR] <= WD0_int;
            wdepth = 4096;
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b001 : begin
            MEM[(WADDR * 2) + 0] <= WD0_int;
            MEM[(WADDR * 2) + 1] <= WD1_int;
            wdepth = 2048;
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b010 : begin
            MEM[(WADDR * 4) + 0] <= WD0_int;
            MEM[(WADDR * 4) + 1] <= WD1_int;
            MEM[(WADDR * 4) + 2] <= WD2_int;
            MEM[(WADDR * 4) + 3] <= WD3_int;
            wdepth = 1024; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          3'b011 : begin
            MEM[(WADDR * 8) + 0] <= WD0_int;
            MEM[(WADDR * 8) + 1] <= WD1_int;
            MEM[(WADDR * 8) + 2] <= WD2_int;
            MEM[(WADDR * 8) + 3] <= WD3_int;
            MEM[(WADDR * 8) + 4] <= WD4_int;
            MEM[(WADDR * 8) + 5] <= WD5_int;
            MEM[(WADDR * 8) + 6] <= WD6_int;
            MEM[(WADDR * 8) + 7] <= WD7_int;
            MEM9[WADDR] = WD8_int;
            wdepth = 512; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
		
            end
          end
          3'b100 : begin
            MEM[(WADDR * 16) + 0] <= WD0_int;
            MEM[(WADDR * 16) + 1] <= WD1_int;
            MEM[(WADDR * 16) + 2] <= WD2_int;
            MEM[(WADDR * 16) + 3] <= WD3_int;
            MEM[(WADDR * 16) + 4] <= WD4_int;
            MEM[(WADDR * 16) + 5] <= WD5_int;
            MEM[(WADDR * 16) + 6] <= WD6_int;
            MEM[(WADDR * 16) + 7] <= WD7_int;
            MEM9[WADDR *   2 + 0] <= WD8_int;
            MEM[(WADDR * 16) + 8] <= WD9_int;
            MEM[(WADDR * 16) + 9] <= WD10_int;
            MEM[(WADDR * 16) + 10] <= WD11_int;
            MEM[(WADDR * 16) + 11] <= WD12_int;
            MEM[(WADDR * 16) + 12] <= WD13_int;
            MEM[(WADDR * 16) + 13] <= WD14_int;
            MEM[(WADDR * 16) + 14] <= WD15_int;
            MEM[(WADDR * 16) + 15] <= WD16_int;
            MEM9[WADDR * 2 + 1] <= WD17_int;
            wdepth = 256; 
            if (WADDR < wdepth - 1 ) begin
              WADDR = #0 WADDR + 1;
            end else begin
              WADDR = #0 0;
              WADDR_wrap = 1 - WADDR_wrap;
            end
          end
          default: begin
	      $display("Warning: Illegal Write port width configuration");
          end
	endcase
      end // not (FULL and FSTOP)
	else if(FSTOP === 1'bx)
	    begin
		$display("Warning : FSTOP is unknown");
		$display("When FULL, to stop writing set FSTOP = 1, to overwrite set FSTOP= 0");
		$display("Time : %0.1fns Instance : %m",$realtime);
	    end 
	
    end // WBLK = 0 and WEN = 0
      else begin
	  if (WBLK_int === 1'bx &&  issue_WBLK == 0 && (WEN_int ==0 ||
							WEN_int === 1'bx))
	      begin
		  if ( WBLK_lastvalue !== 1'bx)
		      begin
			  $display("Warning : WBLK signal is unknown");
			  $display("Time : %0.1fns Instance : %m",$realtime);
			  issue_WBLK = 1;
		      end 
	      end 
	  else if(WBLK_int !== 1'bx)
	      issue_WBLK = 0;
	  
	  if (WEN_int === 1'bx && issue_WEN == 0 && (WBLK_int == 0 ||
						     WBLK_int === 1'bx))
	      begin
		  if ( WEN_lastvalue !== 1'bx)
		      begin	      
			  $display("Warning : WEN signal is unknown");
			  $display("Time : %0.1fns Instance : %m",$realtime);
			  issue_WEN = 1;
		      end // if ( WEN_lastvalue !== 1'bx)
	      end // if (WEN_int === 1'bx && issue_WEN == 0)
	  else if(WEN_int !== 1'bx)
	      issue_WEN = 0;
	  
      end 

      fifo_flags(`AFULL_CFG_VECTOR, `AEMPTY_CFG_VECTOR, `RWIDTH_CFG_VECTOR,
		 `WWIDTH_CFG_VECTOR);

      mask = get_mask(`RWIDTH_CFG_VECTOR,`WWIDTH_CFG_VECTOR);
      xor_afval = ^ (`AFULL_CFG_VECTOR & {8'hff,mask});
      if ( xor_afval !== 1'bx)
	  issue_afval = 0;
      else if ( xor_afval === 1'bx && issue_afval == 0)
	  begin
	      $display("Warning : Invalid AFVAL %b",`AFULL_CFG_VECTOR);
	      $display("Holding the value of AFULL FLAG ");
	      $display("Time : %0.1fns Instance : %m",$realtime);
	      issue_afval = 1;	  
	  end 

  end // if RESET deasserted
end  // Write section

  // FIFO READ behavior section

  always @(posedge RCLK_int) begin
      if (RESET_int == 1'b1  && RCLK_prev == 1'b0 && RCLK_int == 1'b1) begin
    // Synchronizer needs two RCLKs to generate empty flag
      WADDR_P2 = WADDR_P1;
      WADDR_P1 = WADDR;
      WADDR_wrap_P2 = WADDR_wrap_P1;
      WADDR_wrap_P1 = WADDR_wrap;
 
    if (RPIPE_int == 1'b1) begin // Pipelining on
      RDP0  <= RD0_stg;
      RDP1  <= RD1_stg;
      RDP2  <= RD2_stg;
      RDP3  <= RD3_stg;
      RDP4  <= RD4_stg;
      RDP5  <= RD5_stg;
      RDP6  <= RD6_stg;
      RDP7  <= RD7_stg;
      RDP8  <= RD8_stg;
      RDP9  <= RD9_stg;
      RDP10 <= RD10_stg;
      RDP11 <= RD11_stg;
      RDP12 <= RD12_stg;
      RDP13 <= RD13_stg;
      RDP14 <= RD14_stg;
      RDP15 <= RD15_stg;
      RDP16 <= RD16_stg;
      RDP17 <= RD17_stg;
    end
    else if (RPIPE_int === 1'bx ) begin // RPIPE unknown
      $display("Warning : RPIPE signal unknown.");

      RDP0  <= 1'bx;
      RDP1  <= 1'bx;
      RDP2  <= 1'bx;
      RDP3  <= 1'bx;
      RDP4  <= 1'bx;
      RDP5  <= 1'bx;
      RDP6  <= 1'bx;
      RDP7  <= 1'bx;
      RDP8  <= 1'bx;
      RDP9  <= 1'bx;
      RDP10 <= 1'bx;
      RDP11 <= 1'bx;
      RDP12 <= 1'bx;
      RDP13 <= 1'bx;
      RDP14 <= 1'bx;
      RDP15 <= 1'bx;
      RDP16 <= 1'bx;
      RDP17 <= 1'bx;
    end

    if ((RBLK_int == 1'b0) && (REN_int == 1'b1)) begin
      if ( ! ((EMPTYP == 1'b1) && (ESTOP_int == 1'b1))) begin // OK to Read
        if (RPIPE_int == 1'b0) begin // Pipelining off 
          case (`RWIDTH_CFG_VECTOR)
            3'b000 : begin
              RDP0  <= MEM[RADDR];
              rdepth = 4096;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b001 : begin
              RDP0  <= MEM[(RADDR * 2) + 0];
              RDP1  <= MEM[(RADDR * 2) + 1];
              rdepth = 2048;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b010 : begin
              RDP0  <= MEM[(RADDR * 4) + 0];
              RDP1  <= MEM[(RADDR * 4) + 1];
              RDP2  <= MEM[(RADDR * 4) + 2];
              RDP3  <= MEM[(RADDR * 4) + 3];
              rdepth = 1024;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b011 : begin
              RDP0  <= MEM[(RADDR * 8) + 0];
              RDP1  <= MEM[(RADDR * 8) + 1];
              RDP2  <= MEM[(RADDR * 8) + 2];
              RDP3  <= MEM[(RADDR * 8) + 3];
              RDP4  <= MEM[(RADDR * 8) + 4];
              RDP5  <= MEM[(RADDR * 8) + 5];
              RDP6  <= MEM[(RADDR * 8) + 6];
              RDP7  <= MEM[(RADDR * 8) + 7];
              RDP8  <= MEM9[RADDR];
              rdepth = 512;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b100 : begin
              RDP0  <= MEM[(RADDR * 16) + 0];
              RDP1  <= MEM[(RADDR * 16) + 1];
              RDP2  <= MEM[(RADDR * 16) + 2];
              RDP3  <= MEM[(RADDR * 16) + 3];
              RDP4  <= MEM[(RADDR * 16) + 4];
              RDP5  <= MEM[(RADDR * 16) + 5];
              RDP6  <= MEM[(RADDR * 16) + 6];
              RDP7  <= MEM[(RADDR * 16) + 7];
              RDP8  <= MEM9[RADDR*2 +0];
              RDP9  <= MEM[(RADDR * 16) + 8];
              RDP10 <= MEM[(RADDR * 16) + 9];
              RDP11 <= MEM[(RADDR * 16) + 10];
              RDP12 <= MEM[(RADDR * 16) + 11];
              RDP13 <= MEM[(RADDR * 16) + 12];
              RDP14 <= MEM[(RADDR * 16) + 13];
              RDP15 <= MEM[(RADDR * 16) + 14];
              RDP16 <= MEM[(RADDR * 16) + 15];
              RDP17 <= MEM9[RADDR * 2 + 1];
              rdepth = 256;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            default: begin
              $display("Warning: Illegal Read port width configuration");
            end
          endcase
        end else if (RPIPE_int == 1'b1) begin // Pipelining on
          case (`RWIDTH_CFG_VECTOR)
            3'b000 : begin
              RD0_stg  <= MEM[RADDR];
              rdepth = 4096;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b001 : begin
              RD0_stg  <= MEM[(RADDR * 2) + 0];
              RD1_stg  <= MEM[(RADDR * 2) + 1];
              rdepth = 2048;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b010 : begin
              RD0_stg  <= MEM[(RADDR * 4) + 0];
              RD1_stg  <= MEM[(RADDR * 4) + 1];
              RD2_stg  <= MEM[(RADDR * 4) + 2];
              RD3_stg  <= MEM[(RADDR * 4) + 3];
              rdepth = 1024;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b011 : begin
              RD0_stg  <= MEM[(RADDR * 8) + 0];
              RD1_stg  <= MEM[(RADDR * 8) + 1];
              RD2_stg  <= MEM[(RADDR * 8) + 2];
              RD3_stg  <= MEM[(RADDR * 8) + 3];
              RD4_stg  <= MEM[(RADDR * 8) + 4];
              RD5_stg  <= MEM[(RADDR * 8) + 5];
              RD6_stg  <= MEM[(RADDR * 8) + 6];
              RD7_stg  <= MEM[(RADDR * 8) + 7];
              RD8_stg  <= MEM9[RADDR];
              rdepth = 512;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            3'b100 : begin
              RD0_stg  <= MEM[(RADDR * 16) + 0];
              RD1_stg  <= MEM[(RADDR * 16) + 1];
              RD2_stg  <= MEM[(RADDR * 16) + 2];
              RD3_stg  <= MEM[(RADDR * 16) + 3];
              RD4_stg  <= MEM[(RADDR * 16) + 4];
              RD5_stg  <= MEM[(RADDR * 16) + 5];
              RD6_stg  <= MEM[(RADDR * 16) + 6];
              RD7_stg  <= MEM[(RADDR * 16) + 7];
              RD8_stg  <= MEM9[RADDR*2 +0];
              RD9_stg  <= MEM[(RADDR * 16) + 8];
              RD10_stg <= MEM[(RADDR * 16) + 9];
              RD11_stg <= MEM[(RADDR * 16) + 10];
              RD12_stg <= MEM[(RADDR * 16) + 11];
              RD13_stg <= MEM[(RADDR * 16) + 12];
              RD14_stg <= MEM[(RADDR * 16) + 13];
              RD15_stg <= MEM[(RADDR * 16) + 14];
              RD16_stg <= MEM[(RADDR * 16) + 15];
              RD17_stg <= MEM9[RADDR * 2 + 1];
              rdepth = 256;
              if (RADDR < rdepth - 1) begin
                RADDR = #0 RADDR + 1;
              end else begin
                RADDR = #0 0;
                RADDR_wrap = 1 - RADDR_wrap;
              end
            end
            default: begin
              $display("Warning: Illegal Read port width configuration");
            end
          endcase
        end // RPIPE == 1
      end // if (EMPTY and ESTOP)
	else if (ESTOP === 1'bx )
	    begin
		$display("Warning : ESTOP is unknown");
		$display("When FIFO is EMPTY, to stop reading ESTOP=1 or to continue reading old data ESTOP=0");
		$display("Time : %0.1fns Instance : %m",$realtime);
	    end 
    end // if REN = 1 and RBLK = 0

      else begin
	  if (RBLK_int === 1'bx &&  issue_RBLK == 0 && (REN_int == 1 ||
							REN_int === 1'bx) )
	      begin
		  if ( RBLK_lastvalue !== 1'bx)
		      begin
			  $display("Warning : RBLK signal is unknown");
			  $display("Time : %0.1fns Instance : %m",$realtime);
			  issue_RBLK = 1;
		      end 
	      end 
	  else if(RBLK_int !== 1'bx)
	      issue_RBLK = 0;
	  
	  if (REN_int === 1'bx && issue_REN == 0 && (RBLK_int == 0 ||
						     RBLK_int === 1'bx))
	      begin
		  if ( REN_lastvalue !== 1'bx)
		      begin	      
			  $display("Warning : REN signal is unknown");
			  $display("Time : %0.1fns Instance : %m",$realtime);
			  issue_REN = 1;
		      end 
	      end 
	  else if (REN_int !== 1'bx )
	      issue_REN = 0;
      end 
      
	  fifo_flags(`AFULL_CFG_VECTOR, `AEMPTY_CFG_VECTOR,
		     `RWIDTH_CFG_VECTOR, `WWIDTH_CFG_VECTOR);
	  mask = get_mask(`RWIDTH_CFG_VECTOR,`WWIDTH_CFG_VECTOR);
	  xor_aeval = ^ (`AFULL_CFG_VECTOR & {8'hff,mask});
	  if ( xor_aeval !== 1'bx)
	      issue_aeval = 0;
	  else if ( xor_aeval === 1'bx && issue_aeval == 0)
	      begin
		  $display("Warning : Invalid AEVAL %b",`AEMPTY_CFG_VECTOR);
		  $display("Holding the value of AEMPTY FLAG ");
		  $display("Time : %0.1fns Instance : %m",$realtime);
		  issue_aeval = 1;	  
	      end 
      end // if RESET deasserted
  end // Read section
  
function integer get_rel_value;
   input [11:0] addr_signal;
   input [3:0] 	mask;
   integer 	value;
    begin
	value =  addr_signal[11] * 2048 + addr_signal[10] * 1024 
		 + addr_signal[9] *  512  + addr_signal[8]  * 256
		 + addr_signal[7] *  128  + addr_signal[6]  * 64 
		 + addr_signal[5] *  32   + addr_signal[4]  * 16
		 + (addr_signal[3] & mask[3]) * 8
		 + (addr_signal[2] & mask[2]) * 4 
		 + (addr_signal[1] & mask[1]) * 2
		 + (addr_signal[0] & mask[0]) * 1;
	
	get_rel_value = value / (16-mask);
    end
endfunction

function [3:0] get_mask;
     input [2:0] rw;
     input [2:0] ww;
     reg [3:0] 	 rmask,wmask;
      begin
	  rmask = 4'b1111 << rw;
	  wmask = 4'b1111 << ww;
	  get_mask = rmask & wmask;
      end
endfunction // get_mask
  
task fifo_flags;

  input [11:0] afval_cfg_bus;
  input [11:0] aeval_cfg_bus;
  input [2:0]  rwidth_cfg_bus; 
  input [2:0]  wwidth_cfg_bus;

  integer raddr_rel;
  integer raddr_rel_p2;
  integer waddr_rel;
  integer waddr_rel_p2;    
  integer afval_rel, aeval_rel;    
  integer rel_depth;
   integer num_fifo_entries;
 
    begin
	if (^(wwidth_cfg_bus) === 1'bx || (wwidth_cfg_bus > 4))
	    begin
		$display("Warning: Illegal Write port width configuration");
	    end
	else if (^(rwidth_cfg_bus) === 1'bx || (rwidth_cfg_bus > 4))
	    begin
		$display("Warning: Illegal Read port width configuration");
	    end	    
	else if (wwidth_cfg_bus >= rwidth_cfg_bus)
	    begin
		
		raddr_rel = RADDR >> (wwidth_cfg_bus - rwidth_cfg_bus);
		raddr_rel_p2 = RADDR_P2 >> (wwidth_cfg_bus - rwidth_cfg_bus);
		waddr_rel = WADDR;
		waddr_rel_p2 = WADDR_P2;
		rel_depth = 1 << (12 - wwidth_cfg_bus);
	    end 
	else
	    begin
		waddr_rel = WADDR >> (rwidth_cfg_bus - wwidth_cfg_bus);
		waddr_rel_p2 = WADDR_P2 >> (rwidth_cfg_bus - wwidth_cfg_bus);
		raddr_rel = RADDR;
		raddr_rel_p2 = RADDR_P2;
		rel_depth = 1 << (12 - rwidth_cfg_bus);
	    end 

      aeval_rel = get_rel_value(aeval_cfg_bus, get_mask(rwidth_cfg_bus, wwidth_cfg_bus));
      afval_rel = get_rel_value(afval_cfg_bus, get_mask(rwidth_cfg_bus, wwidth_cfg_bus));
 
    // Pipelined addresses used for FULL and EMPTY calculations

	if ((WADDR_wrap == RADDR_wrap_P2) && (waddr_rel == raddr_rel_p2))
	    FULLP = 1'b1;
	else
	    FULLP = 1'b0;

	if ((RADDR_wrap == WADDR_wrap_P2) && (waddr_rel_p2 == raddr_rel))
	    EMPTYP = 1'b1;
	else
	    EMPTYP = 1'b0;

	//Number of FIFO ENTRIES	
	if (waddr_rel >= raddr_rel)
	    num_fifo_entries = waddr_rel - raddr_rel;
	else
	    num_fifo_entries = rel_depth + waddr_rel - raddr_rel;
	//aempty, afull generation
	if (FULLP == 1'b1)
	    AEMPTYP = 1'b0;
	else
	    begin
		if (num_fifo_entries > aeval_rel) 
		    AEMPTYP = 1'b0;
		else if (num_fifo_entries <= aeval_rel)
		    AEMPTYP = 1'b1;
	    end 

	if (EMPTYP == 1'b1) 
	    AFULLP = 1'b0;
	else if (FULLP == 1'b1) 
	    AFULLP = 1'b1;
	else
	    begin
		if (num_fifo_entries < afval_rel) 
		    AFULLP = 1'b0;
		else if (num_fifo_entries >= afval_rel)  
		    AFULLP = 1'b1;
	    end
    end
endtask
 
specify

      specparam   LibName     = "smartfusion";
      
      (posedge RCLK => (RD0+:RD0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD1+:RD1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD2+:RD2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD3+:RD3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD4+:RD4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD5+:RD5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD6+:RD6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD7+:RD7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD8+:RD8) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD9+:RD9) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD10+:RD10) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD11+:RD11) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD12+:RD12) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD13+:RD13) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD14+:RD14) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD15+:RD15) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD16+:RD16) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge RCLK => (RD17+:RD17) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge RCLK => (EMPTY +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      if (AEMPTYP)
      (posedge RCLK => (AEMPTY+: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      if (!AFULLP)
      (posedge RCLK => (AFULL +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      if (!AEMPTYP)
      (posedge WCLK => (AEMPTY+: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      if (AFULLP)
      (posedge WCLK => (AFULL +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (posedge WCLK => (FULL  +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge RESET => (RD0+:RD0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD1+:RD1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD2+:RD2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD3+:RD3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD4+:RD4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD5+:RD5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD6+:RD6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD7+:RD7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD8+:RD8) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD9+:RD9) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD10+:RD10) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD11+:RD11) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD12+:RD12) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD13+:RD13) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD14+:RD14) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD15+:RD15) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD16+:RD16) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (RD17+:RD17) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge RESET => (EMPTY +: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (AEMPTY+: 1'b1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (FULL  +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge RESET => (AFULL +: 1'b0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG);
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG);
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG);
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG);
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG);
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG);
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG);
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG);
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG);
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG);
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG);
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG);
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG);
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG);
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG);
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG);
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WEN, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, posedge WEN, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, negedge WEN, 0.0, NOTIFY_REG);
      $setup(posedge WBLK, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WBLK, posedge WCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, posedge WBLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK &&& RESET, negedge WBLK, 0.0, NOTIFY_REG);

      $setup(posedge FSTOP, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge FSTOP, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge FSTOP, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge FSTOP, 0.0, NOTIFY_REG);

      $setup(posedge WW2, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW2, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW2, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW2, 0.0, NOTIFY_REG);
      $setup(posedge WW1, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW1, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW1, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW1, 0.0, NOTIFY_REG);
      $setup(posedge WW0, posedge WCLK, 0.0, NOTIFY_REG);
      $setup(negedge WW0, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge WW0, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, negedge WW0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, negedge REN, 0.0, NOTIFY_REG);
      $setup(posedge RBLK, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge RBLK, posedge RCLK &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, posedge RBLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RESET, negedge RBLK, 0.0, NOTIFY_REG);

      $setup(posedge ESTOP, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge ESTOP, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge ESTOP, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge ESTOP, 0.0, NOTIFY_REG);

      $setup(posedge RW2, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW2, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW2, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW2, 0.0, NOTIFY_REG);
      $setup(posedge RW1, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW1, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW1, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW1, 0.0, NOTIFY_REG);
      $setup(posedge RW0, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge RW0, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RW0, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge RW0, 0.0, NOTIFY_REG);

      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK, posedge RESET, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);

endspecify

endmodule
`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FIFO4K18 ----

//---- MODULE UJTAG ----
//------------------------
// CELL NAME: UJTAG
//------------------------

/*
 * Simple TAP for simulation of designs using the ProASIC user JTAG interface
 * Note:
 * 1. This TAP is not a model of the actual TAP used in the ProASIC. The
 *    only instruction implemented is BYPASS. An instruction scan operation
 *    will capture the pattern 8'bxxxxxx01
 * 2. This model should not be used for the A500K family, as it uses
 *    a different set of interface signals.
 *
 */

`timescale 1ns/10ps

`define Bypass            8'hff

`define Test_Logic_Reset  4'hf
`define Run_Test_Idle     4'hc
`define Select_DR         4'h7
`define Capture_DR        4'h6
`define Shift_DR          4'h2
`define Exit1_DR          4'h1
`define Pause_DR          4'h3
`define Exit2_DR          4'h0
`define Update_DR         4'h5
`define Select_IR         4'h4
`define Capture_IR        4'he
`define Shift_IR          4'ha
`define Exit1_IR          4'h9
`define Pause_IR          4'hb
`define Exit2_IR          4'h8
`define Update_IR         4'hd

module UJTAG ( UIREG0, UIREG1, UIREG2, UIREG3, UIREG4, UIREG5, UIREG6, UIREG7,
               URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD, UTDI, UTDO,
               TDO, TMS, TDI, TCK, TRSTB );

output  UIREG0, UIREG1, UIREG2, UIREG3, UIREG4, UIREG5, UIREG6, UIREG7;

output  UTDI, URSTB, UDRCK, UDRCAP, UDRSH, UDRUPD;
input   UTDO;

input   TMS, TDI, TCK, TRSTB;
output  TDO;

reg [3:0] STATE;
reg [7:0] IR, SHREG;
//reg       TDO, UDRUPD, UDRCAP, UDRSH;
reg       TDO_zd, UDRUPD_zd, UDRCAP_zd, UDRSH_zd, URSTB_zd;
reg       NOTIFY_REG;

buf  buf_tdi      ( TDI_int,   TDI   );
buf  buf_tms      ( TMS_int,   TMS   );
buf  buf_tck      ( TCK_int,   TCK   );
buf  buf_trstb    ( TRSTB_int, TRSTB );
buf  buf_utdo     ( UTDO_int,  UTDO  );

pmos pmos_uireg0  ( UIREG0, UIREG0_zd, 0 );
pmos pmos_uireg1  ( UIREG1, UIREG1_zd, 0 );
pmos pmos_uireg2  ( UIREG2, UIREG2_zd, 0 );
pmos pmos_uireg3  ( UIREG3, UIREG3_zd, 0 );
pmos pmos_uireg4  ( UIREG4, UIREG4_zd, 0 );
pmos pmos_uireg5  ( UIREG5, UIREG5_zd, 0 );
pmos pmos_uireg6  ( UIREG6, UIREG6_zd, 0 );
pmos pmos_uireg7  ( UIREG7, UIREG7_zd, 0 );

pmos pmos_tdo     ( TDO,    TDO_zd,    0 );
pmos pmos_urstb   ( URSTB,  URSTB_zd,  0 );
//pmos pmos_udrck   ( UDRCK,  UDRCK_zd,  0 );
pmos pmos_udrcap  ( UDRCAP, UDRCAP_zd, 0 );
pmos pmos_udrsh   ( UDRSH,  UDRSH_zd,  0 );
pmos pmos_udrupd  ( UDRUPD, UDRUPD_zd, 0 );
//pmos pmos_utdi    ( UTDI,   UTDI_zd,   0 );

//assign { UIREG7, UIREG6, UIREG5, UIREG4, UIREG3, UIREG2, UIREG1, UIREG0 } = IR;
assign { UIREG7_zd, UIREG6_zd, UIREG5_zd, UIREG4_zd, UIREG3_zd, UIREG2_zd, UIREG1_zd, UIREG0_zd } = IR;
assign UTDI  = TDI_int;
assign UDRCK = TCK_int;
//assign URSTB = STATE != `Test_Logic_Reset;

always @( negedge TCK_int or negedge TRSTB_int )
begin
        if ( !TRSTB_int ) begin
                UDRUPD_zd <= 0;
                UDRSH_zd  <= 0;
                UDRCAP_zd <= 0;
                URSTB_zd  <= 0;
        end else begin
                UDRUPD_zd <= ( STATE == `Update_DR        );
                UDRSH_zd  <= ( STATE == `Shift_DR         );
                UDRCAP_zd <= ( STATE == `Capture_DR       );
                URSTB_zd  <= ( STATE != `Test_Logic_Reset );
        end
end

always @( posedge TCK_int or negedge TRSTB_int )
begin
        if ( !TRSTB_int ) begin
                STATE <= `Test_Logic_Reset;
        end
        else begin
             case ( STATE )
                `Test_Logic_Reset: STATE <= TMS_int ? `Test_Logic_Reset : `Run_Test_Idle;
                `Run_Test_Idle   : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
                `Select_DR       : STATE <= TMS_int ? `Select_IR : `Capture_DR;
                `Capture_DR,
                `Shift_DR        : STATE <= TMS_int ? `Exit1_DR : `Shift_DR;
                `Exit1_DR        : STATE <= TMS_int ? `Update_DR : `Pause_DR;
                `Pause_DR        : STATE <= TMS_int ? `Exit2_DR : `Pause_DR;
                `Exit2_DR        : STATE <= TMS_int ? `Update_DR : `Shift_DR;
                `Select_IR       : STATE <= TMS_int ? `Test_Logic_Reset :  `Capture_IR;
                `Capture_IR,
                `Shift_IR        : STATE <= TMS_int ? `Exit1_IR : `Shift_IR;
                `Exit1_IR        : STATE <= TMS_int ? `Update_IR : `Pause_IR;
                `Pause_IR        : STATE <= TMS_int ? `Exit2_IR : `Pause_IR;
                `Exit2_IR        : STATE <= TMS_int ? `Update_IR : `Shift_IR;
                `Update_DR,
                `Update_IR       : STATE <= TMS_int ? `Select_DR : `Run_Test_Idle;
             endcase
        end
end

always @( posedge TCK_int )
begin
        case ( STATE )
                `Capture_IR : SHREG <=  8'bxxxxxx01;
                `Capture_DR : SHREG <=  8'b00000000;
                `Shift_IR,
                `Shift_DR   : SHREG <= { TDI_int, SHREG[7:1] };
        endcase
end

always @( negedge TCK_int or negedge TRSTB_int )
begin
       if ( !TRSTB_int ) begin
         IR  <= `Bypass;
         TDO_zd <= 'bz;
       end else if ( STATE == `Shift_IR )
         TDO_zd <= SHREG[0];
       else if ( STATE == `Shift_DR ) begin
         casez ( IR )
           8'b01??????,
           8'b0?1?????,
           8'b0??1????: TDO_zd <= UTDO;
           default    : TDO_zd <= SHREG[7];
         endcase
       end
       else if ( STATE == `Update_IR ) begin
         TDO_zd <= 'bz;
         IR  <= SHREG;
       end else begin
         TDO_zd <= 'bz;
       end
end

    specify

      specparam   LibName     = "smartfusion";

      (negedge TCK   => (UIREG0+:UIREG0) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG1+:UIREG1) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG2+:UIREG2) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG3+:UIREG3) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG4+:UIREG4) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG5+:UIREG5) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG6+:UIREG6) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UIREG7+:UIREG7) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge TCK   => (UDRCK +:1'b1  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRCK +:1'b0  ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (posedge TDI   => (UTDI +:1'b1   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TDI   => (UTDI +:1'b0   ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TCK   => (URSTB +:URSTB ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRSH +:UDRSH ) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRCAP+:UDRCAP) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TCK   => (UDRUPD+:UDRUPD) ) = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TCK   => (TDO+:TDO ) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (UIREG0+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG1+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG2+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG3+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG4+:1'b1) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG5+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG6+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UIREG7+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (URSTB +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRSH +:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRCAP+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);
      (negedge TRSTB => (UDRUPD+:1'b0) )   = (0.1:0.1:0.1, 0.1:0.1:0.1);

      (negedge TRSTB => (TDO+:1'b0) )      = (0.1:0.1:0.1, 0.1:0.1:0.1);

      $setup(posedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge TDI, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, posedge TDI, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, negedge TDI, 0.0, NOTIFY_REG);

      $setup(posedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge TMS, posedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, posedge TMS, 0.0, NOTIFY_REG);
      $hold(posedge TCK &&& TRSTB, negedge TMS, 0.0, NOTIFY_REG);

      $setup(posedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $setup(negedge UTDO, negedge TCK &&& TRSTB, 0.0, NOTIFY_REG);
      $hold(negedge TCK &&& TRSTB, posedge UTDO, 0.0, NOTIFY_REG);
      $hold(negedge TCK &&& TRSTB, negedge UTDO, 0.0, NOTIFY_REG);

      $recovery(posedge TRSTB, posedge TCK, 0.0, NOTIFY_REG);
      $hold(posedge TCK,posedge TRSTB, 0.0, NOTIFY_REG);

      $width(negedge TRSTB, 0.0, 0, NOTIFY_REG);
      $width(posedge TCK, 0.0, 0, NOTIFY_REG);
      $width(negedge TCK, 0.0, 0, NOTIFY_REG);

    endspecify

endmodule
//---- END MODULE UJTAG ----

//---- MODULE CLKDIV_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDIV_SDF
 AFL macro used in conjunction with CLKDIVDLY_SDF in place of CLKDIVDLY.
 CLKDIV_SDF handles only division and PORT delays.
 CLKDIVDLY_SDF handles IOPATH delays.
---------------------------------------------------------------------*/
`timescale 1 ps /1 ps

module CLKDIV_SDF
  (
  CLK,
  RESET,    // Active rising-edge triggered RESET.
  ODIVHALF, // Active high.
  ODIV0,
  ODIV1,
  ODIV2,
  ODIV3,
  ODIV4,
  GL
  );

  output GL;
  input  CLK; 
  input  RESET; 
  input  ODIVHALF;
  input  ODIV0;
  input  ODIV1;
  input  ODIV2;
  input  ODIV3;
  input  ODIV4;

  time      CLK_re;
  time      CLK_prev_re;
  integer   CLK_period;

  reg       CLK_int; // Internal clock - runs at 2X CLK frequency
  reg       Q;

  integer   num_edges;
  integer   res_post_reset1;
  integer   fes_post_reset1;
  integer   res_post_reset0;
  integer   fes_post_reset0;
  integer   i;
  integer   DivVal;
  integer   DIV;

  wire       RESET_ipd;
  wire       ODIVHALF_ipd;
  wire [4:0] ODIV_ipd;
  wire       CLK_ipd;

  reg        CLK_ipd_last_value;
  reg        RESET_ipd_last_value;
  reg        CLK_int_last_value;
  reg        force_0;

  // These bufs handle PORT delays
  buf U0 ( CLK_ipd,      CLK      ); 
  buf U1 ( RESET_ipd,    RESET    );
  buf U2 ( ODIVHALF_ipd, ODIVHALF );

  assign ODIV_ipd[0]   = ODIV0;
  assign ODIV_ipd[1]   = ODIV1;
  assign ODIV_ipd[2]   = ODIV2;
  assign ODIV_ipd[3]   = ODIV3;
  assign ODIV_ipd[4]   = ODIV4;
  
  buf U3 ( GL, Q );

 //
  // Get DIV value Block
  //
  always @ ( ODIV_ipd or ODIVHALF_ipd )
  begin

    for ( i = 0; i <= 4; i = i + 1 ) begin
      if ( ODIV_ipd [ i ] == 1 )
        DivVal = DivVal + ( 1 << i );
    end
    if ( ODIVHALF_ipd == 1'b1 ) begin
      if (( DivVal == 0 ) || ( DivVal % 2 )) begin
        $display ( "Warning: Illegal ODIVHALF ODIV configuration %b %b.",
                    ODIVHALF_ipd, ODIV_ipd );
        $display ( "Only even, non-zero ODIV values allowed with ODIVHALF." );
        $display ( "ODIVHALF ignored." );
      end
    end else if ( ODIVHALF_ipd === 1'bx ) begin
      $display ( "Warning: Illegal ODIVHALF value %b.  Assumed 0.", ODIVHALF_ipd );
    end
    DIV <= DivVal + 1; // DIV unchanged by ODIVHALF.  Accounted for elsewhere.
    DivVal <= 0;

  end

  //
  // Generate internal CLK signal
  //
  always @ ( CLK_ipd )
  begin
    if ( ODIVHALF_ipd == 1'b1 ) begin
      // Half divide active - multiply CLK by 2 before dividing by DIV
      if ( CLK_ipd === 1'bx ) begin
        CLK_int <= # 0 1'bx;
      end else if ( CLK_ipd == 1'b1 ) begin
        CLK_prev_re = CLK_re;
        CLK_re = $time;
        CLK_period = ( CLK_re - CLK_prev_re );
        if ( CLK_period > 0 ) begin
          // First CLK_ipd cycle dropped
          CLK_int <= # 0 1'b1;
          CLK_int <= # ( CLK_period / 4.0 ) 1'b0;
          CLK_int <= # ( CLK_period / 2.0 ) 1'b1;
          CLK_int <= # ( CLK_period * 3.0 / 4.0 ) 1'b0;
        end
      end
    end else begin
      // Half divide not active - divide CLK by DIV
      CLK_int <= # 0 CLK_ipd;
    end
  end

  //
  // Generate output
  //
  always @ ( CLK_ipd or RESET_ipd or CLK_int )
  begin

    if ( CLK_ipd !== CLK_ipd_last_value ) begin
      if ( ( CLK_ipd === 1'b1 ) && ( CLK_ipd_last_value === 1'b0 ) ) begin
        res_post_reset1 = res_post_reset1 + 1;
        res_post_reset0 = res_post_reset0 + 1;
        if ( res_post_reset1 == 3 ) begin
          force_0 = 1'b0;
          num_edges = -1;
        end
      end else if ( ( CLK_ipd === 1'b0 ) && ( CLK_ipd_last_value === 1'b1 ) ) begin
        fes_post_reset1 = fes_post_reset1 + 1;
        fes_post_reset0 = fes_post_reset0 + 1;
        if ( fes_post_reset1 == 1 ) begin
          force_0 = 1'b1;
        end
      end
      CLK_ipd_last_value = CLK_ipd;
    end

    if ( RESET_ipd !== RESET_ipd_last_value ) begin
      if ( RESET_ipd === 1'b1 ) begin
        if ( ( RESET_ipd_last_value === 1'b0 ) &&
             ( ( res_post_reset0 < 1 ) || ( fes_post_reset0 < 1 ) ) ) begin
          $display( "RESET must be held low for at least one CLK period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
        end
        res_post_reset1 = 0;
        fes_post_reset1 = 0;
      end else if ( RESET_ipd === 1'b0 ) begin
        if ( ( RESET_ipd_last_value === 1'b1 ) &&
             ( ( res_post_reset1 < 3 ) || ( fes_post_reset1 < 3 ) ) ) begin
          $display( "RESET must be held high for at least three CLK periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
        end
        res_post_reset0 = 0;
        fes_post_reset0 = 0;
      end else begin
        $display( "RESET is unknown. Edge alignment unpredictable." );
      end
      RESET_ipd_last_value = RESET_ipd;
    end

    if ( CLK_int !== CLK_int_last_value ) begin
      num_edges = num_edges + 1;
      if ( force_0 === 1'b1 ) begin
        Q <= 1'b0;
      end else if ( CLK_int === 1'bx ) begin
        Q <= 1'bx;
      end else if ( ( num_edges % DIV ) == 0 ) begin
        if ( Q === 1'bx ) begin
          Q <= CLK_int;
        end else begin
          Q <= !Q;
        end
      end
      CLK_int_last_value = CLK_int;
    end

  end

  initial
  begin
    DIV                  = 1;
    DivVal               = 0;
    Q                    = 1'bx;
    num_edges            = -1;
    res_post_reset0      = 0;
    fes_post_reset0      = 0;
    res_post_reset1      = 0;
    fes_post_reset1      = 0;
    CLK_prev_re          = 0;
    CLK_re               = 0;
    CLK_period           = 0;
    CLK_ipd_last_value   = 1'bx;
    RESET_ipd_last_value = 1'bx;
    CLK_int_last_value   = 1'bx;
    force_0              = 1'b1;
  end

  specify

    // No pin to pin path delays used in this model.

  endspecify

endmodule
//---- END MODULE CLKDIV_SDF ----

//---- MODULE CLKDLY ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDLY 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDLY (
  CLK,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

  output GL;
  input  CLK; 
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  parameter INTRINSIC_DELAY     = 528;
  parameter PROG_INIT_DELAY     = 535;
  parameter PROG_STEP_INCREMENT = 200;

  time       GLDELAY;

  wire [4:0] DLYGL_ipd;
  wire       CLK_ipd;

  reg        CLK_ipd_delayed;

  reg        dlygl_xor;
  integer    dlygl_step;

  buf U0 ( CLK_ipd, CLK );

  assign DLYGL_ipd[0]  = DLYGL0;
  assign DLYGL_ipd[1]  = DLYGL1;
  assign DLYGL_ipd[2]  = DLYGL2;
  assign DLYGL_ipd[3]  = DLYGL3;
  assign DLYGL_ipd[4]  = DLYGL4;

  buf BUF_DLY_0( GL, CLK_ipd_delayed );

  always @ ( DLYGL_ipd )
  begin
    dlygl_xor = ^ DLYGL_ipd;
    if ( dlygl_xor === 1'bX )
    begin
      GLDELAY <= 0;
    end else
    begin
      dlygl_step = DLYGL_ipd;
      GLDELAY <= ( dlygl_step == 0 ) ?
                 INTRINSIC_DELAY :
                 ( INTRINSIC_DELAY + ( dlygl_step * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
    end
  end

  always @( GLDELAY or CLK_ipd)
  begin
     CLK_ipd_delayed <= #(GLDELAY) CLK_ipd;
  end

  initial
  begin
    GLDELAY = 0;
  end
  
endmodule
//---- END MODULE CLKDLY ----

//---- MODULE CLKDLY_SDF ----
/*--------------------------------------------------------------------
 CELL NAME : CLKDLY_SDF 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module CLKDLY_SDF (
  CLK,
  DLYGL0,
  DLYGL1,
  DLYGL2,
  DLYGL3,
  DLYGL4,
  GL
  );

  output GL;
  input  CLK; 
  input  DLYGL0;
  input  DLYGL1;
  input  DLYGL2;
  input  DLYGL3;
  input  DLYGL4;

  buf U0( GL, CLK );

  specify

    specparam tpdLH_CLK_to_GL = ( 100 : 100 : 100 );
    specparam tpdHL_CLK_to_GL = ( 100 : 100 : 100 );

    // pin to pin path delay
    ( CLK => GL ) = ( tpdLH_CLK_to_GL, tpdHL_CLK_to_GL );
    specparam PATHPULSE$CLK$GL = ( 100 , 100 );

  endspecify


endmodule
//---- END MODULE CLKDLY_SDF ----

//---- MODULE PLLINT ----
/*--------------------------------------------------------------------
 CELL NAME : PLLINT 
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module PLLINT(Y,A);
 input A;
 output Y;

 buf    BUF_U_00(Y,A);

       specify

                specparam tpdLH_A_to_Y = (0.0:0.0:0.0);
                specparam tpdHL_A_to_Y = (0.0:0.0:0.0);
                specparam MacroType = "comb";

                //pin to pin path delay

                (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE PLLINT ----

//---- MODULE INBUF_A ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_A
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_A(Y,PAD);
 input PAD;
 output Y;

 assign Y = PAD;

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_A ----

//---- MODULE INBUF_DA ----
/*--------------------------------------------------------------------
 CELL NAME : INBUF_DA
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module INBUF_DA(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 assign Y = PAD;

       specify

    specparam tpdLH_PAD_to_Y = (0.1:0.1:0.1);
    specparam tpdHL_PAD_to_Y = (0.1:0.1:0.1);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );

    specparam PATHPULSE$PAD$Y = (0.1, 0.1);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE INBUF_DA ----

//---- MODULE OUTBUF_A ----
/*--------------------------------------------------------------------
 CELL NAME : OUTBUF_A
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module OUTBUF_A(PAD,D);
 input D;
 output PAD;

 assign PAD = D;

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE OUTBUF_A ----

//---- MODULE CLKSRC ----
/*--------------------------------------------------------------------
 CELL NAME : CLKSRC
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module CLKSRC ( Y, A );
 input  A;
 output Y;

 buf    BUF_U_00 ( Y, A );

       specify

                specparam tpdLH_A_to_Y = (0.1:0.1:0.1);
                specparam tpdHL_A_to_Y = (0.1:0.1:0.1);
                specparam MacroType = "comb";

                //pin to pin path delay

                (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CLKSRC ----

//---- MODULE MSSINT ----
/*--------------------------------------------------------------------
 CELL NAME : MSSINT 
 CELL TYPE : comb
 CELL LOGIC : Y=A
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module MSSINT(Y,A);
 input A;
 output Y;

 buf    BUF_U_00(Y,A);

       specify

                specparam tpdLH_A_to_Y = (0.0:0.0:0.0);
                specparam tpdHL_A_to_Y = (0.0:0.0:0.0);
                specparam MacroType = "comb";

                //pin to pin path delay

                (A => Y ) = ( tpdLH_A_to_Y, tpdHL_A_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MSSINT ----

//Analog Quad Module

`timescale 1ps/1ps

module analog_quad (input wire signed [63:0] VAREF_IN,
                    input wire VAREF_DAC,
                    input wire AV1_IN  ,
                    input wire AV2_IN  ,
                    input wire AC_IN   ,
                    input wire AT_IN   ,
                    input wire AT_GND  ,

                    //AT Comparator inputs
                    input wire DIRECT_ANALOG0,
                    input wire DIRECT_ANALOG1,

                    //direct digital input related SIGNALS
                    input wire [3:0]  AV1_CONFIG,
                    input wire [3:0]  AV2_CONFIG,
                    input wire [7:0]  AC_CONFIG,
                    input wire [7:0]  AT_CONFIG,

                    //OUTPUTS FROM ANALOG QUAD GO TO ANALOG MUX
                    output wire signed [63:0] AV1_OUT ,
                    output wire signed [63:0] AV2_OUT ,
                    output wire signed [63:0] AC_OUT  ,
                    output wire signed [63:0] AT_OUT  ,

                    output reg AC_COMP_OUT,
                    output reg AT_COMP_OUT
                   ) ;

  parameter WIDTH              = 32;
  parameter WARNING_MSGS_ON    = 1 ;

  real  SCALING_FACTOR0 = 1;
  real  SCALING_FACTOR1 = 2.0;
  real  SCALING_FACTOR2 = 4.0;
  real  SCALING_FACTOR3 = 6.0;

   real AC_HYSTERISIS0 = 0.0;//0 mv
   real AC_HYSTERISIS1 = 0.01;//10 mv
   real AC_HYSTERISIS2 = 0.03;//30 mv
   real AC_HYSTERISIS3 = 0.1;//100 mv

   real AT_HYSTERISIS0 = 0.0;//0 mv
   real AT_HYSTERISIS1 = 0.01;//10 mv
   real AT_HYSTERISIS2 = 0.03;//30 mv
   real AT_HYSTERISIS3 = 0.1;//100 mv
  //   
   real ac_hysterisis;
   real at_hysterisis;
  
  reg signed [2 * WIDTH-1:0]  v1_input_to_mux, v2_input_to_mux;

  wire signed [2 * WIDTH-1:0] vin_quad_prescaled, curr_monitor_out , temp_monitor_out;

  wire signed [2 * WIDTH-1:0] av1_vector;
  wire signed [2 * WIDTH-1:0] av2_vector;
  wire signed [2 * WIDTH-1:0] ac_vector;
  wire signed [2 * WIDTH-1:0] at_vector;
  wire signed [2 * WIDTH-1:0] analog_vector_0;
  wire signed [2 * WIDTH-1:0] analog_vector_1;

  // VAREF from DAC
  wire signed [2 * WIDTH-1:0] varef_dac_vector;

  //config inputs
  wire [1:0] av1_prescale_sel  ;
  wire [1:0] av2_prescale_sel ;

  real At_real;

  //reg [15:0] ACB_LATCH [0:3] ;

 /*assign  av1_prescale_en   = AV1_WORD[10];
  assign  av1_prescale_sel  = AV1_WORD[12:11];
  assign  av1_mux_select    = 1'b0;
  assign  av1_direct_switch = 1'b0;

  assign  av2_prescale_en   = AV2_WORD[10];
  assign  av2_prescale_sel  = AV2_WORD[12:11] ;
  assign  av2_mux_select    = 1'b0;
  assign  av2_direct_switch = 1'b0;

  assign  ac_mux_select     = AC_WORD[0];
  assign  ac_direct_switch  = AC_WORD[1];
  assign  ac_cm_en          = AC_WORD[2];
  assign  ac_cm_stb         = AC_WORD[3];
  assign  ac_comp_en        = AC_WORD[4];
  assign  ac_comp_vref_sw   = AC_WORD[5];

  assign  at_mux_select     = AT_WORD[0];
  assign  at_direct_switch  = AT_WORD[1];
  assign  at_tm_en          = AT_WORD[2];
  assign  at_tm_stb         = AT_WORD[3];
  assign  at_comp_en        = AT_WORD[4];
  assign  at_comp_vref_sw   = AT_WORD[5];*/

  assign  av1_prescale_en   = AV1_CONFIG[0];
  assign  av1_prescale_sel  = AV1_CONFIG[2:1];
  assign  av1_mux_select    = 1'b0;   // Set to zero since there is no mux select in the prescalar
  assign  av1_direct_switch = 1'b0;   // Set to zero since there is no direct switch in the prescalar

  assign  av2_prescale_en   = AV2_CONFIG[0];
  assign  av2_prescale_sel  = AV2_CONFIG[2:1] ;
  assign  av2_mux_select    = 1'b0;   // Set to zero since there is no mux select in the prescalar
  assign  av2_direct_switch = 1'b0;   // Set to zero since there is no direct switch in the prescalar

  assign  ac_mux_select     = AC_CONFIG[0];
  assign  ac_direct_switch  = AC_CONFIG[1];
  assign  ac_cm_en          = AC_CONFIG[2];
  assign  ac_cm_stb         = AC_CONFIG[3];
  assign  ac_comp_en        = AC_CONFIG[4];
  wire [1:0] ac_hysterisis_sel  = AC_CONFIG[7:6];
  

  assign  at_mux_select     = AT_CONFIG[0];
  assign  at_direct_switch  = AT_CONFIG[1];
  assign  at_tm_en          = AT_CONFIG[2];
  assign  at_tm_stb         = AT_CONFIG[3];
  assign  at_comp_en        = AT_CONFIG[4];
  assign  at_comp_vref_sw   = AT_CONFIG[5];
  wire [1:0] at_hysterisis_sel  = AT_CONFIG[7:6];

  read_analog_io read_analog_input_AV1    ( AV1_IN   , 1'b0, av1_vector );
  read_analog_io read_analog_input_AV2    ( AV2_IN   , 1'b0, av2_vector );
  read_analog_io read_analog_input_AC     ( AC_IN    , 1'b0 , ac_vector  );
  read_analog_io read_analog_input_AT     ( AT_IN    , 1'b0 , at_vector  );

  //AT comparator inputs
  read_analog_io read_direct_analog_0     ( DIRECT_ANALOG0    , 1'b0 , analog_vector_0  );
  read_analog_io read_direct_analog_1     ( DIRECT_ANALOG1    , 1'b0 , analog_vector_1  );

  // temporarily
  read_analog_io read_analog_input_varef_dac ( VAREF_DAC, 1'b0, varef_dac_vector );



  assign AV1_OUT = bipolar_prescaled_vin_to_mux  ("AV1"             ,
	                                                av1_vector        ,
                                                  av1_prescale_en   ,
                                                  av1_prescale_sel  ,
                                                  VAREF_IN          
                                                 );

  assign AV2_OUT = bipolar_prescaled_vin_to_mux ("AV2"             ,
                                                 av2_vector        ,
                                                 av2_prescale_en   ,
                                                 av2_prescale_sel  ,
                                                 VAREF_IN          
                                                );

  assign AC_OUT = current_monitor_out_n_cin_to_mux (ac_vector        ,
                                                    at_vector        ,
                                                    VAREF_IN         ,
                                                    ac_cm_en         ,
                                                    ac_cm_stb        ,
                                                    ac_mux_select    ,
                                                    ac_direct_switch ,
                                                    at_direct_switch
                                                   );

  assign AT_OUT = temp_monitor_out_n_tin_to_mux  (at_vector        ,
                                                  VAREF_IN         ,
                                                  at_tm_en         ,
                                                  at_tm_stb        ,
                                                  at_mux_select    ,
                                                  at_direct_switch
                                                 );


  // comparator behavior in AC & AT pads; temporarily defined as arithmetic comparison
  // VAREF_DAC signal coding is assumed to be same as serial input if comparator output
  // is expected to be checked

  always @(*)
      begin
	  case (ac_hysterisis_sel)
	     2'b00 : ac_hysterisis <= AC_HYSTERISIS0;
	     2'b01 : ac_hysterisis <= AC_HYSTERISIS1;
	     2'b10 : ac_hysterisis <= AC_HYSTERISIS2;
	     2'b11 : ac_hysterisis <= AC_HYSTERISIS3;
	     default : ac_hysterisis <= AC_HYSTERISIS0;
	  endcase
      end // always @ (*)

    always @(*)
      begin
	  case (at_hysterisis_sel)
	     2'b00 : at_hysterisis <= AT_HYSTERISIS0;
	     2'b01 : at_hysterisis <= AT_HYSTERISIS1;
	     2'b10 : at_hysterisis <= AT_HYSTERISIS2;
	     2'b11 : at_hysterisis <= AT_HYSTERISIS3;
	     default : at_hysterisis <= AT_HYSTERISIS0;
	  endcase
      end // always @ (*)

  always @(*)
      begin:comp_ac
	 real ac_vector_real;
	 real at_vector_real;

	  ac_vector_real = $bitstoreal(ac_vector);
	  at_vector_real = $bitstoreal(at_vector);
	  
	  if (ac_comp_en == 1'b1)
	      begin
		  
		  if (ac_vector_real >= (at_vector_real + ac_hysterisis))
		      AC_COMP_OUT <= 1'b1;		      
		  else if (ac_vector_real <= (at_vector_real - ac_hysterisis))
		      AC_COMP_OUT <= 1'b0;
	      end // if (ac_comp_en == 1'b1)
	  
	  else
	      AC_COMP_OUT <= 1'b0;
	  
      end // always @ (*)
 
  always @(*)
      begin:comp_at
	 real analog_vector_0_real;
	 real analog_vector_1_real;	  
	 real varef_dac_vector_real;

	  analog_vector_0_real = $bitstoreal(analog_vector_0);
	  analog_vector_1_real = $bitstoreal(analog_vector_1);
	  varef_dac_vector_real = $bitstoreal(varef_dac_vector);
	  
	  if (at_comp_en == 1'b1)
	      begin
		  if (at_comp_vref_sw == 1'b1)
		      begin	      
			  if (analog_vector_0_real >= (varef_dac_vector_real + at_hysterisis))		      
			      AT_COMP_OUT <= 1'b1;
			  
			  else if (analog_vector_0_real <= (varef_dac_vector_real - at_hysterisis))
			      AT_COMP_OUT <= 1'b0;
			  
		      end // if (at_comp_vref_sw == 1'b1)		  
		  else
		      begin	      
			  if (analog_vector_0_real >= (analog_vector_1_real + at_hysterisis))
			      AT_COMP_OUT <= 1'b1;
			  
			  else if (analog_vector_0_real <= (analog_vector_1_real - at_hysterisis))
			      AT_COMP_OUT <= 1'b0;
		      end // else: !if(at_comp_vref_sw == 1'b1)		  
		  
	      end // if (at_comp_en == 1'b1)	  
	  
	  else
	      AT_COMP_OUT <= 1'b0;
	  
      end // always @ (*)
   
//**************************************************************************************************************************
function  [63:0] bipolar_prescaled_vin_to_mux;
  input             [15:0]   pad_type;
  input             [63:0]   av_vect;
  input                      prescale_en;
  input             [1:0]    prescale_sel;
  input             [63:0]   varef;

  real        av_real;
  real        quad_prescaled_temp_real;
  reg  [63:0] quad_prescaled_temp;
  real        quad_prescaled_temp_1_real;
  real        varef_real;
  reg signed [63:0] vin_quad_prescaled;
  real        av_out_real;

  begin
    quad_prescaled_temp_real = 0 ;
    quad_prescaled_temp = 64'b0000 ;
    av_real = 0.0 ;
    varef_real = $bitstoreal( varef ) ;
    if ( prescale_en )
      begin
        av_real = $bitstoreal ( av_vect );
        case ( prescale_sel )
          0       : quad_prescaled_temp_real= ( av_real / SCALING_FACTOR3 );
          1       : quad_prescaled_temp_real= ( av_real / SCALING_FACTOR2 );
          2       : quad_prescaled_temp_real= ( av_real / SCALING_FACTOR1 );
          3       : quad_prescaled_temp_real= ( av_real / SCALING_FACTOR0 );
          default : quad_prescaled_temp_real= ( av_real / SCALING_FACTOR3 );
        endcase
        quad_prescaled_temp = $realtobits ( (varef_real/2) - (quad_prescaled_temp_real / 2) );

	      quad_prescaled_temp_1_real = $bitstoreal ( quad_prescaled_temp ) ;

        if ( ( quad_prescaled_temp_1_real < 0 ) || ( quad_prescaled_temp_1_real > varef_real ) )
        begin
          if ( quad_prescaled_temp_1_real > varef_real )
          begin
            vin_quad_prescaled = varef; // Saturation
            if ( WARNING_MSGS_ON )
            begin
              $display ( "Warning : Prescaler output saturation - The internal reference voltage is the Prescaler maximum output value at time %0.1f\n", $realtime );
            end
          end
          else
          begin
            vin_quad_prescaled = 0; // Saturation
            if ( WARNING_MSGS_ON )
            begin
              $display ( "Warning : Prescaler output saturation - The internal reference voltage is the Prescaler minimum output value at time %0.1f\n", $realtime );
            end
          end
        end
        else
          vin_quad_prescaled = get_abs_val ( quad_prescaled_temp );
      end
    else
    begin
      $display(" **** INFO - Disabled Voltage Prescaling **** ");
       vin_quad_prescaled = 64'd0;       
    end
    //**********************************************************************************************************************
    av_out_real = $bitstoreal(vin_quad_prescaled);
    
    if ( prescale_en )
      bipolar_prescaled_vin_to_mux = vin_quad_prescaled;
    
    //***************************************************************************************************************
    if (( $bitstoreal (bipolar_prescaled_vin_to_mux) >  $bitstoreal( varef ) ) &&
        ( WARNING_MSGS_ON ) ) // && aq_acb_blk_tb.config_done )
    begin
      $display ("Warning : Voltage monitor Saturation.\n");
      $display ("Input Voltage value is greater than the Varef value\n") ;
    end
   //**********************************************************************************************************************
  end
endfunction
//**************************************************************************************************************************



//**************************************************************************************************************************
function [63:0] current_monitor_out_n_cin_to_mux;
  input  [63:0] ac_vect;
  input  [63:0] at_vect;
  input  [63:0] varef;
  input         cm_en ;        //current monitor powerdown
  input         cm_stb ;       //current monitor enable strobe
  input         c_mux_select ; //these are the control lines [4:3]
  input         c_direct_switch ; //direct analog input switch
  input         t_direct_switch;

  reg signed [63:0] curr_monitor_out ;
  real            ac_at_diff_real;

  begin

     ac_at_diff_real =  $bitstoreal(get_abs_val(ac_vect)) -
			$bitstoreal(get_abs_val(at_vect)) ;     
  
    if ( c_mux_select == 1'b0 )   // Normal Operation. This will be the default case as it matches to X and Z.
    begin
      // Current Monitor is enabled
      if ( cm_en == 1'b1 && cm_stb == 1'b1 )
      begin
        if ( ac_vect[63]  || at_vect[63] )
        begin
           curr_monitor_out = 64'd0;

          if ( WARNING_MSGS_ON  )
            $display ("Polarity error: AT and/or AC sign and polarity bit are not consistent. Both AT and AC should be positive.  The Current Monitor output will be 0.0 - AT/AC , at time  %0.1f\n", $realtime );
        end
        else
        begin
          if ( c_direct_switch == 1'b1 )    // The direct switch input should be off when the current monitor is in normal operation
          begin
            if ( WARNING_MSGS_ON )
              $display ("Warning : The AC direct analog input switch needs to be switched OFF. - AC, at time %0.1f\n" , $realtime );
          end
          
          if ( (ac_at_diff_real * 50.0) > $bitstoreal ( varef ) )
          begin
            curr_monitor_out = varef; // Saturation
            if ( WARNING_MSGS_ON )
              $display ("Warning : Current Monitor output saturation - The output voltage is set to the Current Monitor maximum output value - AC, at time %0.1f\n" , $realtime );
          end
          else 
          begin
            if (ac_at_diff_real < 0.0 )
            begin
               curr_monitor_out = 64'd0;	       
              if ( WARNING_MSGS_ON )
                $display ( "Warning : Absolute value of AT should not be greater than absolute value of AC.  Current monitor output will be 0.0 - AT/AC, at time %0.1f\n", $realtime );
            end
            else
            begin
              curr_monitor_out = $realtobits (ac_at_diff_real * 50.0 );
            end
          end
        end
        current_monitor_out_n_cin_to_mux = curr_monitor_out;
      end
      else
      begin
        // Current Monitor is disabled
        $display("**** INFO : Disabled Current Monitor **** ");
         current_monitor_out_n_cin_to_mux = 64'd0;	 
      end
    end
    else    // Direct Current analog input is used
    begin
      if ( c_direct_switch == 1'b1 )
      begin
        if ( ac_vect[63] == 1'b1 ) // if AC is negative
        begin
           current_monitor_out_n_cin_to_mux = 64'd0;	   
          if ( WARNING_MSGS_ON )
            $display ( "Warning : When the Current Direct Analog Input is selected, the voltage on AC can not be negative - AC , at time %0.1f\n", $realtime);
        end
        else
        begin
          if ( $bitstoreal(ac_vect) > $bitstoreal(varef) )  // AC > Vref --> Output saturation
          begin
            current_monitor_out_n_cin_to_mux = varef;
            if ( WARNING_MSGS_ON )
              $display ("Warning : Current Monitor output saturation - The output voltage is set to the Current Monitor maximum output value - AC, at time %0.1f\n" , $realtime );
          end
          else
            current_monitor_out_n_cin_to_mux = ac_vect;
        end
      end
      else
      begin
         current_monitor_out_n_cin_to_mux = 64'd0;
        $display ( "Error : When using the Current Direct Analog Input, the AC direct analog input switch needs to be switched ON, at time %0.1f\n", $realtime);
      end
    end
   
    /*
    //**************************************************************************************************************************
    //This part of task is to generate AC output (or c input to analog mux)
    case ( c_mux_select )
      1'b0  : 
              if (( $bitstoreal(at_vect) >= 0.0 ) && ( $bitstoreal(at_vect) < $bitstoreal(varef) ) && (c_direct_switch == 1'b0))
              begin
                current_monitor_out_n_cin_to_mux = curr_monitor_out;
              end
                else
                begin
                  current_monitor_out_n_cin_to_mux = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                  $display ( "Error : When using the Current Monitor, the AC direct analog input switch needs to be switched OFF. The AT direct analog input switch can be switched ON if AT is positive and less than the internal VAREF (default is 2.56V). Otherwise, the AT direct analog input switch needs to be OFF. At time %0.1f\n", $realtime);
                end
      1'b1    : if ( c_direct_switch )
                begin
                  if ( ac_vect[63] == 1'b1 ) // if AC < 0
		              begin
                    current_monitor_out_n_cin_to_mux = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                    if ( WARNING_MSGS_ON )
                      $display ( "Warning : When the Current Direct Analog Input is selected, the voltage on AC can not be negative - AC , at time %0.1f\n", $realtime);
                  end
                  else
                    current_monitor_out_n_cin_to_mux = ac_vect;
                end
                else
                begin
                  current_monitor_out_n_cin_to_mux = 64'b0000000000000000000000000000000000000000000000000000000000000000;
                  $display ( "Error : When using the Current Direct Analog Input, the AC direct analog input switch needs to be switched on, at time %0.1f\n", $realtime);
                end
      default : if ( !c_direct_switch )
                  current_monitor_out_n_cin_to_mux = curr_monitor_out;
    endcase*/
//**************************************************************************************************************************
  end
endfunction
//**************************************************************************************************************************



//**************************************************************************************************************************
//NOTE: Temperature monitor considers input temp to be in kelvin
function [63:0] temp_monitor_out_n_tin_to_mux;
  input  [63:0] at_vect;
  input  [63:0] varef;
  input         tm_en ;  //temp monitor powerdown
  input         tm_stb ;  //temp monitoring enable strobe i/p
  input         t_mux_select;
  input         t_direct_switch;

  reg  signed [63:0] temp_monitor_out ;
  real    at_analog;

  begin
    at_analog = $bitstoreal(at_vect);

    if ( tm_en == 1'b1 && tm_stb == 1'b1 )
    begin
      if ( at_vect[63] )
      begin
         temp_monitor_out = 64'd0;
        if ( WARNING_MSGS_ON )
          $display ( "Warning : AT quad only accepts positive voltages, and T-pad polarity has to be set to 0 (Positive) - AT , at time %0.1f\n",  $realtime);
      end
      else if ( ( ( $bitstoreal ( get_abs_val ( at_vect ) ) ) * 12.5 ) > $bitstoreal ( varef ) )
      begin
        temp_monitor_out = varef; // Saturation
        if ( WARNING_MSGS_ON )
          $display ( "Warning : Temperature Monitor output saturation: The internal reference voltage is the Temperature Monitor maximum output value - AT, at time %0.1f\n",  $realtime);
      end
      else
      begin
        temp_monitor_out = $realtobits ( ( $bitstoreal ( get_abs_val ( at_vect ) ) ) * 12.5 );
      end
    end
    else
    begin
      $display(" **** INFO: Disabled Temperature Monitor**** ");
       temp_monitor_out = 64'd0;       
    end
    //*************************************************************************************************************************
    //This part of the task is for generating the AT output (or temp input to analog mux)
    case ( t_mux_select )
      1'b0    : begin
                  temp_monitor_out_n_tin_to_mux = temp_monitor_out;
                  if ( t_direct_switch )
                  begin
                    $display ( "Error : When using the Temperature Monitor, the direct analog input switch needs to be switched OFF for AT pad at time %0.1f\n",  $realtime);
                  end
                end
      1'b1    : if ( t_direct_switch )
                begin
                  if ( at_vect[63] == 1'b1 )
                  begin
                     temp_monitor_out_n_tin_to_mux = 64'd0;		     
                    $display ( "Warning : The voltage on AT-quad can not be negative - AT , at time %0.1f\n", $realtime);
                  end
                  else
                    temp_monitor_out_n_tin_to_mux = at_vect;
                end
                else
                begin
                   temp_monitor_out_n_tin_to_mux = 64'd0;		   
                  $display ( "Error : When using the Temperature Direct Analog Input, the AT direct analog input switch needs to be switched on for AT pad, at time %0.1f\n", $realtime);
                end
      default : begin
                  temp_monitor_out_n_tin_to_mux = temp_monitor_out;
                  if ( t_direct_switch )
                  begin
                     temp_monitor_out_n_tin_to_mux = 64'd0;		     
                    if ( at_vect[63:1] !== {63{1'bx}} )
                      $display ( "Error : When using the Temperature Monitor, the AT direct analog input switch needs to be switched OFF - for AT pad , at time %0.1f\n",  $realtime);
                  end
                end
    endcase
    //*************************************************************************************************************************
  end
endfunction


//**************************************************************************************************************************
function [63:0] get_abs_val;

  input  [63:0]  quad_vect;

  begin
    if ( (quad_vect[63]) == 1'b0 ) // if quad_vect real positive
      get_abs_val = quad_vect;
    else
      get_abs_val = {1'b0,quad_vect[62:0]};
  end
endfunction
//**************************************************************************************************************************

endmodule


//This files contains the analog mux module

`timescale 1ps/1ps

module analog_mux (input  wire  [4:0]  CHNUMBER_I ,
                   input  wire  [63:0] AV01 ,
	                 input  wire  [63:0] AV02 ,
                   input  wire  [63:0] AC0  ,
                   input  wire  [63:0] AT0  ,
                   input  wire  [63:0] AV11 ,
	                 input  wire  [63:0] AV12 ,
                   input  wire  [63:0] AC1  ,
                   input  wire  [63:0] AT1  ,
                   input  wire  [63:0] ADC_IN_VECTOR_0  ,
                   input  wire  [63:0] ADC_IN_VECTOR_1  ,
                   input  wire  [63:0] ADC_IN_VECTOR_2  ,
                   input  wire  [63:0] ADC_IN_VECTOR_3  ,
                   input  wire  [63:0] DAC_VECTOR       ,
                   output reg   [63:0] MUXOUT
                  ) ;

  real va_ref_real , gnd_ref_real ;
  parameter WARNING_MSGS_ON = 1 ;

  always @ (AV01, AV02, AC0, AT0, AV11, AV12, AC1, AT1,
	          ADC_IN_VECTOR_0, ADC_IN_VECTOR_1, ADC_IN_VECTOR_2, ADC_IN_VECTOR_3,DAC_VECTOR,
            CHNUMBER_I
           )
  begin
    case (CHNUMBER_I)
      5'd1    : MUXOUT =  AV01 ;
      5'd2    : MUXOUT =  AV02 ;
      5'd3    : MUXOUT =  AC0  ;
      5'd4    : MUXOUT =  AT0  ;
      5'd5    : MUXOUT =  AV11 ;
      5'd6    : MUXOUT =  AV12 ;
      5'd7    : MUXOUT =  AC1  ;
      5'd8    : MUXOUT =  AT1  ;
      5'd9    : MUXOUT =  ADC_IN_VECTOR_0 ;
      5'd10   : MUXOUT =  ADC_IN_VECTOR_1 ;
      5'd11   : MUXOUT =  ADC_IN_VECTOR_2 ;
      5'd12   : MUXOUT =  ADC_IN_VECTOR_3 ;
      5'd15   : MUXOUT =  DAC_VECTOR ;

      default : begin
                  MUXOUT = 0;
                end
    endcase
  end
endmodule


`timescale 1ps/1ps

module analog_mux_F060 (input  wire  [4:0]  CHNUMBER_I ,
                        input  wire  [63:0] AV01 ,
                        input  wire  [63:0] AV02 ,
                        input  wire  [63:0] AC0  ,
                        input  wire  [63:0] AT0  ,
                        input  wire  [63:0] ADC_IN_VECTOR_0  ,
                        input  wire  [63:0] ADC_IN_VECTOR_1  ,
                        input  wire  [63:0] ADC_IN_VECTOR_2  ,
                        input  wire  [63:0] ADC_IN_VECTOR_3  ,
                        input  wire  [63:0] ADC_IN_VECTOR_4  ,
                        input  wire  [63:0] ADC_IN_VECTOR_5  ,
                        input  wire  [63:0] ADC_IN_VECTOR_6  ,
                        input  wire  [63:0] ADC_IN_VECTOR_7  ,
                        input  wire  [63:0] ADC_IN_VECTOR_8  ,
                        input  wire  [63:0] ADC_IN_VECTOR_9  ,
                        input  wire  [63:0] ADC_IN_VECTOR_10 ,
                        input  wire  [63:0] ADC_IN_VECTOR_11 ,
                        input  wire  [63:0] ADC_IN_VECTOR_12 ,
                        input  wire  [63:0] ADC_IN_VECTOR_13 ,
                        input  wire  [63:0] ADC_IN_VECTOR_14 ,
                        input  wire  [63:0] ADC_IN_VECTOR_15 ,
                        input  wire  [63:0] ADC_IN_VECTOR_16 ,
                        input  wire  [63:0] ADC_IN_VECTOR_17 ,
                        input  wire  [63:0] ADC_IN_VECTOR_18 ,
                        input  wire  [63:0] ADC_IN_VECTOR_19 ,
                        input  wire  [63:0] ADC_IN_VECTOR_20 ,
                        input  wire  [63:0] ADC_IN_VECTOR_21 ,
                        input  wire  [63:0] ADC_IN_VECTOR_22 ,
                        input  wire  [63:0] ADC_IN_VECTOR_23 ,
                        input  wire  [63:0] ADC_IN_VECTOR_24 ,
                        input  wire  [63:0] ADC_IN_VECTOR_25 ,
                        input  wire  [63:0] DAC_VECTOR       ,
                        output reg   [63:0] MUXOUT
                       ) ;

  real va_ref_real , gnd_ref_real ;
  parameter WARNING_MSGS_ON = 1 ;

  always @ (AV01, AV02, AC0, AT0,
	          ADC_IN_VECTOR_0, ADC_IN_VECTOR_1, ADC_IN_VECTOR_2, ADC_IN_VECTOR_3,
            ADC_IN_VECTOR_4, ADC_IN_VECTOR_5, ADC_IN_VECTOR_6, ADC_IN_VECTOR_7,
            ADC_IN_VECTOR_8, ADC_IN_VECTOR_9, ADC_IN_VECTOR_10, ADC_IN_VECTOR_11,
            ADC_IN_VECTOR_12, ADC_IN_VECTOR_13, ADC_IN_VECTOR_14, ADC_IN_VECTOR_15,
            ADC_IN_VECTOR_16, ADC_IN_VECTOR_17, ADC_IN_VECTOR_18, ADC_IN_VECTOR_19,
            ADC_IN_VECTOR_20, ADC_IN_VECTOR_21, ADC_IN_VECTOR_22, ADC_IN_VECTOR_23,
            ADC_IN_VECTOR_24, ADC_IN_VECTOR_25, DAC_VECTOR, CHNUMBER_I
           )
  begin
    case (CHNUMBER_I)
      5'd1    : MUXOUT =  AV01 ;
      5'd2    : MUXOUT =  AV02 ;
      5'd3    : MUXOUT =  AC0  ;
      5'd4    : MUXOUT =  AT0  ;
      5'd5    : MUXOUT =  ADC_IN_VECTOR_0 ;
      5'd6    : MUXOUT =  ADC_IN_VECTOR_1 ;
      5'd7    : MUXOUT =  ADC_IN_VECTOR_2 ;
      5'd8    : MUXOUT =  ADC_IN_VECTOR_3 ;
      5'd9    : MUXOUT =  ADC_IN_VECTOR_4 ;
      5'd10   : MUXOUT =  ADC_IN_VECTOR_5 ;
      5'd11   : MUXOUT =  ADC_IN_VECTOR_6 ;
      5'd12   : MUXOUT =  ADC_IN_VECTOR_7 ;
      5'd13   : MUXOUT =  ADC_IN_VECTOR_8 ;
      5'd14   : MUXOUT =  ADC_IN_VECTOR_9 ;
      5'd15   : MUXOUT =  ADC_IN_VECTOR_10;
      5'd16   : MUXOUT =  ADC_IN_VECTOR_11;
      5'd17   : MUXOUT =  ADC_IN_VECTOR_12;
      5'd18   : MUXOUT =  ADC_IN_VECTOR_13;
      5'd19   : MUXOUT =  ADC_IN_VECTOR_14;
      5'd20   : MUXOUT =  ADC_IN_VECTOR_15;
      5'd21   : MUXOUT =  ADC_IN_VECTOR_16;
      5'd22   : MUXOUT =  ADC_IN_VECTOR_17;
      5'd23   : MUXOUT =  ADC_IN_VECTOR_18;
      5'd24   : MUXOUT =  ADC_IN_VECTOR_19;
      5'd25   : MUXOUT =  ADC_IN_VECTOR_20;
      5'd26   : MUXOUT =  ADC_IN_VECTOR_21;
      5'd27   : MUXOUT =  ADC_IN_VECTOR_22;
      5'd28   : MUXOUT =  ADC_IN_VECTOR_23;
      5'd29   : MUXOUT =  ADC_IN_VECTOR_24;
      5'd30   : MUXOUT =  ADC_IN_VECTOR_25;
      
      5'd31   : MUXOUT =  DAC_VECTOR ;

      default : begin
                  MUXOUT = 0;
                end
    endcase
  end
endmodule


`timescale 1ps/1ps

module adc(
           input wire signed [63:0]  VAREF_INPUT,
	   input wire       VAREFSEL,
           
           input wire [63:0] A_IN ,   //Analog Input
           
	   input wire       PWRDWN,	   
	   input wire       ADCRESET,
	   input wire       SYSCLK,
	   input wire [4:0] CHNUMBER,
	   input wire [3:0] MODE,
	   input wire [7:0] TVC,
	   input wire [7:0] STC,
	   input wire       ADCSTART,
	   
	   output reg        VAREFSEL_lat ,
	   output wire        BUSY,
	   output wire        CALIBRATE,
	   output wire        DATAVALID,
	   output wire        SAMPLE,
	   output wire [11:0] RESULT
	  ) ;

  parameter WARNING_MSGS_ON = 1;
  parameter FAST_ADC_CONV_SIM  = 0;
  parameter VA_REF_INTERNAL = 2.56;

  real      analog_in ; 
  real      va_ref_real ;
  real      adc_input;        

  reg [3:0]  MODE_i;
  reg [4:0]  CHNUMBER_i;
  reg [7:0]  STC_i, TVC_i;
  reg        ADCRESET_tvc_event, ADCSTART_tvc_event, SYSCLK_tvc_event;
  reg        adcclk_check, check1, wait_for_adcstart ;
  reg        interrupt_cal;

  reg        ADCRESET_tvc_prev, ADCSTART_tvc_prev, SYSCLK_tvc_prev;
  reg        calibration_started, conversion_started, busy_int ;
  reg        ADC_CLK;
  
  reg  [11:0]    comparator_output_12;
  reg  [11:0]    comparator_output_12_temp;
  reg  [11:0]    comparator_output_10;
  reg  [11:0]    comparator_output_8;
  reg  [11:0]    result_temp;

  integer    SYSCLK_previous, SYSCLK_period, ADC_CLK_period;
  integer    fper_cal_count, sysclk_count, CALIBRATE_cnt;

  time    t_sync_read, t_sync_write, t_sample, t_cal ;
  time    t_distrib  , t_conv;
  time    sample_start_time  ,busy_start_time ; 

  reg        ad_res_int;
  reg        BUSY_reg, CALIBRATE_reg, DATAVALID_reg, SAMPLE_reg;
  reg [11:0] RESULT_reg ;

  genvar i ;

  // initialization sequence to bring-up ADC_CLK divider logic & ADC logic
  initial
  begin
    ad_res_int          = 1'b0;
    fper_cal_count      =  'd0;
    busy_int            = 1'b0;
    calibration_started = 1'b0;
    ADCRESET_tvc_prev   = 1'b0;
    ADCSTART_tvc_prev   = 1'b0;
    SYSCLK_tvc_prev     = 1'b0;
    VAREFSEL_lat        = 1'b0;
  end

//output status signals  
  assign BUSY      = BUSY_reg ;
  assign CALIBRATE = CALIBRATE_reg ;
  assign DATAVALID = DATAVALID_reg ;
  assign SAMPLE    = SAMPLE_reg ;
  assign RESULT    = RESULT_reg ;

      
  always @ (VAREF_INPUT) va_ref_real = $bitstoreal ( VAREF_INPUT ) ;
//*************************************************************************************************************
// Programmable Clock Divider
//*************************************************************************************************************

  always @ ( SYSCLK or ADCRESET or ADCSTART )
  begin //{

    ADCRESET_tvc_event = ADCRESET !== ADCRESET_tvc_prev;
    ADCSTART_tvc_event = ADCSTART !== ADCSTART_tvc_prev;
    SYSCLK_tvc_event   = SYSCLK   !== SYSCLK_tvc_prev;
      
    if (( ADCRESET_tvc_event && ( ADCRESET == 1'b1 )) || 
        ( ADCSTART == 1'b1 && ADCSTART_tvc_event ))
       begin //{
        sysclk_count = 0;
        if ( calibration_started == 0 && busy_int == 0 ) 
          ADC_CLK    = 1'b0;
       end   //}
    else if ( SYSCLK_tvc_event && ( SYSCLK == 1'b1 ) )
     begin //{
       if ( sysclk_count == ( ( TVC_i + 1 ) * 4 ) - 1 )
        begin //{
         sysclk_count = 0;
         ADC_CLK      = !ADC_CLK;
         if ( SYSCLK_previous != 0 )
           SYSCLK_period = $time - SYSCLK_previous;
         SYSCLK_previous = $time;
        end  //}
      else if ( sysclk_count < ( ( ( TVC_i + 1 ) * 4 ) - 1 ) )
       begin //{
        sysclk_count    = sysclk_count + 1;
        if ( SYSCLK_previous != 0 )
          SYSCLK_period = $time - SYSCLK_previous;
        SYSCLK_previous = $time;
        if ( sysclk_count == ( ( TVC_i + 1 ) * 4 ) / 2 )
          ADC_CLK = !ADC_CLK;
       end //}
    end //}

      
    ADCRESET_tvc_prev = ADCRESET;
    ADCSTART_tvc_prev = ADCSTART;
    SYSCLK_tvc_prev   = SYSCLK;
  end //} always @ ( SYSCLK or ADCRESET or ADCSTART )

  always @(ADCSTART, ADCSTART_tvc_event, PWRDWN, ADCRESET)
      begin
	  if (PWRDWN == 1'b1 || ADCRESET == 1'b1)
	      wait_for_adcstart = 1'b0;	  
	  else if ( ADCSTART == 1'b1 && ADCSTART_tvc_event )
	      wait_for_adcstart = 1'b1;
      end
  //
  // Generate the check signals(only after the 2nd clock cycle).
  //

  always @ ( posedge ADC_CLK or posedge PWRDWN )
  begin //{
    if (PWRDWN == 1'b1)
      adcclk_check <= 1'b0;
    else if (ADC_CLK == 1'b1 && wait_for_adcstart == 1'b1)
     begin //{
      check1       <= 1'b1;
      adcclk_check <= check1;
     end   //}
  end   //}

  always @ ( TVC_i or SYSCLK_period )
  begin //{
    ADC_CLK_period <= ((TVC_i + 1) * 4) * SYSCLK_period;
  end   //}

  always @ ( ADC_CLK_period )
  begin //{
    if ( ( ( (ADC_CLK_period < 'd100000 ) || ( ADC_CLK_period > 'd1000000 ) ) && adcclk_check == 1'b1) ) 
     begin //{
      if ( WARNING_MSGS_ON == 1 ) 
       begin //{
        $display ( " Error: ADCCLK frequency should be between 1MHz and 10MHz " );
        $display ( " Time: %0.1f Instance: %m ", $realtime );
       end //}
    end   //}
  end   //}

//*************************************************************************************************  
//a to d  Conversion & Resolution Selection
// always ( adc_input or va_ref_real)
    always @ (*)
      begin //{	    
      if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4095.0 )
        begin //{
          comparator_output_12 = 12'b111111111111;
          comparator_output_10 = 12'b111111111100;
          comparator_output_8  = 12'b111111110000;
        end   //}
      else if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4092.0 )
        begin //{
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12 = comparator_output_12_temp;
          comparator_output_10 = 12'b111111111100;
          comparator_output_8  = 12'b111111110000;
        end  //}
      else if ( ( adc_input * 4096.0 ) / ( va_ref_real ) > 4080.0 )
        begin //{
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12 = comparator_output_12_temp;
          comparator_output_10 = {comparator_output_12_temp[11:2], 2'b00};
          comparator_output_8  = 12'b111111110000;
        end   //}
      else if ( adc_input < ( va_ref_real / 4096.0 ) )
        begin //{
          comparator_output_10 = 12'b000000000000;
          comparator_output_12 = 12'b000000000000;
          comparator_output_8  = 12'b000000000000;
        end  //}
      else
        begin //{
          comparator_output_12_temp = ( adc_input * 4096.0 ) / ( va_ref_real );
          comparator_output_12 = comparator_output_12_temp;
          comparator_output_10 = {comparator_output_12_temp[11:2], 2'b00};
          comparator_output_8  = {comparator_output_12_temp[11:4], 4'b0000};
        end   //}
 end //}
//*************************************************************************************************  

//*************************************************************************************************  
// conversion time calculation and output result resolution selection based on mode value
  //   always @ ( SYSCLK_period or STC_i or MODE_i or ADC_CLK_period or SYSCLK_CYCLES_PCAL or
  //              comparator_output_8 or comparator_output_10 or comparator_output_12 )
  always @ (*)              
      begin //{
	  t_sync_read   = SYSCLK_period;
	  t_sync_write  = SYSCLK_period;
	  t_sample      = (2 + STC_i) * ADC_CLK_period;
	  if ( MODE_i < 8 )
	      t_cal         = 2 * ADC_CLK_period;
	  else
	      t_cal = 0;	 
	  //t_powerup_cal = SYSCLK_CYCLES_PCAL * ADC_CLK_period;     
	  case (MODE_i )
	     0, 4, 8, 12 : begin
		 t_distrib = 10 * ADC_CLK_period;
		 result_temp = comparator_output_10;		
	     end
	     1, 5, 9, 13 : begin
		 t_distrib = 12 * ADC_CLK_period;
		 result_temp = comparator_output_12;
	     end
	     2, 6, 10, 14 : begin
		 t_distrib = 8 * ADC_CLK_period;
		 result_temp = comparator_output_8;
	     end
	     default : if ( WARNING_MSGS_ON ) 
		 begin 
		     $display ( " Warning : Reserved ADC mode " );
		     $display ( " Time: %0.1f Instance: %m ", $realtime );
		 end   		     
	  endcase

	  if ( FAST_ADC_CONV_SIM ) begin
	      if (calibration_started == 1'b1) 
		  t_conv = t_distrib;
	      else
		  t_conv = t_distrib + t_cal;
	  end
	  else begin
	      if  (calibration_started == 1'b1)
		  t_conv      = t_sync_read + t_sample + t_distrib + t_sync_write;
	      else
		  t_conv      = t_sync_read + t_sample + t_distrib + t_sync_write + t_cal;
	  end
      end //}
//*************************************************************************************************  


      //
      // Latching of control signals and Powerup calibration.
      // Calibrate, Sample, DataValid and Busy signals
      //
   //always @ (*)
   always @ ( posedge SYSCLK or posedge ADCRESET or posedge PWRDWN )
   begin //{
      // reset digital interface signals when ADCRESET is active
      if ( ADCRESET == 1'b1 )
       begin //{
        // reset input latches
        MODE_i     = 4'b0;
        TVC_i      = 8'b0;
        STC_i      = 8'b0;
        VAREFSEL_lat = 1'b0;
        CHNUMBER_i = 5'b0;
        // reset digital outputs
        BUSY_reg      = 1'b0;
        DATAVALID_reg = 1'b0;
        SAMPLE_reg    = 1'b0;
        RESULT_reg    = 12'b000000000000;
        // reset internal signals
        ad_res_int          = 1;
        calibration_started = 0;
        conversion_started  = 0;
        busy_int            = 0;
       end  //}
   // all ADC activity is triggered on posedge of SYSCLK when ADCRESET is not active
      //else if ( SYSCLK_adc_event && SYSCLK == 1'b1 && ADCRESET == 1'b0 ) 
      else if ( SYSCLK == 1'b1 && ADCRESET == 1'b0 ) 
       begin //{
        // conversion_started flag is reset if ADCSTART is de-asserted
        if ( ADCSTART == 1'b0 && conversion_started == 1'b1 )  
         begin //{
          conversion_started = 0;
         end

        // Latch ADC inputs if ADCSTART is asserted for a new conversion
        if ( ADCSTART == 1'b1 && conversion_started == 1'b0 ) 
	 begin //{
           MODE_i     = MODE;
           TVC_i      = TVC;
           STC_i      = STC;
           VAREFSEL_lat = VAREFSEL;
           CHNUMBER_i = CHNUMBER;
	     if ( CHNUMBER_i == 0 || CHNUMBER_i == 13 || CHNUMBER_i == 14 || CHNUMBER_i > 15) begin
		 if ( WARNING_MSGS_ON == 1 )
		     begin
			 $display ("Error:Invalid CHNUMBER. Currently CHNUMBERs from 1 to 12 and 15 are only supported including limits\n"                             );
			 $display (" Time: %0.1f Instance: %m ", $realtime );
		     end
	     end
           // Set ADC digital interface signals before starting a new conversion
           BUSY_reg          = 1'b1;
           busy_start_time   = $time;
           busy_int          = 1;
           DATAVALID_reg     = 1'b0;
           SAMPLE_reg        = 1'b1;
           sample_start_time = $time;
           conversion_started = 1;
           // assert interrupt_cal to pause calibration if ADCSTART was asserted before power-up calibration
           // (PUK) was initiated or before PUK was completed (intra conversion)
           if ( ad_res_int == 1 || calibration_started == 1 ) 
	    begin //{
             interrupt_cal = 1'b1;
             if ( WARNING_MSGS_ON )
	      begin //{
               $display ( " Warning : ADCSTART is asserted before powerup calibration is completed. " );
               $display ( " Warning : ADC Result will be uncalibrated. " );
               $display ( " Time: %0.1f Instance: %m ", $realtime );
              end  //}
            end  //}
          end //}

        // ADCRESET and PWRDWN are required to be inactive for the entire conversion duration
        else if ( PWRDWN == 1'b0 ) 
	  begin  //{
          // update digital interface signals during and after conversion is complete
           if ( busy_int == 1 )
	    begin  //{
            // de-assert BUSY, drive RESULT and assert DATAVALID upon completion of conversion
              if ( ( $time - busy_start_time ) >= t_conv )
	       begin //{
                BUSY_reg      = 1'b0;
                DATAVALID_reg = 1'b1;
                RESULT_reg    = result_temp;
                busy_int      = 0;
                // if ADCSTART interrupted PUK, de-assert interrup_cal to resume calibration count
                if ( calibration_started == 1 )
                  interrupt_cal = 1'b0;
               end  //}
              // de-assert SAMPLE based on STC
              else if ( ( $time - sample_start_time ) >= t_sample + ( 2 * SYSCLK_period ) )
	       begin //{
                SAMPLE_reg  = 1'b0;
                analog_in   = $bitstoreal ( A_IN ) ;
                if ( analog_in < 0.0 )
                  adc_input = 0.0;
                else
                  adc_input = analog_in;
               end  //}
          end //} if ( busy_int == 1 )

          // latch ADC inputs and initiate power-up calibration on first posedge of SYSCLK after ADCRESET is removed
          if ( ad_res_int == 1 )
	   begin  //{
            fper_cal_count = fper_cal_count + 1;
            if ( fper_cal_count == 3 )
	     begin  //{
              // latch ADC inputs
              MODE_i     = MODE;
              TVC_i      = TVC;
              STC_i      = STC;
              VAREFSEL_lat = VAREFSEL;
              CHNUMBER_i = CHNUMBER;
              // set calibrate signals
              CALIBRATE_reg       = 1'b1;
              calibration_started = 1;
              fper_cal_count      = 0;
              ad_res_int          = 0;
             end  //}
           end //} if ( ad_res_int == 1 )
        end //} if ( ADCSTART == 1'b1 && conversion_started == 1'b0 )

        // if ADCSTART goes unknown when a conversion can be started, generate a warning message
        if ( ADCSTART === 1'bx && conversion_started == 1'b0 )
         begin  //{
          if ( WARNING_MSGS_ON )
	   begin  //{
            $display ( " Warning : ADCSTART is unknown. ADC conversion is not initiated. " );
            $display ( " Time: %0.1f Instance: %m ", $realtime );
           end   //}
         end  //}
       end //}
      else if ( ADCRESET === 1'bx )
       begin  //{
        if ( WARNING_MSGS_ON )
         begin  //{
          $display ( " Warning : ADCRESET is unknown. Driving uknowns on ADC outputs. " );
          $display ( " Time: %0.1f Instance: %m ", $realtime );
         end //}
        BUSY_reg      = 1'bx;
        DATAVALID_reg = 1'bx;
        RESULT_reg    = 12'bx;
        SAMPLE_reg    = 1'bx;
       end //} if (ADCRESET == 1'b1)

    end //}

//*************************************************************************************************

    //
    // counter implementation for CALIBRATE de-assertion
    //

    always @ ( posedge ADC_CLK or posedge ADCRESET )
    begin
      if ( ADCRESET == 1'b1 )
      begin
        CALIBRATE_reg       = 1'b0;
        CALIBRATE_cnt       =  'd0;
        interrupt_cal       = 1'b0;
      end
      else if ( ADCRESET == 1'b0 && ADC_CLK == 1'b1 )
      begin
        if ( CALIBRATE_cnt == 'd3840 )
        begin
          CALIBRATE_reg       = 1'b0;
          CALIBRATE_cnt       =  'd0;
          calibration_started =  'd0;
          // pseudo interrupt to stop counting upon reaching 3840
          interrupt_cal       = 1'b1;
        end
        else
        begin
          if ( interrupt_cal == 1'b0 )
            CALIBRATE_cnt = CALIBRATE_cnt + 1'd1;
        end
      end
    end // always ( posedge ADC_CLK or posedge ADCRESET )

endmodule


 	  
//Analog Config Bus
//This separate module is used only for block level verification.
//For the actual model this logic is included in the top level instance file
//itself.
`timescale 1ps/1ps

module acb_96_bit (
	     input  wire       ACB_RST,
        input  wire       ACB_WEN,
        input  wire [7:0] ACB_ADDR,
        input  wire [7:0] ACB_WDATA,
	              
        output reg  [7:0] ACB_RDATA,
        
        output wire [3:0] AQO_AV1_CONFIG,
        output wire [3:0] AQO_AV2_CONFIG,
        output wire [7:0] AQO_AC_CONFIG,
        output wire [7:0] AQO_AT_CONFIG,
        output wire [1:0] AQ0_DAC_MUX_SEL,
        
        output wire [3:0] AQ1_AV1_CONFIG,
        output wire [3:0] AQ1_AV2_CONFIG,
        output wire [7:0] AQ1_AC_CONFIG,
        output wire [7:0] AQ1_AT_CONFIG,
        output wire [1:0] AQ1_DAC_MUX_SEL,
        
        output wire [3:0] AQ2_AV1_CONFIG,
        output wire [3:0] AQ2_AV2_CONFIG,
        output wire [7:0] AQ2_AC_CONFIG,
        output wire [7:0] AQ2_AT_CONFIG,
        output wire [1:0] AQ2_DAC_MUX_SEL,
        
        output wire [3:0] AQ3_AV1_CONFIG,
        output wire [3:0] AQ3_AV2_CONFIG,
        output wire [7:0] AQ3_AC_CONFIG,
        output wire [7:0] AQ3_AT_CONFIG,
        output wire [1:0] AQ3_DAC_MUX_SEL,
        
        output wire [3:0] AQ4_AV1_CONFIG,
        output wire [3:0] AQ4_AV2_CONFIG,
        output wire [7:0] AQ4_AC_CONFIG,
        output wire [7:0] AQ4_AT_CONFIG,
        output wire [1:0] AQ4_DAC_MUX_SEL,
        
        output wire [3:0] AQ5_AV1_CONFIG,
        output wire [3:0] AQ5_AV2_CONFIG,
        output wire [7:0] AQ5_AC_CONFIG,
        output wire [7:0] AQ5_AT_CONFIG,
        output wire [1:0] AQ5_DAC_MUX_SEL,

        output wire [1:0] DAC0_CONFIG,
        output wire [1:0] DAC1_CONFIG,
        output wire [1:0] DAC2_CONFIG  
        
	  );
	  
parameter ANALOG_QUAD_NUM    = 6 ; //For Fs-200 we have 4 analog quads, for Fs-400 -- 6 Quads
parameter ACB_BYTES_NUM_PER_QUAD = 12 ;
        
reg ACB_WEN_reg ;
reg load_reg ;

integer index;

reg [7:0] ACB_ADDR_reg, ACB_WDATA_reg ;
reg [7:0] ACB_LATCH [1:72] ;  //6 quads , 12 bytes/quad
integer m ;
parameter WARNING_MSGS_ON = 1 ;

initial
 begin //{
 for (m=1 ; m<72 ; m=m+1)
   ACB_LATCH[m] = 8'h00;
 end   //}

//**************************************************************************
//o/p signal assignment
assign AQO_AV1_CONFIG       = ACB_LATCH[9][3:0]; 
assign AQO_AV2_CONFIG       = ACB_LATCH[9][7:4];
assign AQO_AC_CONFIG[2:0]   = ACB_LATCH[10][2:0];
assign AQO_AC_CONFIG[ 3 ]   = ACB_LATCH[10][3] | ACB_LATCH[8][0];
assign AQO_AC_CONFIG[7:4]   = ACB_LATCH[10][7:4];
assign AQO_AT_CONFIG        = ACB_LATCH[11];
assign AQ0_DAC_MUX_SEL[1:0] = ACB_LATCH[12][1:0];

assign AQ1_AV1_CONFIG       = ACB_LATCH[21][3:0]; 
assign AQ1_AV2_CONFIG       = ACB_LATCH[21][7:4];
assign AQ1_AC_CONFIG[2:0]   = ACB_LATCH[22][2:0];
assign AQ1_AC_CONFIG[ 3 ]   = ACB_LATCH[22][3] | ACB_LATCH[8][1];
assign AQ1_AC_CONFIG[7:4]   = ACB_LATCH[22][7:4];
assign AQ1_AT_CONFIG        = ACB_LATCH[23];
assign AQ1_DAC_MUX_SEL[1:0] = ACB_LATCH[24][1:0];

assign AQ2_AV1_CONFIG       = ACB_LATCH[33][3:0]; 
assign AQ2_AV2_CONFIG       = ACB_LATCH[33][7:4];
assign AQ2_AC_CONFIG[2:0]   = ACB_LATCH[34][2:0];
assign AQ2_AC_CONFIG[ 3 ]   = ACB_LATCH[34][3] | ACB_LATCH[8][2];
assign AQ2_AC_CONFIG[7:4]   = ACB_LATCH[34][7:4];
assign AQ2_AT_CONFIG        = ACB_LATCH[35];
assign AQ2_DAC_MUX_SEL[1:0] = ACB_LATCH[36][1:0];

assign AQ3_AV1_CONFIG       = ACB_LATCH[45][3:0]; 
assign AQ3_AV2_CONFIG       = ACB_LATCH[45][7:4];
assign AQ3_AC_CONFIG[2:0]   = ACB_LATCH[46][2:0];
assign AQ3_AC_CONFIG[ 3 ]   = ACB_LATCH[46][3] | ACB_LATCH[8][3];
assign AQ3_AC_CONFIG[7:4]  = ACB_LATCH[46][7:4];
assign AQ3_AT_CONFIG        = ACB_LATCH[47];
assign AQ3_DAC_MUX_SEL[1:0] = ACB_LATCH[48][1:0];

assign AQ4_AV1_CONFIG       = ACB_LATCH[57][3:0]; 
assign AQ4_AV2_CONFIG       = ACB_LATCH[57][7:4];
assign AQ4_AC_CONFIG[2:0]   = ACB_LATCH[58][2:0];
assign AQ4_AC_CONFIG[ 3 ]   = ACB_LATCH[58][3] | ACB_LATCH[8][4];
assign AQ4_AC_CONFIG[7:4]   = ACB_LATCH[58][7:4];
assign AQ4_AT_CONFIG        = ACB_LATCH[59];
assign AQ4_DAC_MUX_SEL[1:0] = ACB_LATCH[60][1:0];

assign AQ5_AV1_CONFIG       = ACB_LATCH[69][3:0]; 
assign AQ5_AV2_CONFIG       = ACB_LATCH[69][7:4];
assign AQ5_AC_CONFIG[2:0]   = ACB_LATCH[70][2:0];
assign AQ5_AC_CONFIG[ 3 ]   = ACB_LATCH[70][3] | ACB_LATCH[8][5];
assign AQ5_AC_CONFIG[7:4]   = ACB_LATCH[70][7:4];
assign AQ5_AT_CONFIG        = ACB_LATCH[71];
assign AQ5_DAC_MUX_SEL[1:0] = ACB_LATCH[72][1:0]; 

  assign DAC0_CONFIG          = ACB_LATCH[7][1:0];
  assign DAC1_CONFIG          = ACB_LATCH[31][1:0];
  assign DAC2_CONFIG          = ACB_LATCH[55][1:0];
  
//---------------------------------------------------------------------------------------------------------
// Analog Configuration Bus (ACB) Handling
// ACB supports 3 operations on the analog configuration latches that
// 1. Reset - ACB_RST is active when at logic "0"
// 2. Write - Falling edge of ACB_WEN closes the ACB latches (latch is open when ACB_WEN is at logic "1"
// 3. Read  - Read is controlled by input address ACB_ADDR; data from selected latch is driven on ACB_RDATA
//---------------------------------------------------------------------------------------------------------

always @ ( ACB_RST or ACB_ADDR or ACB_WEN )
begin
  // reset all the configuration latches
  if ( ACB_RST == 1'b0 ) begin
    for ( index=0; index<(ACB_BYTES_NUM_PER_QUAD*ANALOG_QUAD_NUM); index=index+1 ) begin
      ACB_LATCH[index] = 8'b0;
    end
  end
  // write to latch
  else if ( ACB_RST == 1'b1 && ACB_WEN == 1'b1 ) begin
    if ( (8'd1 <= ACB_ADDR) && (ACB_ADDR <= (ACB_BYTES_NUM_PER_QUAD*ANALOG_QUAD_NUM)) ) begin
      ACB_LATCH[ACB_ADDR] = ACB_WDATA;
    end
    else begin
      if (WARNING_MSGS_ON) begin
        $display ( " ERROR: ACB Address for Write is not in the ACB address range " ) ;
        $display ( " Time: %0.1f Instance: %m ", $realtime );
      end
    end
  end
end

// read from latch is controlled only by input address
always @ ( ACB_ADDR or ACB_WEN )
begin
  if ( (8'd1 <= ACB_ADDR) && (ACB_ADDR <= (ACB_BYTES_NUM_PER_QUAD*ANALOG_QUAD_NUM)) ) begin
    ACB_RDATA = ACB_LATCH[ACB_ADDR] ;
  end
  else begin
    if (WARNING_MSGS_ON) begin
      $display ( " ERROR: ACB Address for Read is not in the ACB address range " ) ; 
      $display ( " Time: %0.1f Instance: %m ", $realtime );
    end
  end
end

endmodule

module obd_mux (DAC_0,
                DAC_1,
                DAC_2,
                DAC_SELECT,
                DAC_MUX_OUT 
               );
       
  input  wire       DAC_0;
  input  wire       DAC_1;
  input  wire       DAC_2;
  input  wire [1:0] DAC_SELECT;
  output reg        DAC_MUX_OUT;

  always @ (*)
  begin
  	case(DAC_SELECT)
  		2'b00	  :	begin
  		            DAC_MUX_OUT = DAC_0; 
  		            $display("DAC_0 Selected");
  		          end
  		2'b01	  :	begin
  		            DAC_MUX_OUT = DAC_1;
  		            $display("DAC_1 Selected");
  		          end
  		2'b10	  :	begin
  		            DAC_MUX_OUT = DAC_2;
  		            $display("DAC_2 Selected");
  		          end
  		2'b11	  :	$display("WARNING: This selection is currently is unsupported. Select signal should be either 0,1, or 2");
  		default : $display("WARNING: This selection is currently is unsupported. Select signal should be either 0,1, or 2");
  	endcase
  	
  end

endmodule

//*****************************************************************************************************
//                      PROPRIETARY INFORMATION
//
//     This document is CONFIDENATIAL and PROPRIETARY and is for
//     the use of Actel Corporation personnel only, except to the 
//     extent that permission is expressly granted elsewhere.
//
// File Name   :    obd.v
// Authors     :    Sreeni Angitapalli
// Function    :    One-Bit DAC
// Description :    One-Bit DAC Logic, sub-block of Analog System in Fusion2
//                  Inputs to this logic are:
//                  1. OBD_DIN - Data input from ACE RTL
//                  2. OBD_CLKIN - Reference input clock for OBD_DIN
//                  3. OBD_ENABLE - Enable for OBD_DIN
// Assumptions :    1.
//                  2.
//*****************************************************************************************************
// Detailed Revision History:
// Version  Date(/MM/DD/YY)   Author              Description   
// 1.0      04/17/08          Sreeni Angitapalli  First versions based on FS-400 Analog System spec.
//*****************************************************************************************************

`timescale 1ns/1ps 
module obd (  input wire [1:0] OBD_CONFIG,
	      input wire OBD_DIN,
	      input wire OBD_CLKIN,
	      input wire OBD_ENABLE,
	      output reg  DAC_OUT
	      );
   parameter [1:0]   RESOLUTION = 2'b00;

  //if RESOLUTION = 00 OBD_RESOLUTION = 8
  //if RESOLUTION = 01 OBD_RESOLUTION = 16
  //if RESOLUTION = 10 OBD_RESOLUTION = 24
  
  localparam 	    OBD_RESOLUTION = (8 * RESOLUTION + 8);
  reg [ OBD_RESOLUTION  : 0 ] ones_counter=0;
  reg [OBD_RESOLUTION : 0 ]  clock_counter=0;
  
  real 		 avg_duty_cycle = 0.0;
  reg  [63:0]		 output_voltage=0;
  reg  [63:0]		 output_current=0;
  wire  [63:0]		 output_value;
  
  integer 		 i;

   wire 		 CUR_VOLB = OBD_CONFIG[0];
  
  always @(posedge OBD_CLKIN)
  begin
	  if (OBD_ENABLE == 1'b1) begin
	    clock_counter <= clock_counter + 1;
	    if (OBD_DIN == 1'b1) begin
        ones_counter <= ones_counter + 1;
	    end // if (OBD_DIN == 1'b1)

	    if (clock_counter == 2 ** OBD_RESOLUTION ) begin
  		  avg_duty_cycle = $bitstoreal(ones_counter)/$bitstoreal(clock_counter);
  		  ones_counter <=0;
		clock_counter <= 0;
		
	    end // if (clock_counter == 2 ** OBD_RESOLUTION - 1)
	  end
  end // always @ (posedge OBD_CLKIN)

  always @( * )
  begin
    if (OBD_ENABLE == 1)
      output_voltage <= $realtobits(avg_duty_cycle * 2.56);
      output_current <= $realtobits(avg_duty_cycle * 256);

	  $display("voltage in bits is %h",output_voltage);
    $display("converted voltage is %e",$bitstoreal(output_voltage));
  end // always *

  assign output_value = CUR_VOLB ? output_current : output_voltage;
  
  always @ ( output_value )
  begin
    #0;
    for ( i=0; i<=63; i=i+1 ) begin
      DAC_OUT = output_value[i];
      #0;
      DAC_OUT = 1'bx;
      #0;
      if ( i == 63 )
        DAC_OUT = 1'bz;
    end
  end

endmodule // obd


//*****************************************************************************************************
//
//     
//                      PROPRIETARY INFORMATION
//
//     This document is CONFIDENATIAL and PROPRIETARY and is for
//     the use of Actel Corporation personnel only, except to the 
//     extent that permission is expressly granted elsewhere.
//
//
//
// File Name   :    F2AB.v
// Authors     :    Shweta
//
// Function    :    Analog System for Fusion2
//
// Description :    This file contains the top-level module for the Analog System in Fusion2
//                  Includes instances of analog quad, analog mux, adc, obd logic blocks.
//
// Assumptions : 1. 
//               2.
//               3.
//*****************************************************************************************************
//
// Detailed Revision History:
//
// Version  Date(MM/DD/YY)   Author               Description   
//
// 1.0      01/21/08         Shweta               First versions based on FS-400 Analog System spec.
//
// 2.0      04/19/08         Sreeni Angitapalli   Logic updated as per updated specs from SDE.
//                                                -- ACB, Configuration bits 
//                                                -- ADC logic updated (CALIBRATE, MUXOUT etc.,)
//
// 3.0      07/31/08         Hima Bindu           Logic updated as per updated specs from SDE.
//                                                -- Integrated new module named acb_96_bit
//                                                -- Connections between analog_quad with acb_96_bit updated 
//
// 4.0      08/06/08         Hima Bindu           Logic updated as per updated specs from SDE.
//                                                -- analog_mux port listing updated and connections between analog_mux and other modules updated
//                                                -- One 12-bit input included that are data enables for the direct anlog inputs at 3 ADCs
//                                                -- One 12-bit output included that are gated direct anlog outputs at 3 ADCs
//                                                
//*****************************************************************************************************

`timescale 1ns/1 ps

module	F2AB (  
	   input wire [5:0] AV1,            //   6 AV1 pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AV2,            //   6 AV2 pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AC,             //   6 AC pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AT,             //   6 AT pad analog inputs for 6 analog_quad modules

      input wire ATGND_01,             //   ATRETURN01,
      input wire ATGND_23,             //   ATRETURN23,
      input wire ATGND_45,             //   ATRETURN23,
	   
	   //input wire [5:0] AC_CM_STB,
	   //input wire [5:0] AT_TM_STB,
	   
	   /*input wire [5:0] AV1_DEN,         //   6 AV1 pad data enable signals
	   input wire [5:0] AV2_DEN,         //   6 AV2 pad data enable signals
	   input wire [5:0] AC_DEN,          //   6 AC pad data enable signals
	   input wire [5:0] AT_DEN,          //   6 AT pad data enable signals*/

      input wire [2:0] VAREF,
	   input wire ADCGNDREF,
	   
	   input wire ADC_VAREFSEL,

	   input wire [3:0] ADC0 ,           //   4 direct analog inputs to the ADC-0
      input wire [3:0] ADC1 ,           //   4 direct analog inputs to the ADC-1
      input wire [3:0] ADC2 ,           //   4 direct analog inputs to the ADC-2

	   input wire [11:0] DEN_ADC,        //    12 data enable signals for 12 direct analog inputs at ADC-0,1,2
	   
	   input wire       ADC0_PWRDWN,      //   Power down signal for ADC-0
	   input wire       ADC0_ADCRESET,    //   Reset signal for ADC-0
	   input wire       ADC0_SYSCLK,      //   Clock signal for ADC-0
	   input wire [4:0] ADC0_CHNUMBER,    //   Channel number select signal for ADC-0
	   input wire [3:0] ADC0_MODE,        //   Mode select signal for ADC-0
	   input wire [7:0] ADC0_TVC,         //   TVC signal for ADC-0
	   input wire [7:0] ADC0_STC,         //   STC signal for ADC-0
	   input wire       ADC0_ADCSTART,    //   Start signal for ADC-0

	   input wire       ADC1_PWRDWN,      //   Power down signal for ADC-1
      input wire       ADC1_ADCRESET,    //   Reset signal for ADC-1
      input wire       ADC1_SYSCLK,      //   Clock signal for ADC-1
      input wire [4:0] ADC1_CHNUMBER,    //   Channel number select signal for ADC-1
      input wire [3:0] ADC1_MODE,        //   Mode select signal for ADC-1
      input wire [7:0] ADC1_TVC,         //   TVC signal for ADC-1
      input wire [7:0] ADC1_STC,         //   STC signal for ADC-1
      input wire       ADC1_ADCSTART,    //   Start signal for ADC-1

	   input wire       ADC2_PWRDWN,      //   Power down signal for ADC-2
      input wire       ADC2_ADCRESET,    //   Reset signal for ADC-2
      input wire       ADC2_SYSCLK,      //   Clock signal for ADC-2
      input wire [4:0] ADC2_CHNUMBER,    //   Channel number select signal for ADC-2
      input wire [3:0] ADC2_MODE,        //   Mode select signal for ADC-2
      input wire [7:0] ADC2_TVC,         //   TVC signal for ADC-2
      input wire [7:0] ADC2_STC,         //   STC signal for ADC-2
      input wire       ADC2_ADCSTART,    //   Start signal for ADC-2

      input wire       ACB_RST,          //   Reset signal for ACB bus
	   input wire       ACB_WEN,          //   Write enable signal for ACB bus
	   input wire [7:0] ACB_ADDR,         //   Address signal for ACB bus
	   input wire [7:0] ACB_WDATA,        //   Data In signal for ACB bus
	   
	   output  wire      ADC_VAREFOUT,
	   
	   output wire [7:0]  ACB_RDATA,       //   Data Out signal for ACB bus

	   output wire        ADC0_BUSY,      //   Busy signal from ADC-0
	   output wire        ADC0_CALIBRATE, //   Calibrate signal from ADC-0
	   output wire        ADC0_DATAVALID, //   Data valid signal from ADC-0
	   output wire        ADC0_SAMPLE,    //   Sampling signal from ADC-0
	   output wire [11:0] ADC0_RESULT,    //   Converted digital output signal from ADC-0 for the analog input 

	   output wire        ADC1_BUSY,      //   Busy signal from ADC-1
      output wire        ADC1_CALIBRATE, //   Calibrate signal from ADC-1
      output wire        ADC1_DATAVALID, //   Data valid signal from ADC-1
      output wire        ADC1_SAMPLE,    //   Sampling signal from ADC-1
      output wire [11:0] ADC1_RESULT,    //   Converted digital output signal from ADC-1 for the analog input

	   output wire        ADC2_BUSY,      //   Busy signal from ADC-2
      output wire        ADC2_CALIBRATE, //   Calibrate signal from ADC-2
      output wire        ADC2_DATAVALID, //   Data valid signal from ADC-2
      output wire        ADC2_SAMPLE,    //   Sampling signal from ADC-2
      output wire [11:0] ADC2_RESULT,    //   Converted digital output signal from ADC-2 for the analog input
      
      output wire        DACOUT0,        //   Converted Analog output of DAC-0
      output wire        DACOUT1,        //   Converted Analog output of DAC-1
      output wire        DACOUT2,        //   Converted Analog output of DAC-2
      
      output wire [11:0] DIG_ADC, 

      input wire  [2:0]  OBD_DIN,        //   Digital data input signals for DAC-0, DAC-1, and DAC-2
      input wire  [2:0]  OBD_CLKIN,      //   Clock signals for DAC-0, DAC-1, and DAC-2
      input wire  [2:0]  OBD_ENABLE,     //   Data enable signals for DAC-0, DAC-1, and DAC-2

      
      output wire [11:0] COMPARATOR

   );
  
  parameter WIDTH              = 32;
   parameter [5:0] DAC_RESOLUTION = 6'b0;
  
  // Used to turn off warnings messages.
  // Default = ON.  Set to 0 to turn them OFF.
  parameter WARNING_MSGS_ON    = 1; 

  parameter FAST_ADC_CONV_SIM  = 0;
  parameter ANALOG_QUAD_NUM    = 6 ; //For Fs-200 we have 4 analog quads, for Fs-400 -- 6 Quads
  parameter ADC_NUM            = 3 ; //Number of ADCs in the system
  parameter NUM_ADC_IN         = 5 ; //Number of direct analog inputs to each ADC
  parameter VAREF_INT          = 2.56 ;

//  parameter MEMORYFILE         = "";
//---------------------------------------------------------------------------------------------------------
  wire          VAREFSEL;
  wire   [2:0]  at_gnd;

  wire          VAREFSEL_ipd;
  wire          VAREFSEL_lat;
  wire          VAREFSEL_lat0, VAREFSEL_lat1, VAREFSEL_lat2 ;
  real          va_ref_ext_0,va_ref_ext_1,va_ref_ext_2;
  real 	        va_ref_real_0,va_ref_real_1,va_ref_real_2, gnd_ref_real, va_ref_real_out;

  wire signed [2 * WIDTH-1:0]    VA_REF_VECTOR_0,VA_REF_VECTOR_1,VA_REF_VECTOR_2, GND_REF_VECTOR;

  //wire                 VAREF_in ;
  wire                 VAREF_out ; 
  wire signed [63:0]   VAREF_IN[2:0] ; 
  
  wire [11:0]    adc_direct_input;

  //reg  [63:0] ADC_IN_VECTOR  [0: (ADC_NUM*NUM_ADC_IN)-1] ;
  reg  [63:0] ADC_IN_VECTOR  [0: 11] ;
  
  wire signed [63:0] ADC0_IN_0 ;
  wire signed [63:0] ADC0_IN_1 ;
  wire signed [63:0] ADC0_IN_2 ;
  wire signed [63:0] ADC0_IN_3 ;
  wire signed [63:0] ADC0_IN_4 ;

  wire signed [63:0] ADC1_IN_0 ;
  wire signed [63:0] ADC1_IN_1 ;
  wire signed [63:0] ADC1_IN_2 ;
  wire signed [63:0] ADC1_IN_3 ;
  wire signed [63:0] ADC1_IN_4 ;

  wire signed [63:0] ADC2_IN_0 ;
  wire signed [63:0] ADC2_IN_1 ;
  wire signed [63:0] ADC2_IN_2 ; 
  wire signed [63:0] ADC2_IN_3 ;
  wire signed [63:0] ADC2_IN_4 ;
  
  
//declarations of intermodule ports
  wire  [2:0]  QUAD_NUM;
  wire  [2:0]  QUAD_NUM_OP ; 
  wire  [15:0] AV1_WORD;
  wire  [15:0] AV2_WORD;
  wire  [15:0] AC_WORD;
  wire  [15:0] AT_WORD;

  reg [63:0] AV1_OUT_reg [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AV2_OUT_reg [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AC_OUT_reg  [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AT_OUT_reg  [0 : ANALOG_QUAD_NUM-1 ] ;
  
  wire[63:0] DAC_VECTOR  [0 : ADC_NUM-1];

  reg [63:0] AV1_OUT  ;
  reg [63:0] AV2_OUT  ;
  reg [63:0] AC_OUT   ;
  reg [63:0] AT_OUT   ;
  
  wire [3:0] AV1_CONFIG [0: ANALOG_QUAD_NUM-1];
  wire [3:0] AV2_CONFIG [0: ANALOG_QUAD_NUM-1];
  wire [7:0] AC_CONFIG  [0: ANALOG_QUAD_NUM-1];
  wire [7:0] AT_CONFIG  [0: ANALOG_QUAD_NUM-1];
  wire [1:0] DAC_CONFIG [0: ANALOG_QUAD_NUM/2-1];
  
  wire [1:0] AQ0_DAC_MUX_SEL, AQ1_DAC_MUX_SEL, AQ2_DAC_MUX_SEL, AQ3_DAC_MUX_SEL, AQ4_DAC_MUX_SEL, AQ5_DAC_MUX_SEL;
        
  reg ACB_WEN_reg ;
  reg load_reg ;

  reg [7:0] ACB_ADDR_reg, ACB_WDATA_reg ;
  reg [7:0] ACB_LATCH [0:(8*ANALOG_QUAD_NUM-1)] ;  //6quads , 8bytes/quad
  
  wire [1:0] DAC_MUX_SELECT[0 : ANALOG_QUAD_NUM-1];

  wire [ANALOG_QUAD_NUM-1 : 0] VAREFDAC;

  wire [63:0] AV1_OUT_tmp ;
  wire [63:0] AV2_OUT_tmp ;
  wire [63:0] AC_OUT_tmp ;
  wire [63:0] AT_OUT_tmp ;
  
  //reg [63:0] MUX_OUT_reg [0 : ADC_NUM-1] ; 
  wire [63:0] MUX_OUT_reg [0 : ADC_NUM-1] ; 

  //wire [63:0] MUXOUT ;

  reg [4:0]  CH_NUM  [0 : ADC_NUM-1] ;
  integer    j, k, index ;
  wire [2:0] DAC_OUT;
  
  
  and U116 (DIG_ADC[0], ADC0[0], DEN_ADC[0]);
  and U117 (DIG_ADC[1], ADC0[1], DEN_ADC[1]);
  and U118 (DIG_ADC[2], ADC0[2], DEN_ADC[2]);
  and U119 (DIG_ADC[3], ADC0[3], DEN_ADC[3]);
  
  and U120 (DIG_ADC[4], ADC1[0], DEN_ADC[4]);
  and U122 (DIG_ADC[5], ADC1[1], DEN_ADC[5]);
  and U123 (DIG_ADC[6], ADC1[2], DEN_ADC[6]);
  and U124 (DIG_ADC[7], ADC1[3], DEN_ADC[7]);
  
  and U125 (DIG_ADC[8], ADC2[0], DEN_ADC[8]);
  and U126 (DIG_ADC[9], ADC2[1], DEN_ADC[9]);
  and U127 (DIG_ADC[10], ADC2[2], DEN_ADC[10]);
  and U128 (DIG_ADC[11], ADC2[3], DEN_ADC[11]);
  
  
 
  assign  VAREFSEL     =  ADC_VAREFSEL;
  assign  VAREFSEL_lat = (VAREFSEL_lat0 | VAREFSEL_lat1 |  VAREFSEL_lat2) ;
  assign  at_gnd       = { ATGND_45, ATGND_23, ATGND_01 };  
  
  assign  adc_direct_input = {ADC2[3],ADC2[2],ADC2[1],ADC2[0],
                              ADC1[3],ADC1[2],ADC1[1],ADC1[0],
                              ADC0[3],ADC0[2],ADC0[1],ADC0[0]};

  //buf U106 (VAREFSEL_ipd, VAREFSEL);

  // "Deserialize" / Read analog inputs for all quads
  // NOTE: Inverted version of VAREFSEL is being used becoz the enable input
  // of the below read_analog_io module is active low.
  
  read_analog_io read_analog_input_VAREF_0    ( VAREF[0] , !VAREFSEL   , VA_REF_VECTOR_0  );
  read_analog_io read_analog_input_VAREF_1    ( VAREF[1] , !VAREFSEL   , VA_REF_VECTOR_1  );
  read_analog_io read_analog_input_VAREF_2    ( VAREF[2] , !VAREFSEL   , VA_REF_VECTOR_2  );
  
  
  read_analog_io read_analog_input_GNDREF   ( GNDREF   , 1'b0        , GND_REF_VECTOR );

  read_analog_io read_analog_input_adc01    ( adc_direct_input[0]  , 1'b0        , ADC0_IN_0 );
  read_analog_io read_analog_input_adc02    ( adc_direct_input[1]  , 1'b0        , ADC0_IN_1 );
  read_analog_io read_analog_input_adc03    ( adc_direct_input[2]  , 1'b0        , ADC0_IN_2 );
  read_analog_io read_analog_input_adc04    ( adc_direct_input[3]  , 1'b0        , ADC0_IN_3 );
  //read_analog_io read_analog_input_adc05    ( ADC0[4]  , 1'b0        , ADC0_IN_4 );

  read_analog_io read_analog_input_adc11    ( adc_direct_input[4]  , 1'b0        , ADC1_IN_0 );
  read_analog_io read_analog_input_adc12    ( adc_direct_input[5]  , 1'b0        , ADC1_IN_1 );
  read_analog_io read_analog_input_adc13    ( adc_direct_input[6]  , 1'b0        , ADC1_IN_2 );
  read_analog_io read_analog_input_adc14    ( adc_direct_input[7]  , 1'b0        , ADC1_IN_3 );
  //read_analog_io read_analog_input_adc15    ( ADC1[4]  , 1'b0        , ADC1_IN_4 );

  read_analog_io read_analog_input_adc21    ( adc_direct_input[8]  , 1'b0        , ADC2_IN_0 );
  read_analog_io read_analog_input_adc22    ( adc_direct_input[9]  , 1'b0        , ADC2_IN_1 );
  read_analog_io read_analog_input_adc23    ( adc_direct_input[10]  , 1'b0        , ADC2_IN_2 );
  read_analog_io read_analog_input_adc24    ( adc_direct_input[11]  , 1'b0        , ADC2_IN_3 );
  //read_analog_io read_analog_input_adc25    ( ADC2[4]  , 1'b0        , ADC2_IN_4 );

  drive_varef_out drive_analog_output_VAREF ( $realtobits( VAREF_INT ), !VAREFSEL , ADC_VAREFOUT );
  
  read_analog_io read_analog_input_dac0    ( DAC_OUT[0]  , 1'b0        , DAC_VECTOR[0] );
  read_analog_io read_analog_input_dac1    ( DAC_OUT[1]  , 1'b0        , DAC_VECTOR[1] );
  read_analog_io read_analog_input_dac2    ( DAC_OUT[2]  , 1'b0        , DAC_VECTOR[2] );

  always @ (*)
  begin  //{
    ADC_IN_VECTOR[0]  = ADC0_IN_0 ;
    ADC_IN_VECTOR[1]  = ADC0_IN_1 ;
    ADC_IN_VECTOR[2]  = ADC0_IN_2 ;
    ADC_IN_VECTOR[3]  = ADC0_IN_3 ;
    //ADC_IN_VECTOR[4]  = ADC0_IN_4 ;
    ADC_IN_VECTOR[4]  = ADC1_IN_0 ;
    ADC_IN_VECTOR[5]  = ADC1_IN_1 ;
    ADC_IN_VECTOR[6]  = ADC1_IN_2 ;
    ADC_IN_VECTOR[7]  = ADC1_IN_3 ;
    //ADC_IN_VECTOR[9]  = ADC1_IN_4 ;
    ADC_IN_VECTOR[8]  = ADC2_IN_0 ;
    ADC_IN_VECTOR[9]  = ADC2_IN_1 ;
    ADC_IN_VECTOR[10] = ADC2_IN_2 ;
    ADC_IN_VECTOR[11] = ADC2_IN_3 ;
    //ADC_IN_VECTOR[14] = ADC2_IN_4 ;
  end    //}

  always @ ( VA_REF_VECTOR_0  ) va_ref_ext_0   <= $bitstoreal ( VA_REF_VECTOR_0  );
  always @ ( VA_REF_VECTOR_1  ) va_ref_ext_1   <= $bitstoreal ( VA_REF_VECTOR_1  );
  always @ ( VA_REF_VECTOR_2  ) va_ref_ext_2   <= $bitstoreal ( VA_REF_VECTOR_2  );

  always @ ( GND_REF_VECTOR ) gnd_ref_real <= $bitstoreal ( GND_REF_VECTOR );

  // use latched value of VAREFLSEL for selecting source of internal va_ref_real input to ADC
  always @ ( VAREFSEL_lat, va_ref_ext_0,va_ref_ext_1,va_ref_ext_2 )
  begin
    if ( VAREFSEL_lat == 1'b1 )
    begin
      va_ref_real_0 <= va_ref_ext_0;
      va_ref_real_1 <= va_ref_ext_1;
      va_ref_real_2 <= va_ref_ext_2;
    end
    else if ( VAREFSEL_lat == 1'b0 )
    begin
      va_ref_real_0 <= VAREF_INT;   //VAREF_INT holds internal ref voltage 
      va_ref_real_1 <= VAREF_INT;   //VAREF_INT holds internal ref voltage
      va_ref_real_2 <= VAREF_INT;   //VAREF_INT holds internal ref voltage
    end
    else if ( VAREFSEL_lat === 1'bx ) begin
      if ( WARNING_MSGS_ON == 1 ) begin
        $display ( " Error : VAREFSEL is unknown " );
        $display ( " Time: %0.1f Instance: %m ", $realtime );
      end
    end
  end

    // Internal and external VAREF handling
   /* assign VAREF_in  = ( VAREFSEL == 1'b1 ) ? VAREF     : 1'bz;
    assign VAREF     = ( VAREFSEL == 1'b0 ) ? VAREF_out : 1'bz;*/
    assign VAREF_IN[0]  = $realtobits (va_ref_real_0) ;
    assign VAREF_IN[1]  = $realtobits (va_ref_real_1) ;
    assign VAREF_IN[2]  = $realtobits (va_ref_real_2) ;
  
//---------------------------------------------------------------------------------------------------------
  genvar        i;


acb_96_bit acb(
             .ACB_RST        (ACB_RST      ),
             .ACB_WEN        (ACB_WEN      ),
             .ACB_ADDR       (ACB_ADDR     ),
             .ACB_WDATA      (ACB_WDATA    ),
             .ACB_RDATA      (ACB_RDATA    ),
             .AQO_AV1_CONFIG (AV1_CONFIG[0]),
             .AQO_AV2_CONFIG (AV2_CONFIG[0]),
             .AQO_AC_CONFIG  (AC_CONFIG[0] ),
             .AQO_AT_CONFIG  (AT_CONFIG[0] ),
             .AQ0_DAC_MUX_SEL(AQ0_DAC_MUX_SEL),
             .AQ1_AV1_CONFIG (AV1_CONFIG[1]),
             .AQ1_AV2_CONFIG (AV2_CONFIG[1]),
             .AQ1_AC_CONFIG  (AC_CONFIG[1] ),
             .AQ1_AT_CONFIG  (AT_CONFIG[1] ),
             .AQ1_DAC_MUX_SEL(AQ1_DAC_MUX_SEL),
             .AQ2_AV1_CONFIG (AV1_CONFIG[2]),
             .AQ2_AV2_CONFIG (AV2_CONFIG[2]),
             .AQ2_AC_CONFIG  (AC_CONFIG[2] ),
             .AQ2_AT_CONFIG  (AT_CONFIG[2] ),
             .AQ2_DAC_MUX_SEL(AQ2_DAC_MUX_SEL),
             .AQ3_AV1_CONFIG (AV1_CONFIG[3]),
             .AQ3_AV2_CONFIG (AV2_CONFIG[3]),
             .AQ3_AC_CONFIG  (AC_CONFIG[3] ),
             .AQ3_AT_CONFIG  (AT_CONFIG[3] ),
             .AQ3_DAC_MUX_SEL(AQ3_DAC_MUX_SEL),
             .AQ4_AV1_CONFIG (AV1_CONFIG[4]),
             .AQ4_AV2_CONFIG (AV2_CONFIG[4]),
             .AQ4_AC_CONFIG  (AC_CONFIG[4] ),
             .AQ4_AT_CONFIG  (AT_CONFIG[4] ),
             .AQ4_DAC_MUX_SEL(AQ4_DAC_MUX_SEL),
             .AQ5_AV1_CONFIG (AV1_CONFIG[5]),
             .AQ5_AV2_CONFIG (AV2_CONFIG[5]),
             .AQ5_AC_CONFIG  (AC_CONFIG[5] ),
             .AQ5_AT_CONFIG  (AT_CONFIG[5] ),
             .AQ5_DAC_MUX_SEL(AQ5_DAC_MUX_SEL),
	     .DAC0_CONFIG    (DAC_CONFIG[0]),
	     .DAC1_CONFIG    (DAC_CONFIG[1]),
	     .DAC2_CONFIG    (DAC_CONFIG[2])
         );

//---------------------------------------------------------------------------------------------------------
//Instantiation of Analog Quad Block
generate 
 for (i=0 ; i<ANALOG_QUAD_NUM ; i=i+1)
  begin:aq_loop //{                  //
   wire  [63:0] av1_out, av2_out, ac_out, at_out ;
   analog_quad aq(
	            // inputs to analog quad
		                .VAREF_IN    (VAREF_IN[i/2]),
                    // varef from DAC, alternate input for comparator in AC & AT pads
                    //.VAREF_DAC   (DAC_OUT[i/2]),
                      .VAREF_DAC   (VAREFDAC[i]),
	                   .AV1_IN      (AV1[i]      ),
                      .AV2_IN      (AV2[i]      ),
		                .AC_IN       (AC[i]       ),
		                .AT_IN       (AT[i]       ),
		                .AT_GND      (at_gnd[i/2] ),
		                .DIRECT_ANALOG0 (adc_direct_input[(i*2)]),
		                .DIRECT_ANALOG1 (adc_direct_input[(i*2)+1]),
		    // direct digital input related signals
		                //.AV1_DIN     (AV1_DOUT[i] ),   
		                //.AV1_DEN     (AV1_DEN[i]  ),    
		                //.AV2_DIN     (AV2_DOUT[i] ),  
		                //.AV2_DEN     (AV2_DEN[i]  ), 
		                //.AC_DIN      (AC_DOUT[i]  ),
		                //.AC_DEN      (AC_DEN[i]   ),
		                //.AT_DIN      (AT_DOUT[i]  ),
		                //.AT_DEN      (AT_DEN[i]   ),
		    // outputs from analog quad go to analog mux
                      .AV1_OUT     ( ),
	                   .AV2_OUT     ( ),
                      .AC_OUT      ( ),
                      .AT_OUT      ( ),
		    // analog config latch bits, 2 bytes 
	                   //.AV1_WORD    ( {ACB_LATCH[(i*8) + 1],ACB_LATCH[(i*8) + 0]} ),
                      //.AV2_WORD    ( {ACB_LATCH[(i*8) + 3],ACB_LATCH[(i*8) + 2]} ),
                      //.AC_WORD     ( {ACB_LATCH[(i*8) + 6],ACB_LATCH[(i*8) + 4]} ),
		                //.AT_WORD     ( {ACB_LATCH[(i*8) + 7],ACB_LATCH[(i*8) + 5]} ),
		                .AV1_CONFIG  (AV1_CONFIG[i]),
		                .AV2_CONFIG  (AV2_CONFIG[i]),
		                .AC_CONFIG   (AC_CONFIG[i] ),
		                .AT_CONFIG   (AT_CONFIG[i] ),
		                
                    // comparator output
                      .AC_COMP_OUT (COMPARATOR[i*2]  ),
                      .AT_COMP_OUT (COMPARATOR[i*2+1])
                  ) ;	  
  end	//}  
endgenerate 	 
//---------------------------------------------------------------------------------------------------------

//heirarchially accessing the generated quad modules' signals
always @ (*)
begin //{
AV1_OUT_reg[0] = aq_loop[0].aq.AV1_OUT; 
AV2_OUT_reg[0] = aq_loop[0].aq.AV2_OUT;
AC_OUT_reg[0]  = aq_loop[0].aq.AC_OUT;
AT_OUT_reg[0]  = aq_loop[0].aq.AT_OUT;
AV1_OUT_reg[1] = aq_loop[1].aq.AV1_OUT; 
AV2_OUT_reg[1] = aq_loop[1].aq.AV2_OUT;
AC_OUT_reg[1]  = aq_loop[1].aq.AC_OUT;
AT_OUT_reg[1]  = aq_loop[1].aq.AT_OUT;
AV1_OUT_reg[2] = aq_loop[2].aq.AV1_OUT; 
AV2_OUT_reg[2] = aq_loop[2].aq.AV2_OUT;
AC_OUT_reg[2]  = aq_loop[2].aq.AC_OUT;
AT_OUT_reg[2]  = aq_loop[2].aq.AT_OUT;
AV1_OUT_reg[3] = aq_loop[3].aq.AV1_OUT; 
AV2_OUT_reg[3] = aq_loop[3].aq.AV2_OUT;
AC_OUT_reg[3]  = aq_loop[3].aq.AC_OUT;
AT_OUT_reg[3]  = aq_loop[3].aq.AT_OUT;
AV1_OUT_reg[4] = aq_loop[4].aq.AV1_OUT; 
AV2_OUT_reg[4] = aq_loop[4].aq.AV2_OUT;
AC_OUT_reg[4]  = aq_loop[4].aq.AC_OUT;
AT_OUT_reg[4]  = aq_loop[4].aq.AT_OUT;
AV1_OUT_reg[5] = aq_loop[5].aq.AV1_OUT; 
AV2_OUT_reg[5] = aq_loop[5].aq.AV2_OUT;
AC_OUT_reg[5]  = aq_loop[5].aq.AC_OUT;
AT_OUT_reg[5]  = aq_loop[5].aq.AT_OUT;
end   //}

always @ (*)
begin //{
  CH_NUM[0] =  ADC0_CHNUMBER ;
  CH_NUM[1] =  ADC1_CHNUMBER ;
  CH_NUM[2] =  ADC2_CHNUMBER ;

end   //}
//---------------------------------------------------------------------------------------------------------
//Instantiation of Analog mux block
generate //{ 
for (i=0 ; i < ADC_NUM ; i=i+1)
begin:mux_loop //{
analog_mux a_mux1(
                  .CHNUMBER_I        (CH_NUM[i]              ),
                  .AV01              (AV1_OUT_reg[i*2]       ),
                  .AV02              (AV2_OUT_reg[i*2]       ),
                  .AC0               (AC_OUT_reg[i*2]        ),
                  .AT0               (AT_OUT_reg[i*2]        ),
                  .AV11              (AV1_OUT_reg[i*2 + 1]   ),
                  .AV12              (AV2_OUT_reg[i*2 + 1]   ),
                  .AC1               (AC_OUT_reg[i*2 + 1]    ),
                  .AT1               (AT_OUT_reg[i*2 + 1]    ),
                  .ADC_IN_VECTOR_0   (ADC_IN_VECTOR[i*4]     ),	                
                  .ADC_IN_VECTOR_1   (ADC_IN_VECTOR[i*4 + 1] ),
		              .ADC_IN_VECTOR_2   (ADC_IN_VECTOR[i*4 + 2] ),
		              .ADC_IN_VECTOR_3   (ADC_IN_VECTOR[i*4 + 3] ),
		              .DAC_VECTOR        (DAC_VECTOR[i]          ),
		              .MUXOUT            (MUX_OUT_reg[i]         )
	         ) ;  
end  //}
endgenerate //}
			
//---------------------------------------------------------------------------------------------------------
//heirarchially accessing the generated quad modules' signals
//always @ (*)
//begin //{
//  MUX_OUT_reg[0] = mux_loop[0].a_mux1.MUXOUT   ;
//  MUX_OUT_reg[1] = mux_loop[1].a_mux1.MUXOUT   ;
//  MUX_OUT_reg[2] = mux_loop[2].a_mux1.MUXOUT   ;
//end   //}

//---------------------------------------------------------------------------------------------------------
//Instantiation of ADC
adc u_adc0(
	 .VAREF_INPUT  (VAREF_IN[0]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[0]),
	 .PWRDWN       (ADC0_PWRDWN   ),
	 .ADCRESET     (ADC0_ADCRESET ),
    .SYSCLK       (ADC0_SYSCLK   ),	 
	 .CHNUMBER     (ADC0_CHNUMBER ),
    .MODE         (ADC0_MODE     ),
    .TVC          (ADC0_TVC      ),
	 .STC          (ADC0_STC      ),
    .ADCSTART     (ADC0_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat0 ),
	 .BUSY         (ADC0_BUSY     ),
	 .CALIBRATE    (ADC0_CALIBRATE),
	 .DATAVALID    (ADC0_DATAVALID),
	 .SAMPLE       (ADC0_SAMPLE   ), 
	 .RESULT       (ADC0_RESULT   )   
	 );

adc u_adc1(
	 .VAREF_INPUT  (VAREF_IN[1]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[1]),
	 .PWRDWN       (ADC1_PWRDWN   ),
	 .ADCRESET     (ADC1_ADCRESET ),
    .SYSCLK       (ADC1_SYSCLK   ),	 
	 .CHNUMBER     (ADC1_CHNUMBER ),
    .MODE         (ADC1_MODE     ),
    .TVC          (ADC1_TVC      ),
	 .STC          (ADC1_STC      ),
    .ADCSTART     (ADC1_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat1 ),
	 .BUSY         (ADC1_BUSY     ),
	 .CALIBRATE    (ADC1_CALIBRATE),
	 .DATAVALID    (ADC1_DATAVALID),
	 .SAMPLE       (ADC1_SAMPLE   ), 
	 .RESULT       (ADC1_RESULT   )   
	 );

adc u_adc2(
	 .VAREF_INPUT  (VAREF_IN[2]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[2]),
	 .PWRDWN       (ADC2_PWRDWN   ),
	 .ADCRESET     (ADC2_ADCRESET ),
    .SYSCLK       (ADC2_SYSCLK   ),	 
	 .CHNUMBER     (ADC2_CHNUMBER ),
    .MODE         (ADC2_MODE     ),
    .TVC          (ADC2_TVC      ),
	 .STC          (ADC2_STC      ),
    .ADCSTART     (ADC2_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat2 ),
	 .BUSY         (ADC2_BUSY     ),
	 .CALIBRATE    (ADC2_CALIBRATE),
	 .DATAVALID    (ADC2_DATAVALID),
	 .SAMPLE       (ADC2_SAMPLE   ), 
	 .RESULT       (ADC2_RESULT   )   
	 );

//---------------------------------------------------------------------------------------------------------
// Analog Configuration Bus (ACB) Handling
// ACB supports 3 operations on the analog configuration latches that
// 1. Reset - ACB_RST is active when at logic "1"
// 2. Write - Falling edge of ACB_WEN closes the ACB latches (latch is open when ACB_WEN is at logic "1"
// 3. Read  - Read is controlled by input address ACB_ADDR; data from selected latch is driven on ACB_RDATA
//---------------------------------------------------------------------------------------------------------

/*always @ ( ACB_RST or ACB_ADDR or ACB_WEN )
begin
  // reset all the configuration latches
  if ( ACB_RST == 1'b1 ) begin
    for ( index=0; index<(8*ANALOG_QUAD_NUM); index=index+1 ) begin
      ACB_LATCH[index] = 8'b0;
    end
  end
  // write to latch
  else if ( ACB_RST == 1'b0 && ACB_WEN == 1'b0 ) begin
    if ( (8'd0 <= ACB_ADDR) && (ACB_ADDR < (8*ANALOG_QUAD_NUM)) ) begin
      ACB_LATCH[ACB_ADDR] = ACB_WDATA;
    end
    else begin
      if (WARNING_MSGS_ON) begin
        $display ( " ERROR: ACB Address for Write is not in the ACB address range " ) ;
        $display ( " Time: %0.1f Instance: %m ", $realtime );
      end
    end
  end
end

// read from latch is controlled only by input address
always @ ( ACB_ADDR or ACB_WEN )
begin
  if ( (8'd0 <= ACB_ADDR) && (ACB_ADDR < (8*ANALOG_QUAD_NUM)) ) begin
    ACB_RDATA = ACB_LATCH[ACB_ADDR] ;
  end
  else begin
    if (WARNING_MSGS_ON) begin
      $display ( " ERROR: ACB Address for Read is not in the ACB address range " ) ;
      $display ( " Time: %0.1f Instance: %m ", $realtime );
    end
  end
end*/


genvar obd_index,obd_mux_index;

generate
for (obd_mux_index = 0; obd_mux_index<ANALOG_QUAD_NUM ; obd_mux_index = obd_mux_index+1)
begin: obd_mux_loop
obd_mux u_obd_mux (
                       .DAC_0       (DAC_OUT[0]),
                       .DAC_1       (DAC_OUT[1]),
                       .DAC_2       (DAC_OUT[2]),
                       .DAC_SELECT  (DAC_MUX_SELECT[obd_mux_index]), 
                       .DAC_MUX_OUT (VAREFDAC[obd_mux_index])
                   );
end
endgenerate  
  
//---------------------------------------------------------------------------------------------------------
// One-Bit DAC Logic


assign DAC_MUX_SELECT[0] = AQ0_DAC_MUX_SEL;
assign DAC_MUX_SELECT[1] = AQ1_DAC_MUX_SEL;
assign DAC_MUX_SELECT[2] = AQ2_DAC_MUX_SEL;
assign DAC_MUX_SELECT[3] = AQ3_DAC_MUX_SEL;
assign DAC_MUX_SELECT[4] = AQ4_DAC_MUX_SEL;
assign DAC_MUX_SELECT[5] = AQ5_DAC_MUX_SEL;


generate
  for (obd_index=0 ; obd_index<3 ; obd_index=obd_index+1)
  begin: obd_loop
    obd #(.RESOLUTION(DAC_RESOLUTION[obd_index*2 + 1:obd_index*2]))
	u_obd (
	       .OBD_CONFIG (DAC_CONFIG[obd_index]), 
	       .OBD_DIN    (OBD_DIN   [obd_index]), 
	       .OBD_CLKIN  (OBD_CLKIN [obd_index]), 
	       .OBD_ENABLE (OBD_ENABLE[obd_index]),
	       .DAC_OUT    (DAC_OUT   [obd_index]) 
	       );
  end
endgenerate

// DAC output is registered version of OBD_DIN generated by ACE RTL
// Logic of DAC is not yet defined and hence this approximation
// Update logic in obd.v file to reflect the implementation

assign DACOUT0 = DAC_OUT[0];
assign DACOUT1 = DAC_OUT[1];
assign DACOUT2 = DAC_OUT[2];

//---------------------------------------------------------------------------------------------------------
endmodule



`timescale 1ns/1 ps

module	F2AB_F060 (  
	   input wire [5:0] AV1,            //   6 AV1 pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AV2,            //   6 AV2 pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AC,             //   6 AC pad analog inputs for 6 analog_quad modules
	   input wire [5:0] AT,             //   6 AT pad analog inputs for 6 analog_quad modules

      input wire ATGND_01,             //   ATRETURN01,
      input wire ATGND_23,             //   ATRETURN23,
      input wire ATGND_45,             //   ATRETURN23,
	   
	   //input wire [5:0] AC_CM_STB,
	   //input wire [5:0] AT_TM_STB,
	   
	   /*input wire [5:0] AV1_DEN,         //   6 AV1 pad data enable signals
	   input wire [5:0] AV2_DEN,         //   6 AV2 pad data enable signals
	   input wire [5:0] AC_DEN,          //   6 AC pad data enable signals
	   input wire [5:0] AT_DEN,          //   6 AT pad data enable signals*/

      input wire [2:0] VAREF,
	   input wire ADCGNDREF,
	   
	   input wire ADC_VAREFSEL,

	   input wire [3:0] ADC0 ,           //   4 direct analog inputs to the ADC-0
      input wire [3:0] ADC1 ,           //   4 direct analog inputs to the ADC-1
      input wire [3:0] ADC2 ,           //   4 direct analog inputs to the ADC-2
      input wire [13:0] ADC_F060,           // 14 direct analog inputs specific to F060

	   input wire [11:0] DEN_ADC,        //    12 data enable signals for 12 direct analog inputs at ADC-0,1,2
	   
	   input wire       ADC0_PWRDWN,      //   Power down signal for ADC-0
	   input wire       ADC0_ADCRESET,    //   Reset signal for ADC-0
	   input wire       ADC0_SYSCLK,      //   Clock signal for ADC-0
	   input wire [4:0] ADC0_CHNUMBER,    //   Channel number select signal for ADC-0
	   input wire [3:0] ADC0_MODE,        //   Mode select signal for ADC-0
	   input wire [7:0] ADC0_TVC,         //   TVC signal for ADC-0
	   input wire [7:0] ADC0_STC,         //   STC signal for ADC-0
	   input wire       ADC0_ADCSTART,    //   Start signal for ADC-0

	   input wire       ADC1_PWRDWN,      //   Power down signal for ADC-1
      input wire       ADC1_ADCRESET,    //   Reset signal for ADC-1
      input wire       ADC1_SYSCLK,      //   Clock signal for ADC-1
      input wire [4:0] ADC1_CHNUMBER,    //   Channel number select signal for ADC-1
      input wire [3:0] ADC1_MODE,        //   Mode select signal for ADC-1
      input wire [7:0] ADC1_TVC,         //   TVC signal for ADC-1
      input wire [7:0] ADC1_STC,         //   STC signal for ADC-1
      input wire       ADC1_ADCSTART,    //   Start signal for ADC-1

	   input wire       ADC2_PWRDWN,      //   Power down signal for ADC-2
      input wire       ADC2_ADCRESET,    //   Reset signal for ADC-2
      input wire       ADC2_SYSCLK,      //   Clock signal for ADC-2
      input wire [4:0] ADC2_CHNUMBER,    //   Channel number select signal for ADC-2
      input wire [3:0] ADC2_MODE,        //   Mode select signal for ADC-2
      input wire [7:0] ADC2_TVC,         //   TVC signal for ADC-2
      input wire [7:0] ADC2_STC,         //   STC signal for ADC-2
      input wire       ADC2_ADCSTART,    //   Start signal for ADC-2

      input wire       ACB_RST,          //   Reset signal for ACB bus
	   input wire       ACB_WEN,          //   Write enable signal for ACB bus
	   input wire [7:0] ACB_ADDR,         //   Address signal for ACB bus
	   input wire [7:0] ACB_WDATA,        //   Data In signal for ACB bus
	   
	   output  wire      ADC_VAREFOUT,
	   
	   output wire [7:0]  ACB_RDATA,       //   Data Out signal for ACB bus

	   output wire        ADC0_BUSY,      //   Busy signal from ADC-0
	   output wire        ADC0_CALIBRATE, //   Calibrate signal from ADC-0
	   output wire        ADC0_DATAVALID, //   Data valid signal from ADC-0
	   output wire        ADC0_SAMPLE,    //   Sampling signal from ADC-0
	   output wire [11:0] ADC0_RESULT,    //   Converted digital output signal from ADC-0 for the analog input 

	   output wire        ADC1_BUSY,      //   Busy signal from ADC-1
      output wire        ADC1_CALIBRATE, //   Calibrate signal from ADC-1
      output wire        ADC1_DATAVALID, //   Data valid signal from ADC-1
      output wire        ADC1_SAMPLE,    //   Sampling signal from ADC-1
      output wire [11:0] ADC1_RESULT,    //   Converted digital output signal from ADC-1 for the analog input

	   output wire        ADC2_BUSY,      //   Busy signal from ADC-2
      output wire        ADC2_CALIBRATE, //   Calibrate signal from ADC-2
      output wire        ADC2_DATAVALID, //   Data valid signal from ADC-2
      output wire        ADC2_SAMPLE,    //   Sampling signal from ADC-2
      output wire [11:0] ADC2_RESULT,    //   Converted digital output signal from ADC-2 for the analog input
      
      output wire        DACOUT0,        //   Converted Analog output of DAC-0
      output wire        DACOUT1,        //   Converted Analog output of DAC-1
      output wire        DACOUT2,        //   Converted Analog output of DAC-2
      
      output wire [11:0] DIG_ADC, 

      input wire  [2:0]  OBD_DIN,        //   Digital data input signals for DAC-0, DAC-1, and DAC-2
      input wire  [2:0]  OBD_CLKIN,      //   Clock signals for DAC-0, DAC-1, and DAC-2
      input wire  [2:0]  OBD_ENABLE,     //   Data enable signals for DAC-0, DAC-1, and DAC-2

      
      output wire [11:0] COMPARATOR

   );
  
  parameter WIDTH              = 32;
   parameter [5:0] DAC_RESOLUTION = 6'b0;
  
  // Used to turn off warnings messages.
  // Default = ON.  Set to 0 to turn them OFF.
  parameter WARNING_MSGS_ON    = 1; 

  parameter FAST_ADC_CONV_SIM  = 0;
  parameter ANALOG_QUAD_NUM    = 6 ; //For Fs-200 we have 4 analog quads, for Fs-400 -- 6 Quads
  parameter ADC_NUM            = 1 ; //Number of ADCs in the system
  parameter NUM_ADC_IN         = 5 ; //Number of direct analog inputs to each ADC
  parameter VAREF_INT          = 2.56 ;

//  parameter MEMORYFILE         = "";
//---------------------------------------------------------------------------------------------------------
  wire          VAREFSEL;
  wire   [2:0]  at_gnd;

  wire          VAREFSEL_ipd;
  wire          VAREFSEL_lat;
  wire          VAREFSEL_lat0, VAREFSEL_lat1, VAREFSEL_lat2 ;
  real          va_ref_ext_0,va_ref_ext_1,va_ref_ext_2;
  real 	        va_ref_real_0,va_ref_real_1,va_ref_real_2, gnd_ref_real, va_ref_real_out;

  wire signed [2 * WIDTH-1:0]    VA_REF_VECTOR_0,VA_REF_VECTOR_1,VA_REF_VECTOR_2, GND_REF_VECTOR;

  //wire                 VAREF_in ;
  wire                 VAREF_out ; 
  wire signed [63:0]   VAREF_IN[2:0] ; 
  
  wire [25:0]    adc_direct_input;

  //reg  [63:0] ADC_IN_VECTOR  [0: (ADC_NUM*NUM_ADC_IN)-1] ;
  reg  [63:0] ADC_IN_VECTOR  [0: 25] ;
  
  wire signed [63:0] ADC0_IN_0 ;
  wire signed [63:0] ADC0_IN_1 ;
  wire signed [63:0] ADC0_IN_2 ;
  wire signed [63:0] ADC0_IN_3 ;
  wire signed [63:0] ADC0_IN_4 ;

  wire signed [63:0] ADC1_IN_0 ;
  wire signed [63:0] ADC1_IN_1 ;
  wire signed [63:0] ADC1_IN_2 ;
  wire signed [63:0] ADC1_IN_3 ;
  wire signed [63:0] ADC1_IN_4 ;

  wire signed [63:0] ADC2_IN_0 ;
  wire signed [63:0] ADC2_IN_1 ;
  wire signed [63:0] ADC2_IN_2 ; 
  wire signed [63:0] ADC2_IN_3 ;
  wire signed [63:0] ADC2_IN_4 ;
  
  wire signed [63:0] ADC_F060_IN_0;
  wire signed [63:0] ADC_F060_IN_1;
  wire signed [63:0] ADC_F060_IN_2;
  wire signed [63:0] ADC_F060_IN_3;
  wire signed [63:0] ADC_F060_IN_4;
  wire signed [63:0] ADC_F060_IN_5;
  wire signed [63:0] ADC_F060_IN_6;
  wire signed [63:0] ADC_F060_IN_7;
  wire signed [63:0] ADC_F060_IN_8;
  wire signed [63:0] ADC_F060_IN_9;
  wire signed [63:0] ADC_F060_IN_10;
  wire signed [63:0] ADC_F060_IN_11;
  wire signed [63:0] ADC_F060_IN_12;
  wire signed [63:0] ADC_F060_IN_13;
  
  
//declarations of intermodule ports
  wire  [2:0]  QUAD_NUM;
  wire  [2:0]  QUAD_NUM_OP ; 
  wire  [15:0] AV1_WORD;
  wire  [15:0] AV2_WORD;
  wire  [15:0] AC_WORD;
  wire  [15:0] AT_WORD;

  reg [63:0] AV1_OUT_reg [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AV2_OUT_reg [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AC_OUT_reg  [0 : ANALOG_QUAD_NUM-1 ] ;
  reg [63:0] AT_OUT_reg  [0 : ANALOG_QUAD_NUM-1 ] ;
  
  wire[63:0] DAC_VECTOR  [0 : ADC_NUM-1];

  reg [63:0] AV1_OUT  ;
  reg [63:0] AV2_OUT  ;
  reg [63:0] AC_OUT   ;
  reg [63:0] AT_OUT   ;
  
  wire [3:0] AV1_CONFIG [0: ANALOG_QUAD_NUM-1];
  wire [3:0] AV2_CONFIG [0: ANALOG_QUAD_NUM-1];
  wire [7:0] AC_CONFIG  [0: ANALOG_QUAD_NUM-1];
  wire [7:0] AT_CONFIG  [0: ANALOG_QUAD_NUM-1];
  wire [1:0] DAC_CONFIG [0: ANALOG_QUAD_NUM/2-1];
  
  wire [1:0] AQ0_DAC_MUX_SEL, AQ1_DAC_MUX_SEL, AQ2_DAC_MUX_SEL, AQ3_DAC_MUX_SEL, AQ4_DAC_MUX_SEL, AQ5_DAC_MUX_SEL;
        
  reg ACB_WEN_reg ;
  reg load_reg ;

  reg [7:0] ACB_ADDR_reg, ACB_WDATA_reg ;
  reg [7:0] ACB_LATCH [0:(8*ANALOG_QUAD_NUM-1)] ;  //6quads , 8bytes/quad
  
  wire [1:0] DAC_MUX_SELECT[0 : ANALOG_QUAD_NUM-1];

  wire [ANALOG_QUAD_NUM-1 : 0] VAREFDAC;

  wire [63:0] AV1_OUT_tmp ;
  wire [63:0] AV2_OUT_tmp ;
  wire [63:0] AC_OUT_tmp ;
  wire [63:0] AT_OUT_tmp ;
  
  //reg [63:0] MUX_OUT_reg [0 : ADC_NUM-1] ; 
  wire [63:0] MUX_OUT_reg [0 : ADC_NUM-1] ; 

  //wire [63:0] MUXOUT ;

  reg [4:0]  CH_NUM  [0 : ADC_NUM-1] ;
  integer    j, k, index ;
  wire [2:0] DAC_OUT;
  
  
  // IN F060 only ADC[25:22] are LVTTL
  // and U116 (DIG_ADC[0], ADC0[0], DEN_ADC[0]);
  // and U117 (DIG_ADC[1], ADC0[1], DEN_ADC[1]);
  // and U118 (DIG_ADC[2], ADC0[2], DEN_ADC[2]);
  // and U119 (DIG_ADC[3], ADC0[3], DEN_ADC[3]);
  and U116 (DIG_ADC[0], ADC_F060[10], DEN_ADC[0]);
  and U117 (DIG_ADC[1], ADC_F060[11], DEN_ADC[1]);
  and U118 (DIG_ADC[2], ADC_F060[12], DEN_ADC[2]);
  and U119 (DIG_ADC[3], ADC_F060[13], DEN_ADC[3]);
  
  and U120 (DIG_ADC[4], ADC1[0], DEN_ADC[4]);
  and U122 (DIG_ADC[5], ADC1[1], DEN_ADC[5]);
  and U123 (DIG_ADC[6], ADC1[2], DEN_ADC[6]);
  and U124 (DIG_ADC[7], ADC1[3], DEN_ADC[7]);
  
  and U125 (DIG_ADC[8], ADC2[0], DEN_ADC[8]);
  and U126 (DIG_ADC[9], ADC2[1], DEN_ADC[9]);
  and U127 (DIG_ADC[10], ADC2[2], DEN_ADC[10]);
  and U128 (DIG_ADC[11], ADC2[3], DEN_ADC[11]);
  
  
 
  assign  VAREFSEL     =  ADC_VAREFSEL;
  assign  VAREFSEL_lat = VAREFSEL_lat0;
  assign  at_gnd       = { ATGND_45, ATGND_23, ATGND_01 };  
  
  assign  adc_direct_input = {ADC_F060[13],ADC_F060[12],
                              ADC_F060[11],ADC_F060[10],ADC_F060[9],ADC_F060[8],
                              ADC_F060[7],ADC_F060[6],ADC_F060[5],ADC_F060[4],
                              ADC_F060[3],ADC_F060[2],ADC_F060[1],ADC_F060[0],
                              ADC2[3],ADC2[2],ADC2[1],ADC2[0],
                              ADC1[3],ADC1[2],ADC1[1],ADC1[0],
                              ADC0[3],ADC0[2],ADC0[1],ADC0[0]};

  //buf U106 (VAREFSEL_ipd, VAREFSEL);

  // "Deserialize" / Read analog inputs for all quads
  // NOTE: Inverted version of VAREFSEL is being used becoz the enable input
  // of the below read_analog_io module is active low.
  
  read_analog_io read_analog_input_VAREF_0    ( VAREF[0] , !VAREFSEL   , VA_REF_VECTOR_0  );
  read_analog_io read_analog_input_VAREF_1    ( VAREF[1] , !VAREFSEL   , VA_REF_VECTOR_1  );
  read_analog_io read_analog_input_VAREF_2    ( VAREF[2] , !VAREFSEL   , VA_REF_VECTOR_2  );
  
  
  read_analog_io read_analog_input_GNDREF   ( GNDREF   , 1'b0        , GND_REF_VECTOR );

  read_analog_io read_analog_input_adc01    ( adc_direct_input[0]  , 1'b0        , ADC0_IN_0 );
  read_analog_io read_analog_input_adc02    ( adc_direct_input[1]  , 1'b0        , ADC0_IN_1 );
  read_analog_io read_analog_input_adc03    ( adc_direct_input[2]  , 1'b0        , ADC0_IN_2 );
  read_analog_io read_analog_input_adc04    ( adc_direct_input[3]  , 1'b0        , ADC0_IN_3 );
  //read_analog_io read_analog_input_adc05    ( ADC0[4]  , 1'b0        , ADC0_IN_4 );

  read_analog_io read_analog_input_adc11    ( adc_direct_input[4]  , 1'b0        , ADC1_IN_0 );
  read_analog_io read_analog_input_adc12    ( adc_direct_input[5]  , 1'b0        , ADC1_IN_1 );
  read_analog_io read_analog_input_adc13    ( adc_direct_input[6]  , 1'b0        , ADC1_IN_2 );
  read_analog_io read_analog_input_adc14    ( adc_direct_input[7]  , 1'b0        , ADC1_IN_3 );
  //read_analog_io read_analog_input_adc15    ( ADC1[4]  , 1'b0        , ADC1_IN_4 );

  read_analog_io read_analog_input_adc21    ( adc_direct_input[8]  , 1'b0        , ADC2_IN_0 );
  read_analog_io read_analog_input_adc22    ( adc_direct_input[9]  , 1'b0        , ADC2_IN_1 );
  read_analog_io read_analog_input_adc23    ( adc_direct_input[10]  , 1'b0        , ADC2_IN_2 );
  read_analog_io read_analog_input_adc24    ( adc_direct_input[11]  , 1'b0        , ADC2_IN_3 );
  //read_analog_io read_analog_input_adc25    ( ADC2[4]  , 1'b0        , ADC2_IN_4 );
  
  read_analog_io read_analog_input_adc0_F060 ( adc_direct_input[12]  , 1'b0        , ADC_F060_IN_0 );
  read_analog_io read_analog_input_adc1_F060 ( adc_direct_input[13]  , 1'b0        , ADC_F060_IN_1 );
  read_analog_io read_analog_input_adc2_F060 ( adc_direct_input[14]  , 1'b0        , ADC_F060_IN_2 );
  read_analog_io read_analog_input_adc3_F060 ( adc_direct_input[15]  , 1'b0        , ADC_F060_IN_3 );
  read_analog_io read_analog_input_adc4_F060 ( adc_direct_input[16]  , 1'b0        , ADC_F060_IN_4 );
  read_analog_io read_analog_input_adc5_F060 ( adc_direct_input[17]  , 1'b0        , ADC_F060_IN_5 );
  read_analog_io read_analog_input_adc6_F060 ( adc_direct_input[18]  , 1'b0        , ADC_F060_IN_6 );
  read_analog_io read_analog_input_adc7_F060 ( adc_direct_input[19]  , 1'b0        , ADC_F060_IN_7 );
  read_analog_io read_analog_input_adc8_F060 ( adc_direct_input[20]  , 1'b0        , ADC_F060_IN_8 );
  read_analog_io read_analog_input_adc9_F060 ( adc_direct_input[21]  , 1'b0        , ADC_F060_IN_9 );
  read_analog_io read_analog_input_adc10_F060( adc_direct_input[22]  , 1'b0        , ADC_F060_IN_10 );
  read_analog_io read_analog_input_adc11_F060( adc_direct_input[23]  , 1'b0        , ADC_F060_IN_11 );
  read_analog_io read_analog_input_adc12_F060( adc_direct_input[24]  , 1'b0        , ADC_F060_IN_12 );
  read_analog_io read_analog_input_adc13_F060( adc_direct_input[25]  , 1'b0        , ADC_F060_IN_13 );
  

  drive_varef_out drive_analog_output_VAREF ( $realtobits( VAREF_INT ), !VAREFSEL , ADC_VAREFOUT );
  
  read_analog_io read_analog_input_dac0    ( DAC_OUT[0]  , 1'b0        , DAC_VECTOR[0] );
  //read_analog_io read_analog_input_dac1    ( DAC_OUT[1]  , 1'b0        , DAC_VECTOR[1] );
  //read_analog_io read_analog_input_dac2    ( DAC_OUT[2]  , 1'b0        , DAC_VECTOR[2] );

  always @ (*)
  begin  //{
    ADC_IN_VECTOR[0]  = ADC0_IN_0 ;
    ADC_IN_VECTOR[1]  = ADC0_IN_1 ;
    ADC_IN_VECTOR[2]  = ADC0_IN_2 ;
    ADC_IN_VECTOR[3]  = ADC0_IN_3 ;
    //ADC_IN_VECTOR[4]  = ADC0_IN_4 ;
    ADC_IN_VECTOR[4]  = ADC1_IN_0 ;
    ADC_IN_VECTOR[5]  = ADC1_IN_1 ;
    ADC_IN_VECTOR[6]  = ADC1_IN_2 ;
    ADC_IN_VECTOR[7]  = ADC1_IN_3 ;
    //ADC_IN_VECTOR[9]  = ADC1_IN_4 ;
    ADC_IN_VECTOR[8]  = ADC2_IN_0 ;
    ADC_IN_VECTOR[9]  = ADC2_IN_1 ;
    ADC_IN_VECTOR[10] = ADC2_IN_2 ;
    ADC_IN_VECTOR[11] = ADC2_IN_3 ;
    //ADC_IN_VECTOR[14] = ADC2_IN_4 ;
    
    ADC_IN_VECTOR[12] = ADC_F060_IN_0 ;
    ADC_IN_VECTOR[13] = ADC_F060_IN_1 ;
    ADC_IN_VECTOR[14] = ADC_F060_IN_2 ;
    ADC_IN_VECTOR[15] = ADC_F060_IN_3 ;
    ADC_IN_VECTOR[16] = ADC_F060_IN_4 ;
    ADC_IN_VECTOR[17] = ADC_F060_IN_5 ;
    ADC_IN_VECTOR[18] = ADC_F060_IN_6 ;
    ADC_IN_VECTOR[19] = ADC_F060_IN_7 ;
    ADC_IN_VECTOR[20] = ADC_F060_IN_8 ;
    ADC_IN_VECTOR[21] = ADC_F060_IN_9 ;
    ADC_IN_VECTOR[22] = ADC_F060_IN_10 ;
    ADC_IN_VECTOR[23] = ADC_F060_IN_11 ;
    ADC_IN_VECTOR[24] = ADC_F060_IN_12 ;
    ADC_IN_VECTOR[25] = ADC_F060_IN_13 ;
    
  end    //}

  always @ ( VA_REF_VECTOR_0  ) va_ref_ext_0   <= $bitstoreal ( VA_REF_VECTOR_0  );
  always @ ( VA_REF_VECTOR_1  ) va_ref_ext_1   <= $bitstoreal ( VA_REF_VECTOR_1  );
  always @ ( VA_REF_VECTOR_2  ) va_ref_ext_2   <= $bitstoreal ( VA_REF_VECTOR_2  );

  always @ ( GND_REF_VECTOR ) gnd_ref_real <= $bitstoreal ( GND_REF_VECTOR );

  // use latched value of VAREFLSEL for selecting source of internal va_ref_real input to ADC
  always @ ( VAREFSEL_lat, va_ref_ext_0,va_ref_ext_1,va_ref_ext_2 )
  begin
    if ( VAREFSEL_lat == 1'b1 )
    begin
      va_ref_real_0 <= va_ref_ext_0;
      va_ref_real_1 <= va_ref_ext_1;
      va_ref_real_2 <= va_ref_ext_2;
    end
    else if ( VAREFSEL_lat == 1'b0 )
    begin
      va_ref_real_0 <= VAREF_INT;   //VAREF_INT holds internal ref voltage 
      va_ref_real_1 <= VAREF_INT;   //VAREF_INT holds internal ref voltage
      va_ref_real_2 <= VAREF_INT;   //VAREF_INT holds internal ref voltage
    end
    else if ( VAREFSEL_lat === 1'bx ) begin
      if ( WARNING_MSGS_ON == 1 ) begin
        $display ( " Error : VAREFSEL is unknown " );
        $display ( " Time: %0.1f Instance: %m ", $realtime );
      end
    end
  end

    // Internal and external VAREF handling
   /* assign VAREF_in  = ( VAREFSEL == 1'b1 ) ? VAREF     : 1'bz;
    assign VAREF     = ( VAREFSEL == 1'b0 ) ? VAREF_out : 1'bz;*/
    assign VAREF_IN[0]  = $realtobits (va_ref_real_0) ;
    assign VAREF_IN[1]  = $realtobits (va_ref_real_1) ;
    assign VAREF_IN[2]  = $realtobits (va_ref_real_2) ;
  
//---------------------------------------------------------------------------------------------------------
  genvar        i;


acb_96_bit acb(
             .ACB_RST        (ACB_RST      ),
             .ACB_WEN        (ACB_WEN      ),
             .ACB_ADDR       (ACB_ADDR     ),
             .ACB_WDATA      (ACB_WDATA    ),
             .ACB_RDATA      (ACB_RDATA    ),
             .AQO_AV1_CONFIG (AV1_CONFIG[0]),
             .AQO_AV2_CONFIG (AV2_CONFIG[0]),
             .AQO_AC_CONFIG  (AC_CONFIG[0] ),
             .AQO_AT_CONFIG  (AT_CONFIG[0] ),
             .AQ0_DAC_MUX_SEL(AQ0_DAC_MUX_SEL),
             .AQ1_AV1_CONFIG (AV1_CONFIG[1]),
             .AQ1_AV2_CONFIG (AV2_CONFIG[1]),
             .AQ1_AC_CONFIG  (AC_CONFIG[1] ),
             .AQ1_AT_CONFIG  (AT_CONFIG[1] ),
             .AQ1_DAC_MUX_SEL(AQ1_DAC_MUX_SEL),
             .AQ2_AV1_CONFIG (AV1_CONFIG[2]),
             .AQ2_AV2_CONFIG (AV2_CONFIG[2]),
             .AQ2_AC_CONFIG  (AC_CONFIG[2] ),
             .AQ2_AT_CONFIG  (AT_CONFIG[2] ),
             .AQ2_DAC_MUX_SEL(AQ2_DAC_MUX_SEL),
             .AQ3_AV1_CONFIG (AV1_CONFIG[3]),
             .AQ3_AV2_CONFIG (AV2_CONFIG[3]),
             .AQ3_AC_CONFIG  (AC_CONFIG[3] ),
             .AQ3_AT_CONFIG  (AT_CONFIG[3] ),
             .AQ3_DAC_MUX_SEL(AQ3_DAC_MUX_SEL),
             .AQ4_AV1_CONFIG (AV1_CONFIG[4]),
             .AQ4_AV2_CONFIG (AV2_CONFIG[4]),
             .AQ4_AC_CONFIG  (AC_CONFIG[4] ),
             .AQ4_AT_CONFIG  (AT_CONFIG[4] ),
             .AQ4_DAC_MUX_SEL(AQ4_DAC_MUX_SEL),
             .AQ5_AV1_CONFIG (AV1_CONFIG[5]),
             .AQ5_AV2_CONFIG (AV2_CONFIG[5]),
             .AQ5_AC_CONFIG  (AC_CONFIG[5] ),
             .AQ5_AT_CONFIG  (AT_CONFIG[5] ),
             .AQ5_DAC_MUX_SEL(AQ5_DAC_MUX_SEL),
	     .DAC0_CONFIG    (DAC_CONFIG[0]),
	     .DAC1_CONFIG    (DAC_CONFIG[1]),
	     .DAC2_CONFIG    (DAC_CONFIG[2])
         );

//---------------------------------------------------------------------------------------------------------
//Instantiation of Analog Quad Block
generate 
 for (i=0 ; i<ANALOG_QUAD_NUM ; i=i+1)
  begin:aq_loop //{                  //
   wire  [63:0] av1_out, av2_out, ac_out, at_out ;
   analog_quad aq(
	            // inputs to analog quad
		                .VAREF_IN    (VAREF_IN[i/2]),
                    // varef from DAC, alternate input for comparator in AC & AT pads
                    //.VAREF_DAC   (DAC_OUT[i/2]),
                      .VAREF_DAC   (VAREFDAC[i]),
	                   .AV1_IN      (AV1[i]      ),
                      .AV2_IN      (AV2[i]      ),
		                .AC_IN       (AC[i]       ),
		                .AT_IN       (AT[i]       ),
		                .AT_GND      (at_gnd[i/2] ),
		                .DIRECT_ANALOG0 (adc_direct_input[(i*2)]),
		                .DIRECT_ANALOG1 (adc_direct_input[(i*2)+1]),
		    // direct digital input related signals
		                //.AV1_DIN     (AV1_DOUT[i] ),   
		                //.AV1_DEN     (AV1_DEN[i]  ),    
		                //.AV2_DIN     (AV2_DOUT[i] ),  
		                //.AV2_DEN     (AV2_DEN[i]  ), 
		                //.AC_DIN      (AC_DOUT[i]  ),
		                //.AC_DEN      (AC_DEN[i]   ),
		                //.AT_DIN      (AT_DOUT[i]  ),
		                //.AT_DEN      (AT_DEN[i]   ),
		    // outputs from analog quad go to analog mux
                      .AV1_OUT     ( ),
	                   .AV2_OUT     ( ),
                      .AC_OUT      ( ),
                      .AT_OUT      ( ),
		    // analog config latch bits, 2 bytes 
	                   //.AV1_WORD    ( {ACB_LATCH[(i*8) + 1],ACB_LATCH[(i*8) + 0]} ),
                      //.AV2_WORD    ( {ACB_LATCH[(i*8) + 3],ACB_LATCH[(i*8) + 2]} ),
                      //.AC_WORD     ( {ACB_LATCH[(i*8) + 6],ACB_LATCH[(i*8) + 4]} ),
		                //.AT_WORD     ( {ACB_LATCH[(i*8) + 7],ACB_LATCH[(i*8) + 5]} ),
		                .AV1_CONFIG  (AV1_CONFIG[i]),
		                .AV2_CONFIG  (AV2_CONFIG[i]),
		                .AC_CONFIG   (AC_CONFIG[i] ),
		                .AT_CONFIG   (AT_CONFIG[i] ),
		                
                    // comparator output
                      .AC_COMP_OUT (COMPARATOR[i*2]  ),
                      .AT_COMP_OUT (COMPARATOR[i*2+1])
                  ) ;	  
  end	//}  
endgenerate 	 
//---------------------------------------------------------------------------------------------------------

//heirarchially accessing the generated quad modules' signals
always @ (*)
begin //{
AV1_OUT_reg[0] = aq_loop[0].aq.AV1_OUT; 
AV2_OUT_reg[0] = aq_loop[0].aq.AV2_OUT;
AC_OUT_reg[0]  = aq_loop[0].aq.AC_OUT;
AT_OUT_reg[0]  = aq_loop[0].aq.AT_OUT;
// AV1_OUT_reg[1] = aq_loop[1].aq.AV1_OUT; 
// AV2_OUT_reg[1] = aq_loop[1].aq.AV2_OUT;
// AC_OUT_reg[1]  = aq_loop[1].aq.AC_OUT;
// AT_OUT_reg[1]  = aq_loop[1].aq.AT_OUT;
// AV1_OUT_reg[2] = aq_loop[2].aq.AV1_OUT; 
// AV2_OUT_reg[2] = aq_loop[2].aq.AV2_OUT;
// AC_OUT_reg[2]  = aq_loop[2].aq.AC_OUT;
// AT_OUT_reg[2]  = aq_loop[2].aq.AT_OUT;
// AV1_OUT_reg[3] = aq_loop[3].aq.AV1_OUT; 
// AV2_OUT_reg[3] = aq_loop[3].aq.AV2_OUT;
// AC_OUT_reg[3]  = aq_loop[3].aq.AC_OUT;
// AT_OUT_reg[3]  = aq_loop[3].aq.AT_OUT;
// AV1_OUT_reg[4] = aq_loop[4].aq.AV1_OUT; 
// AV2_OUT_reg[4] = aq_loop[4].aq.AV2_OUT;
// AC_OUT_reg[4]  = aq_loop[4].aq.AC_OUT;
// AT_OUT_reg[4]  = aq_loop[4].aq.AT_OUT;
// AV1_OUT_reg[5] = aq_loop[5].aq.AV1_OUT; 
// AV2_OUT_reg[5] = aq_loop[5].aq.AV2_OUT;
// AC_OUT_reg[5]  = aq_loop[5].aq.AC_OUT;
// AT_OUT_reg[5]  = aq_loop[5].aq.AT_OUT;
end   //}

always @ (*)
begin //{
  CH_NUM[0] =  ADC0_CHNUMBER ;
  CH_NUM[1] =  ADC1_CHNUMBER ;
  CH_NUM[2] =  ADC2_CHNUMBER ;

end   //}
//---------------------------------------------------------------------------------------------------------
//Instantiation of Analog mux block
generate //{ 
for (i=0 ; i < ADC_NUM ; i=i+1)
begin:mux_loop //{
analog_mux_F060 a_mux1(
                      .CHNUMBER_I        (CH_NUM[i]              ),
                      .AV01              (AV1_OUT_reg[i*2]       ),
                      .AV02              (AV2_OUT_reg[i*2]       ),
                      .AC0               (AC_OUT_reg[i*2]        ),
                      .AT0               (AT_OUT_reg[i*2]        ),
                      .ADC_IN_VECTOR_0   (ADC_IN_VECTOR[i*4]     ),	                
                      .ADC_IN_VECTOR_1   (ADC_IN_VECTOR[i*4 + 1] ),
                      .ADC_IN_VECTOR_2   (ADC_IN_VECTOR[i*4 + 2] ),
                      .ADC_IN_VECTOR_3   (ADC_IN_VECTOR[i*4 + 3] ),
                      
                      .ADC_IN_VECTOR_4   (ADC_IN_VECTOR[i*4 + 4] ),
                      .ADC_IN_VECTOR_5   (ADC_IN_VECTOR[i*4 + 5] ),
                      .ADC_IN_VECTOR_6   (ADC_IN_VECTOR[i*4 + 6] ),
                      .ADC_IN_VECTOR_7   (ADC_IN_VECTOR[i*4 + 7] ),
                      .ADC_IN_VECTOR_8   (ADC_IN_VECTOR[i*4 + 8] ),
                      .ADC_IN_VECTOR_9   (ADC_IN_VECTOR[i*4 + 9] ),
                      .ADC_IN_VECTOR_10  (ADC_IN_VECTOR[i*4 + 10] ),
                      .ADC_IN_VECTOR_11  (ADC_IN_VECTOR[i*4 + 11] ),
                      .ADC_IN_VECTOR_12  (ADC_IN_VECTOR[i*4 + 12] ),
                      .ADC_IN_VECTOR_13  (ADC_IN_VECTOR[i*4 + 13] ),
                      .ADC_IN_VECTOR_14  (ADC_IN_VECTOR[i*4 + 14] ),
                      .ADC_IN_VECTOR_15  (ADC_IN_VECTOR[i*4 + 15] ),
                      .ADC_IN_VECTOR_16  (ADC_IN_VECTOR[i*4 + 16] ),
                      .ADC_IN_VECTOR_17  (ADC_IN_VECTOR[i*4 + 17] ),
                      .ADC_IN_VECTOR_18  (ADC_IN_VECTOR[i*4 + 18] ),
                      .ADC_IN_VECTOR_19  (ADC_IN_VECTOR[i*4 + 19] ),
                      .ADC_IN_VECTOR_20  (ADC_IN_VECTOR[i*4 + 20] ),
                      .ADC_IN_VECTOR_21  (ADC_IN_VECTOR[i*4 + 21] ),
                      .ADC_IN_VECTOR_22  (ADC_IN_VECTOR[i*4 + 22] ),
                      .ADC_IN_VECTOR_23  (ADC_IN_VECTOR[i*4 + 23] ),
                      .ADC_IN_VECTOR_24  (ADC_IN_VECTOR[i*4 + 24] ),
                      .ADC_IN_VECTOR_25  (ADC_IN_VECTOR[i*4 + 25] ),
                      
                      
                      .DAC_VECTOR        (DAC_VECTOR[i]          ),
                      .MUXOUT            (MUX_OUT_reg[i]         )
                    ) ;  
end  //}
endgenerate //}
			
//---------------------------------------------------------------------------------------------------------
//heirarchially accessing the generated quad modules' signals
//always @ (*)
//begin //{
//  MUX_OUT_reg[0] = mux_loop[0].a_mux1.MUXOUT   ;
//  MUX_OUT_reg[1] = mux_loop[1].a_mux1.MUXOUT   ;
//  MUX_OUT_reg[2] = mux_loop[2].a_mux1.MUXOUT   ;
//end   //}

//---------------------------------------------------------------------------------------------------------
//Instantiation of ADC
adc u_adc0(
	 .VAREF_INPUT  (VAREF_IN[0]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[0]),
	 .PWRDWN       (ADC0_PWRDWN   ),
	 .ADCRESET     (ADC0_ADCRESET ),
    .SYSCLK       (ADC0_SYSCLK   ),	 
	 .CHNUMBER     (ADC0_CHNUMBER ),
    .MODE         (ADC0_MODE     ),
    .TVC          (ADC0_TVC      ),
	 .STC          (ADC0_STC      ),
    .ADCSTART     (ADC0_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat0 ),
	 .BUSY         (ADC0_BUSY     ),
	 .CALIBRATE    (ADC0_CALIBRATE),
	 .DATAVALID    (ADC0_DATAVALID),
	 .SAMPLE       (ADC0_SAMPLE   ), 
	 .RESULT       (ADC0_RESULT   )   
	 );

/* adc u_adc1(
	 .VAREF_INPUT  (VAREF_IN[1]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[1]),
	 .PWRDWN       (ADC1_PWRDWN   ),
	 .ADCRESET     (ADC1_ADCRESET ),
    .SYSCLK       (ADC1_SYSCLK   ),	 
	 .CHNUMBER     (ADC1_CHNUMBER ),
    .MODE         (ADC1_MODE     ),
    .TVC          (ADC1_TVC      ),
	 .STC          (ADC1_STC      ),
    .ADCSTART     (ADC1_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat1 ),
	 .BUSY         (ADC1_BUSY     ),
	 .CALIBRATE    (ADC1_CALIBRATE),
	 .DATAVALID    (ADC1_DATAVALID),
	 .SAMPLE       (ADC1_SAMPLE   ), 
	 .RESULT       (ADC1_RESULT   )   
	 );

adc u_adc2(
	 .VAREF_INPUT  (VAREF_IN[2]   ),
	 .VAREFSEL     (VAREFSEL      ),
	 .A_IN         (MUX_OUT_reg[2]),
	 .PWRDWN       (ADC2_PWRDWN   ),
	 .ADCRESET     (ADC2_ADCRESET ),
    .SYSCLK       (ADC2_SYSCLK   ),	 
	 .CHNUMBER     (ADC2_CHNUMBER ),
    .MODE         (ADC2_MODE     ),
    .TVC          (ADC2_TVC      ),
	 .STC          (ADC2_STC      ),
    .ADCSTART     (ADC2_ADCSTART ),
	 .VAREFSEL_lat (VAREFSEL_lat2 ),
	 .BUSY         (ADC2_BUSY     ),
	 .CALIBRATE    (ADC2_CALIBRATE),
	 .DATAVALID    (ADC2_DATAVALID),
	 .SAMPLE       (ADC2_SAMPLE   ), 
	 .RESULT       (ADC2_RESULT   )   
	 ); */

//---------------------------------------------------------------------------------------------------------
// Analog Configuration Bus (ACB) Handling
// ACB supports 3 operations on the analog configuration latches that
// 1. Reset - ACB_RST is active when at logic "1"
// 2. Write - Falling edge of ACB_WEN closes the ACB latches (latch is open when ACB_WEN is at logic "1"
// 3. Read  - Read is controlled by input address ACB_ADDR; data from selected latch is driven on ACB_RDATA
//---------------------------------------------------------------------------------------------------------

/*always @ ( ACB_RST or ACB_ADDR or ACB_WEN )
begin
  // reset all the configuration latches
  if ( ACB_RST == 1'b1 ) begin
    for ( index=0; index<(8*ANALOG_QUAD_NUM); index=index+1 ) begin
      ACB_LATCH[index] = 8'b0;
    end
  end
  // write to latch
  else if ( ACB_RST == 1'b0 && ACB_WEN == 1'b0 ) begin
    if ( (8'd0 <= ACB_ADDR) && (ACB_ADDR < (8*ANALOG_QUAD_NUM)) ) begin
      ACB_LATCH[ACB_ADDR] = ACB_WDATA;
    end
    else begin
      if (WARNING_MSGS_ON) begin
        $display ( " ERROR: ACB Address for Write is not in the ACB address range " ) ;
        $display ( " Time: %0.1f Instance: %m ", $realtime );
      end
    end
  end
end

// read from latch is controlled only by input address
always @ ( ACB_ADDR or ACB_WEN )
begin
  if ( (8'd0 <= ACB_ADDR) && (ACB_ADDR < (8*ANALOG_QUAD_NUM)) ) begin
    ACB_RDATA = ACB_LATCH[ACB_ADDR] ;
  end
  else begin
    if (WARNING_MSGS_ON) begin
      $display ( " ERROR: ACB Address for Read is not in the ACB address range " ) ;
      $display ( " Time: %0.1f Instance: %m ", $realtime );
    end
  end
end*/


genvar obd_index,obd_mux_index;

generate
for (obd_mux_index = 0; obd_mux_index<ANALOG_QUAD_NUM ; obd_mux_index = obd_mux_index+1)
begin: obd_mux_loop
obd_mux u_obd_mux (
                       .DAC_0       (DAC_OUT[0]),
                       .DAC_1       (DAC_OUT[1]),
                       .DAC_2       (DAC_OUT[2]),
                       .DAC_SELECT  (DAC_MUX_SELECT[obd_mux_index]), 
                       .DAC_MUX_OUT (VAREFDAC[obd_mux_index])
                   );
end
endgenerate  
  
//---------------------------------------------------------------------------------------------------------
// One-Bit DAC Logic


assign DAC_MUX_SELECT[0] = AQ0_DAC_MUX_SEL;
assign DAC_MUX_SELECT[1] = AQ1_DAC_MUX_SEL;
assign DAC_MUX_SELECT[2] = AQ2_DAC_MUX_SEL;
assign DAC_MUX_SELECT[3] = AQ3_DAC_MUX_SEL;
assign DAC_MUX_SELECT[4] = AQ4_DAC_MUX_SEL;
assign DAC_MUX_SELECT[5] = AQ5_DAC_MUX_SEL;


generate
  for (obd_index=0 ; obd_index<3 ; obd_index=obd_index+1)
  begin: obd_loop
    obd #(.RESOLUTION(DAC_RESOLUTION[obd_index*2 + 1:obd_index*2]))
	u_obd (
	       .OBD_CONFIG (DAC_CONFIG[obd_index]), 
	       .OBD_DIN    (OBD_DIN   [obd_index]), 
	       .OBD_CLKIN  (OBD_CLKIN [obd_index]), 
	       .OBD_ENABLE (OBD_ENABLE[obd_index]),
	       .DAC_OUT    (DAC_OUT   [obd_index]) 
	       );
  end
endgenerate

// DAC output is registered version of OBD_DIN generated by ACE RTL
// Logic of DAC is not yet defined and hence this approximation
// Update logic in obd.v file to reflect the implementation

assign DACOUT0 = DAC_OUT[0];
assign DACOUT1 = DAC_OUT[1];
assign DACOUT2 = DAC_OUT[2];

//---------------------------------------------------------------------------------------------------------
endmodule

`timescale 1ns/1ps
module DSSAB (
DIGEN0,
 DIGEN1,
 DIGEN2,
 DIGEN3,
 DIGEN4,
 DIGEN5,
 DIGEN6,
 DIGEN7,
 DIGEN8,
 DIGEN9,
 DIGEN10,
 DIGEN11,
 DIGOUT0,
 DIGOUT1,
 DIGOUT2,
 DIGOUT3,
 DIGOUT4,
 DIGOUT5,
 DIGOUT6,
 DIGOUT7,
 DIGOUT8,
 DIGOUT9,
 DIGOUT10,
 DIGOUT11,
 ADCIN0,
 ADCIN1,
 ADCIN2,
 ADCIN3,
 ADCIN4,
 ADCIN5,
 ADCIN6,
 ADCIN7,
 ADCIN8,
 ADCIN9,
 ADCIN10,
 ADCIN11,
 DACOUT0,
 DACOUT1,
 DACOUT2,
 AV1Q0,
 AV1Q1,
 AV1Q2,
 AV1Q3,
 AV1Q4,
 AV1Q5,
 AV2Q0,
 AV2Q1,
 AV2Q2,
 AV2Q3,
 AV2Q4,
 AV2Q5,
 ATQ0,
 ATQ1,
 ATQ2,
 ATQ3,
 ATQ4,
 ATQ5,
 ACQ0,
 ACQ1,
 ACQ2,
 ACQ3,
 ACQ4,
 ACQ5,
 ATRTN01,
 ATRTN23,
 ATRTN45,
 VAREF0,
 VAREF1,
 VAREF2,
 VAREFOUT,
 GNDREF,
 TVC0,
 TVC1,
 TVC2,
 STC0,
 STC1,
 STC2,
 MODE0,
 MODE1,
 MODE2,
 VAREFSEL,
 START0,
 START1,
 START2,
 PWRDWN0,
 PWRDWN1,
 PWRDWN2,
 ADCRESET0,
 ADCRESET1,
 ADCRESET2,
 CHNUMBER0,
 CHNUMBER1,
 CHNUMBER2,
 BUSY0,
 BUSY1,
 BUSY2,
 CALIBRATE0,
 CALIBRATE1,
 CALIBRATE2,
 DATAVALID0,
 DATAVALID1,
 DATAVALID2,
 SAMPLE0,
 SAMPLE1,
 SAMPLE2,
 RESULT0,
 RESULT1,
 RESULT2,
 ADCCLK0,
 ADCCLK1,
 ADCCLK2,
 OBDIN0,
 OBDIN1,
 OBDIN2,
 OBDCLK0,
 OBDCLK1,
 OBDCLK2,
 OBDEN0,
 OBDEN1,
 OBDEN2,
 ACMPOUT0,
 ACMPOUT1,
 ACMPOUT2,
 ACMPOUT3,
 ACMPOUT4,
 ACMPOUT5,
 ACMPOUT6,
 ACMPOUT7,
 ACMPOUT8,
 ACMPOUT9,
 ACMPOUT10,
 ACMPOUT11,
 ABPWRON,
 ACBRESET,
 ACBADDR,
 ACBWRE,
 ACBWDATA,
 ACBRDATA);
input DIGEN0;
input DIGEN1;
input DIGEN2;
input DIGEN3;
input DIGEN4;
input DIGEN5;
input DIGEN6;
input DIGEN7;
input DIGEN8;
input DIGEN9;
input DIGEN10;
input DIGEN11;
output DIGOUT0;
output DIGOUT1;
output DIGOUT2;
output DIGOUT3;
output DIGOUT4;
output DIGOUT5;
output DIGOUT6;
output DIGOUT7;
output DIGOUT8;
output DIGOUT9;
output DIGOUT10;
output DIGOUT11;
input ADCIN0;
input ADCIN1;
input ADCIN2;
input ADCIN3;
input ADCIN4;
input ADCIN5;
input ADCIN6;
input ADCIN7;
input ADCIN8;
input ADCIN9;
input ADCIN10;
input ADCIN11;
output DACOUT0;
output DACOUT1;
output DACOUT2;
input AV1Q0;
input AV1Q1;
input AV1Q2;
input AV1Q3;
input AV1Q4;
input AV1Q5;
input AV2Q0;
input AV2Q1;
input AV2Q2;
input AV2Q3;
input AV2Q4;
input AV2Q5;
input ATQ0;
input ATQ1;
input ATQ2;
input ATQ3;
input ATQ4;
input ATQ5;
input ACQ0;
input ACQ1;
input ACQ2;
input ACQ3;
input ACQ4;
input ACQ5;
input ATRTN01;
input ATRTN23;
input ATRTN45;
input VAREF0;
input VAREF1;
input VAREF2;
output VAREFOUT;
input GNDREF;
input [7 : 0] TVC0;
input [7 : 0] TVC1;
input [7 : 0] TVC2;
input [7 : 0] STC0;
input [7 : 0] STC1;
input [7 : 0] STC2;
input [3 : 0] MODE0;
input [3 : 0] MODE1;
input [3 : 0] MODE2;
input VAREFSEL;
input START0;
input START1;
input START2;
input PWRDWN0;
input PWRDWN1;
input PWRDWN2;
input ADCRESET0;
input ADCRESET1;
input ADCRESET2;
input [4 : 0] CHNUMBER0;
input [4 : 0] CHNUMBER1;
input [4 : 0] CHNUMBER2;
output BUSY0;
output BUSY1;
output BUSY2;
output CALIBRATE0;
output CALIBRATE1;
output CALIBRATE2;
output DATAVALID0;
output DATAVALID1;
output DATAVALID2;
output SAMPLE0;
output SAMPLE1;
output SAMPLE2;
output [11 : 0] RESULT0;
output [11 : 0] RESULT1;
output [11 : 0] RESULT2;
input ADCCLK0;
input ADCCLK1;
input ADCCLK2;
input OBDIN0;
input OBDIN1;
input OBDIN2;
input OBDCLK0;
input OBDCLK1;
input OBDCLK2;
input OBDEN0;
input OBDEN1;
input OBDEN2;
output ACMPOUT0;
output ACMPOUT1;
output ACMPOUT2;
output ACMPOUT3;
output ACMPOUT4;
output ACMPOUT5;
output ACMPOUT6;
output ACMPOUT7;
output ACMPOUT8;
output ACMPOUT9;
output ACMPOUT10;
output ACMPOUT11;
input ABPWRON;
input ACBRESET;
input [7 : 0] ACBADDR;
input ACBWRE;
input [7 : 0] ACBWDATA;
   output [7 : 0] ACBRDATA;

   parameter DAC_RESOLUTION = 0;
  
  F2AB #(.DAC_RESOLUTION(DAC_RESOLUTION)) VandVinst (.AV1({AV1Q5,AV1Q4,AV1Q3, AV1Q2, AV1Q1, AV1Q0}),
		  .AV2({AV2Q5,AV2Q4,AV2Q3, AV2Q2, AV2Q1, AV2Q0}),
		  .AC({ACQ5,ACQ4,ACQ3, ACQ2, ACQ1, ACQ0}),
		  .AT({ATQ5,ATQ4,ATQ3, ATQ2, ATQ1, ATQ0}),

		  .ATGND_01(ATRTN01),  
		  .ATGND_23(ATRTN23),  
		  .ATGND_45(ATRTN45),  
		  
		  .VAREF({VAREF2, VAREF1, VAREF0}),
		  .ADCGNDREF(GNDREF),
		  
		  .ADC_VAREFSEL(VAREFSEL),

		  .ADC0 ({ADCIN3, ADCIN2, ADCIN1, ADCIN0}),
		  .ADC1 ({ADCIN7, ADCIN6, ADCIN5, ADCIN4}),
		  .ADC2 ({ADCIN11, ADCIN10, ADCIN9, ADCIN8}),

		  .DEN_ADC({DIGEN11, DIGEN10, DIGEN9,
			    DIGEN8, DIGEN7, DIGEN6,
			    DIGEN5, DIGEN4, DIGEN3, DIGEN2,
			    DIGEN1, DIGEN0}),   
		  
		  .ADC0_PWRDWN(PWRDWN0),   
		  .ADC0_ADCRESET(ADCRESET0),
		  .ADC0_SYSCLK(ADCCLK0),   
		  .ADC0_CHNUMBER(CHNUMBER0),
		  .ADC0_MODE(MODE0),  
		  .ADC0_TVC(TVC0),  
		  .ADC0_STC(STC0),  
		  .ADC0_ADCSTART(START0),

		  .ADC1_PWRDWN(PWRDWN1),   
		  .ADC1_ADCRESET(ADCRESET1),
		  .ADC1_SYSCLK(ADCCLK1),   
		  .ADC1_CHNUMBER(CHNUMBER1),
		  .ADC1_MODE(MODE1),  
		  .ADC1_TVC(TVC1),  
		  .ADC1_STC(STC1),  
		  .ADC1_ADCSTART(START1),		  

		  .ADC2_PWRDWN(PWRDWN2),   
		  .ADC2_ADCRESET(ADCRESET2),
		  .ADC2_SYSCLK(ADCCLK2),   
		  .ADC2_CHNUMBER(CHNUMBER2),
		  .ADC2_MODE(MODE2),  
		  .ADC2_TVC(TVC2),  
		  .ADC2_STC(STC2),  
		  .ADC2_ADCSTART(START2),
		  
		  .ACB_RST(ACBRESET),
		  .ACB_WEN(ACBWRE),  
		  .ACB_ADDR(ACBADDR),
		  .ACB_WDATA(ACBWDATA),
		  
		  .ADC_VAREFOUT(VAREFOUT),
		  
		  .ACB_RDATA(ACBRDATA),

		  .ADC0_BUSY(BUSY0),   
		  .ADC0_CALIBRATE(CALIBRATE0),
		  .ADC0_DATAVALID(DATAVALID0),
		  .ADC0_SAMPLE(SAMPLE0),    
		  .ADC0_RESULT(RESULT0),   

		  .ADC1_BUSY(BUSY1),   
		  .ADC1_CALIBRATE(CALIBRATE1),
		  .ADC1_DATAVALID(DATAVALID1),
		  .ADC1_SAMPLE(SAMPLE1),    
		  .ADC1_RESULT(RESULT1),   

		  .ADC2_BUSY(BUSY2),   
		  .ADC2_CALIBRATE(CALIBRATE2),
		  .ADC2_DATAVALID(DATAVALID2),
		  .ADC2_SAMPLE(SAMPLE2),    
		  .ADC2_RESULT(RESULT2),   
		  
		  .DACOUT0(DACOUT0),
		  .DACOUT1(DACOUT1),
		  .DACOUT2(DACOUT2),
		  
		  .DIG_ADC({DIGOUT11, DIGOUT10, DIGOUT9,
			    DIGOUT8, DIGOUT7, DIGOUT6,
			    DIGOUT5, DIGOUT4, DIGOUT3, DIGOUT2,
			    DIGOUT1, DIGOUT0}),

		  .OBD_DIN({OBDIN2, OBDIN1, OBDIN0}),
		  .OBD_CLKIN({OBDCLK2, OBDCLK1, OBDCLK0}),
		  .OBD_ENABLE({OBDEN2, OBDEN1, OBDEN0}),

		  
		  .COMPARATOR({ACMPOUT11, ACMPOUT10, ACMPOUT9,
			       ACMPOUT8, ACMPOUT7, ACMPOUT6,
			       ACMPOUT5, ACMPOUT4, ACMPOUT3, ACMPOUT2,
			       ACMPOUT1, ACMPOUT0})
		  );
  
endmodule

`timescale 1ns/1ps
module DSSAB_F060 (
DIGEN0,
 DIGEN1,
 DIGEN2,
 DIGEN3,
 DIGEN4,
 DIGEN5,
 DIGEN6,
 DIGEN7,
 DIGEN8,
 DIGEN9,
 DIGEN10,
 DIGEN11,
 DIGOUT0,
 DIGOUT1,
 DIGOUT2,
 DIGOUT3,
 DIGOUT4,
 DIGOUT5,
 DIGOUT6,
 DIGOUT7,
 DIGOUT8,
 DIGOUT9,
 DIGOUT10,
 DIGOUT11,
 ADCIN0,
 ADCIN1,
 ADCIN2,
 ADCIN3,
 ADCIN4,
 ADCIN5,
 ADCIN6,
 ADCIN7,
 ADCIN8,
 ADCIN9,
 ADCIN10,
 ADCIN11,
 ADCIN12,
 ADCIN13,
 ADCIN14,
 ADCIN15,
 ADCIN16,
 ADCIN17,
 ADCIN18,
 ADCIN19,
 ADCIN20,
 ADCIN21,
 ADCIN22,
 ADCIN23,
 ADCIN24,
 ADCIN25,
 DACOUT0,
 DACOUT1,
 DACOUT2,
 AV1Q0,
 AV1Q1,
 AV1Q2,
 AV1Q3,
 AV1Q4,
 AV1Q5,
 AV2Q0,
 AV2Q1,
 AV2Q2,
 AV2Q3,
 AV2Q4,
 AV2Q5,
 ATQ0,
 ATQ1,
 ATQ2,
 ATQ3,
 ATQ4,
 ATQ5,
 ACQ0,
 ACQ1,
 ACQ2,
 ACQ3,
 ACQ4,
 ACQ5,
 ATRTN01,
 ATRTN23,
 ATRTN45,
 VAREF0,
 VAREF1,
 VAREF2,
 VAREFOUT,
 GNDREF,
 TVC0,
 TVC1,
 TVC2,
 STC0,
 STC1,
 STC2,
 MODE0,
 MODE1,
 MODE2,
 VAREFSEL,
 START0,
 START1,
 START2,
 PWRDWN0,
 PWRDWN1,
 PWRDWN2,
 ADCRESET0,
 ADCRESET1,
 ADCRESET2,
 CHNUMBER0,
 CHNUMBER1,
 CHNUMBER2,
 BUSY0,
 BUSY1,
 BUSY2,
 CALIBRATE0,
 CALIBRATE1,
 CALIBRATE2,
 DATAVALID0,
 DATAVALID1,
 DATAVALID2,
 SAMPLE0,
 SAMPLE1,
 SAMPLE2,
 RESULT0,
 RESULT1,
 RESULT2,
 ADCCLK0,
 ADCCLK1,
 ADCCLK2,
 OBDIN0,
 OBDIN1,
 OBDIN2,
 OBDCLK0,
 OBDCLK1,
 OBDCLK2,
 OBDEN0,
 OBDEN1,
 OBDEN2,
 ACMPOUT0,
 ACMPOUT1,
 ACMPOUT2,
 ACMPOUT3,
 ACMPOUT4,
 ACMPOUT5,
 ACMPOUT6,
 ACMPOUT7,
 ACMPOUT8,
 ACMPOUT9,
 ACMPOUT10,
 ACMPOUT11,
 ABPWRON,
 ACBRESET,
 ACBADDR,
 ACBWRE,
 ACBWDATA,
 ACBRDATA);
input DIGEN0;
input DIGEN1;
input DIGEN2;
input DIGEN3;
input DIGEN4;
input DIGEN5;
input DIGEN6;
input DIGEN7;
input DIGEN8;
input DIGEN9;
input DIGEN10;
input DIGEN11;
output DIGOUT0;
output DIGOUT1;
output DIGOUT2;
output DIGOUT3;
output DIGOUT4;
output DIGOUT5;
output DIGOUT6;
output DIGOUT7;
output DIGOUT8;
output DIGOUT9;
output DIGOUT10;
output DIGOUT11;
input ADCIN0;
input ADCIN1;
input ADCIN2;
input ADCIN3;
input ADCIN4;
input ADCIN5;
input ADCIN6;
input ADCIN7;
input ADCIN8;
input ADCIN9;
input ADCIN10;
input ADCIN11;
input ADCIN12;
input ADCIN13;
input ADCIN14;
input ADCIN15;
input ADCIN16;
input ADCIN17;
input ADCIN18;
input ADCIN19;
input ADCIN20;
input ADCIN21;
input ADCIN22;
input ADCIN23;
input ADCIN24;
input ADCIN25;
output DACOUT0;
output DACOUT1;
output DACOUT2;
input AV1Q0;
input AV1Q1;
input AV1Q2;
input AV1Q3;
input AV1Q4;
input AV1Q5;
input AV2Q0;
input AV2Q1;
input AV2Q2;
input AV2Q3;
input AV2Q4;
input AV2Q5;
input ATQ0;
input ATQ1;
input ATQ2;
input ATQ3;
input ATQ4;
input ATQ5;
input ACQ0;
input ACQ1;
input ACQ2;
input ACQ3;
input ACQ4;
input ACQ5;
input ATRTN01;
input ATRTN23;
input ATRTN45;
input VAREF0;
input VAREF1;
input VAREF2;
output VAREFOUT;
input GNDREF;
input [7 : 0] TVC0;
input [7 : 0] TVC1;
input [7 : 0] TVC2;
input [7 : 0] STC0;
input [7 : 0] STC1;
input [7 : 0] STC2;
input [3 : 0] MODE0;
input [3 : 0] MODE1;
input [3 : 0] MODE2;
input VAREFSEL;
input START0;
input START1;
input START2;
input PWRDWN0;
input PWRDWN1;
input PWRDWN2;
input ADCRESET0;
input ADCRESET1;
input ADCRESET2;
input [4 : 0] CHNUMBER0;
input [4 : 0] CHNUMBER1;
input [4 : 0] CHNUMBER2;
output BUSY0;
output BUSY1;
output BUSY2;
output CALIBRATE0;
output CALIBRATE1;
output CALIBRATE2;
output DATAVALID0;
output DATAVALID1;
output DATAVALID2;
output SAMPLE0;
output SAMPLE1;
output SAMPLE2;
output [11 : 0] RESULT0;
output [11 : 0] RESULT1;
output [11 : 0] RESULT2;
input ADCCLK0;
input ADCCLK1;
input ADCCLK2;
input OBDIN0;
input OBDIN1;
input OBDIN2;
input OBDCLK0;
input OBDCLK1;
input OBDCLK2;
input OBDEN0;
input OBDEN1;
input OBDEN2;
output ACMPOUT0;
output ACMPOUT1;
output ACMPOUT2;
output ACMPOUT3;
output ACMPOUT4;
output ACMPOUT5;
output ACMPOUT6;
output ACMPOUT7;
output ACMPOUT8;
output ACMPOUT9;
output ACMPOUT10;
output ACMPOUT11;
input ABPWRON;
input ACBRESET;
input [7 : 0] ACBADDR;
input ACBWRE;
input [7 : 0] ACBWDATA;
   output [7 : 0] ACBRDATA;

   parameter DAC_RESOLUTION = 0;
  
  F2AB_F060 #(.DAC_RESOLUTION(DAC_RESOLUTION)) VandVinst (.AV1({AV1Q5,AV1Q4,AV1Q3, AV1Q2, AV1Q1, AV1Q0}),
		  .AV2({AV2Q5,AV2Q4,AV2Q3, AV2Q2, AV2Q1, AV2Q0}),
		  .AC({ACQ5,ACQ4,ACQ3, ACQ2, ACQ1, ACQ0}),
		  .AT({ATQ5,ATQ4,ATQ3, ATQ2, ATQ1, ATQ0}),

		  .ATGND_01(ATRTN01),  
		  .ATGND_23(ATRTN23),  
		  .ATGND_45(ATRTN45),  
		  
		  .VAREF({VAREF2, VAREF1, VAREF0}),
		  .ADCGNDREF(GNDREF),
		  
		  .ADC_VAREFSEL(VAREFSEL),

		  .ADC0 ({ADCIN3, ADCIN2, ADCIN1, ADCIN0}),
		  .ADC1 ({ADCIN7, ADCIN6, ADCIN5, ADCIN4}),
		  .ADC2 ({ADCIN11, ADCIN10, ADCIN9, ADCIN8}),
      .ADC_F060({ADCIN25,ADCIN24,ADCIN23,ADCIN22,ADCIN21,ADCIN20,ADCIN19,ADCIN18,ADCIN17,ADCIN16,ADCIN15,ADCIN14,ADCIN13,ADCIN12}),

		  .DEN_ADC({DIGEN11, DIGEN10, DIGEN9,
			    DIGEN8, DIGEN7, DIGEN6,
			    DIGEN5, DIGEN4, DIGEN3, DIGEN2,
			    DIGEN1, DIGEN0}),   
		  
		  .ADC0_PWRDWN(PWRDWN0),   
		  .ADC0_ADCRESET(ADCRESET0),
		  .ADC0_SYSCLK(ADCCLK0),   
		  .ADC0_CHNUMBER(CHNUMBER0),
		  .ADC0_MODE(MODE0),  
		  .ADC0_TVC(TVC0),  
		  .ADC0_STC(STC0),  
		  .ADC0_ADCSTART(START0),

		  .ADC1_PWRDWN(PWRDWN1),   
		  .ADC1_ADCRESET(ADCRESET1),
		  .ADC1_SYSCLK(ADCCLK1),   
		  .ADC1_CHNUMBER(CHNUMBER1),
		  .ADC1_MODE(MODE1),  
		  .ADC1_TVC(TVC1),  
		  .ADC1_STC(STC1),  
		  .ADC1_ADCSTART(START1),		  

		  .ADC2_PWRDWN(PWRDWN2),   
		  .ADC2_ADCRESET(ADCRESET2),
		  .ADC2_SYSCLK(ADCCLK2),   
		  .ADC2_CHNUMBER(CHNUMBER2),
		  .ADC2_MODE(MODE2),  
		  .ADC2_TVC(TVC2),  
		  .ADC2_STC(STC2),  
		  .ADC2_ADCSTART(START2),
		  
		  .ACB_RST(ACBRESET),
		  .ACB_WEN(ACBWRE),  
		  .ACB_ADDR(ACBADDR),
		  .ACB_WDATA(ACBWDATA),
		  
		  .ADC_VAREFOUT(VAREFOUT),
		  
		  .ACB_RDATA(ACBRDATA),

		  .ADC0_BUSY(BUSY0),   
		  .ADC0_CALIBRATE(CALIBRATE0),
		  .ADC0_DATAVALID(DATAVALID0),
		  .ADC0_SAMPLE(SAMPLE0),    
		  .ADC0_RESULT(RESULT0),   

		  .ADC1_BUSY(BUSY1),   
		  .ADC1_CALIBRATE(CALIBRATE1),
		  .ADC1_DATAVALID(DATAVALID1),
		  .ADC1_SAMPLE(SAMPLE1),    
		  .ADC1_RESULT(RESULT1),   

		  .ADC2_BUSY(BUSY2),   
		  .ADC2_CALIBRATE(CALIBRATE2),
		  .ADC2_DATAVALID(DATAVALID2),
		  .ADC2_SAMPLE(SAMPLE2),    
		  .ADC2_RESULT(RESULT2),   
		  
		  .DACOUT0(DACOUT0),
		  .DACOUT1(DACOUT1),
		  .DACOUT2(DACOUT2),
		  
		  .DIG_ADC({DIGOUT11, DIGOUT10, DIGOUT9,
			    DIGOUT8, DIGOUT7, DIGOUT6,
			    DIGOUT5, DIGOUT4, DIGOUT3, DIGOUT2,
			    DIGOUT1, DIGOUT0}),

		  .OBD_DIN({OBDIN2, OBDIN1, OBDIN0}),
		  .OBD_CLKIN({OBDCLK2, OBDCLK1, OBDCLK0}),
		  .OBD_ENABLE({OBDEN2, OBDEN1, OBDEN0}),

		  
		  .COMPARATOR({ACMPOUT11, ACMPOUT10, ACMPOUT9,
			       ACMPOUT8, ACMPOUT7, ACMPOUT6,
			       ACMPOUT5, ACMPOUT4, ACMPOUT3, ACMPOUT2,
			       ACMPOUT1, ACMPOUT0})
		  );
  
endmodule

//---- MODULE IOPAD_A_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_A_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_A_IN(Y,PAD);
 input PAD;
 output Y;

 assign Y = PAD;
 
       specify

    specparam tpdLH_PAD_to_Y = (0.0:0.0:0.0);
    specparam tpdHL_PAD_to_Y = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_A_IN ----

//---- MODULE IOPAD_DA_IN ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_DA_IN
 CELL TYPE : comb
 CELL LOGIC : Y=PAD
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_DA_IN(Y,PAD);
 input PAD;
 output Y;
 reg NOTIFY_REG;

 assign Y = PAD;

       specify

    specparam tpdLH_PAD_to_Y = (0.0:0.0:0.0);
    specparam tpdHL_PAD_to_Y = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (PAD => Y ) = ( tpdLH_PAD_to_Y, tpdHL_PAD_to_Y );
    specparam PATHPULSE$PAD$Y = (0.1, 0.1);
    $width(negedge PAD, 0.0, 0, NOTIFY_REG);
    $width(posedge PAD, 0.0, 0, NOTIFY_REG);

   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_DA_IN ----

//---- MODULE IOPAD_A_OUT ----
/*--------------------------------------------------------------------
 CELL NAME : IOPAD_A_OUT
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module IOPAD_A_OUT(PAD,D);
 input D;
 output PAD;

 assign PAD = D;

       specify

    specparam tpdLH_D_to_PAD = (0.0:0.0:0.0);
    specparam tpdHL_D_to_PAD = (0.0:0.0:0.0);
    specparam MacroType = "comb";

    //pin to pin path delay

    (D => PAD ) = ( tpdLH_D_to_PAD, tpdHL_D_to_PAD );
   endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE IOPAD_A_OUT ----

//---- MODULE NGMUXPRIM ----
/*--------------------------------------------------------------------
 CELL NAME : NGMUXPRIM
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module NGMUXPRIM ( GL, CLK0, CLK1, S );

  input   CLK0;
  input   CLK1;
  input   S;
  output  GL;

  reg     GL_zd;

  wire    CLK0_ipd;
  wire    CLK1_ipd;
  wire    S_ipd;

  reg     S_ipd_prev;
  reg     CLK0_ipd_prev;
  reg     CLK1_ipd_prev;
  integer CLK0_re;
  integer CLK1_re;
  integer CLK0_fe;
  integer CLK1_fe;
    // restart_clk_edge is assigned when GL_zd is sent low.
    // It is the number of "to clk" edges that must occur before the switch is complete
  integer restart_clk_edge;
    // driving_clk is -1 for GND, 0 for CLK0, 1 for CLK1, and -2 for unknown, and -3 for initialization
  integer driving_clk;

  buf     BUF_G ( GL, GL_zd );

  buf U0 ( CLK0_ipd, CLK0 );
  buf U1 ( CLK1_ipd, CLK1 );
  buf U2 ( S_ipd,    S    );

  initial
  begin
    S_ipd_prev       <= 1'bx;
    CLK0_ipd_prev    <= 1'bx;
    CLK1_ipd_prev    <= 1'bx;
    CLK0_re          <= 0;
    CLK1_re          <= 0;
    CLK0_fe          <= 0;
    CLK1_fe          <= 0;
    // Initial powerup does not have a standard switching sequence, comes up immediately with selected CLK
    restart_clk_edge <= 0;
    driving_clk      <= -3;
  end

  always @ ( CLK0_ipd, CLK1_ipd, S_ipd )
  begin
    if ( CLK0_ipd !== CLK0_ipd_prev ) begin
      CLK0_ipd_prev <= CLK0_ipd;
      if ( CLK0_ipd === 1'b1 ) begin
        CLK0_re <= CLK0_re + 1;
      end else if ( CLK0_ipd === 1'b0 ) begin
        CLK0_fe <= CLK0_fe + 1;
      end
    end
    if ( CLK1_ipd !== CLK1_ipd_prev ) begin
      CLK1_ipd_prev <= CLK1_ipd;
      if ( CLK1_ipd === 1'b1 ) begin
        CLK1_re <= CLK1_re + 1;
      end else if ( CLK1_ipd === 1'b0 ) begin
        CLK1_fe <= CLK1_fe + 1;
      end
    end
    if ( S_ipd !== S_ipd_prev ) begin
      S_ipd_prev <= S_ipd;
      CLK0_re <= 0;
      CLK1_re <= 0;
      CLK0_fe <= 0;
      CLK1_fe <= 0;
      // Handle error conditions:  previous switching cycle not completed or S_ipd unknown
      // driving_clk != -3 condition avoids error messsages for initial powerup unnknown
      if ( driving_clk != -3 ) begin
        if ( S_ipd === 1'b0 ) begin
          if ( driving_clk != 1 )  begin
            $display( " ERROR: NGMUX switching sequence not completed, output GL unpredictable " );
            $display( " Time: %0.1f Instance: %m ", $realtime );
            driving_clk <= 1;
          end
        end else if ( S_ipd === 1'b1 ) begin
          if ( driving_clk != 0 )  begin
            $display( " ERROR: NGMUX switching sequence not completed, output GL unpredictable " );
            $display( " Time: %0.1f Instance: %m ", $realtime );
            driving_clk <= 0;
          end
        end else begin
          $display( " ERROR: NGMUX input S is unknown, output GL unpredictable, setting to 0 " );
          $display( " Time: %0.1f Instance: %m ", $realtime );
          driving_clk <= -2;
          restart_clk_edge <= 17;
        end
      end
    end
  end

  always @ ( driving_clk, CLK0_re, CLK0_fe, CLK1_re, CLK1_fe )
  begin
    if ( driving_clk == 0 ) begin
      GL_zd <= CLK0_ipd;
      if ( S_ipd === 1'b1 ) begin
        if ( ( CLK0_re == 0 ) && ( CLK1_re == 7 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 9;
        end else if ( ( CLK0_fe == 0 ) && ( CLK1_re == 15 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 17;
        end else if ( ( CLK0_ipd === 1'b0 ) && ( CLK0_re == 1 ) && ( ( CLK0_fe == 1 ) || ( CLK0_fe == 2 ) ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= CLK1_re + 2;
        end
      end
    end else if ( driving_clk == 1 ) begin
      GL_zd <= CLK1_ipd;
      if ( S_ipd === 1'b0 ) begin
        if ( ( CLK1_re == 0 ) && ( CLK0_re == 7 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 9;
        end else if ( ( CLK1_fe == 0 ) && ( CLK0_re == 15 ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= 17;
        end else if ( ( CLK1_ipd === 1'b0 ) && ( CLK1_re == 1 ) && ( ( CLK1_fe == 1 ) || ( CLK1_fe == 2 ) ) ) begin
          driving_clk <= -1;
          restart_clk_edge <= CLK0_re + 2;
        end
      end
    end else if ( driving_clk == -2 ) begin
      GL_zd <= 1'b0;
    end else begin
      if ( ( S_ipd == 1'b1 ) && ( CLK1_re >= restart_clk_edge ) ) begin
        driving_clk <= 1;
        GL_zd <= CLK1_ipd;
      end else if ( ( S_ipd == 1'b0 ) && ( CLK0_re >= restart_clk_edge ) ) begin
        driving_clk <= 0;
        GL_zd <= CLK0_ipd;
      end else begin
        GL_zd <= 1'b0;
      end
    end
  end

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NGMUXPRIM ----

//---- MODULE NGMUX ----
/*--------------------------------------------------------------------
 CELL NAME : NGMUX
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module NGMUX ( GL, CLK0, CLK1, S );

  input   CLK0;
  input   CLK1;
  input   S;
  output  GL;

  reg     NOTIFY_REG;

  wire    CLK0_ipd;
  wire    CLK1_ipd;
  wire    S_ipd;

  // Add SDF PORT delays
  buf U0 ( CLK0_ipd, CLK0 );
  buf U1 ( CLK1_ipd, CLK1 );
  buf U2 ( S_ipd,    S    );

  // Instantiation of NGMUXPRIM with pure functionality
  NGMUXPRIM NGMUX0 (
    .GL   ( GL ),
    .CLK0 ( CLK0_ipd ),
    .CLK1 ( CLK1_ipd ),
    .S    ( S_ipd )
  );

    specify

      specparam tpdLH_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK0_to_GL = ( 100 : 100 : 100 );
      specparam tpdLH_CLK1_to_GL = ( 100 : 100 : 100 );
      specparam tpdHL_CLK1_to_GL = ( 100 : 100 : 100 );

      //pin to pin path delay 

      ( CLK0 => GL ) = ( tpdLH_CLK0_to_GL, tpdHL_CLK0_to_GL );
      ( CLK1 => GL ) = ( tpdLH_CLK1_to_GL, tpdHL_CLK1_to_GL );

      //checking setup and hold timing for inputs
  
      $setup(negedge S, posedge CLK1, 0.0, NOTIFY_REG);
      $hold(posedge CLK1, negedge S, 0.0, NOTIFY_REG);
      $setup(posedge S, posedge CLK0, 0.0, NOTIFY_REG);
      $hold(posedge CLK0, posedge S, 0.0, NOTIFY_REG);

    endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE NGMUX ----

//---- MODULE RCOSC ----
/*--------------------------------------------------------------------
 CELL NAME : RCOSC 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module RCOSC 
  (
  CLKOUT
  );

  output CLKOUT;

  reg CLKOUT;

  always
  begin
    forever
    begin
      CLKOUT = 1'b1;
      # 5000;
      CLKOUT = 1'b0;
      # 5000;
    end
  end

endmodule
//---- END MODULE RCOSC ----

//---- MODULE PLLPRIM ----
/*--------------------------------------------------------------------
 CELL NAME : PLLPRIM
 ---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module PLLPRIM (
		DYNSYNC,
		CLKA,
		EXTFB,
		POWERDOWN,
		CLKB,
		CLKC,
		OADIVRST,
		OADIVHALF,
		OADIV0,
		OADIV1,
		OADIV2,
		OADIV3,
		OADIV4,
		OAMUX0,
		OAMUX1,
		OAMUX2,
		BYPASSA,
		DLYGLA0,
		DLYGLA1,
		DLYGLA2,
		DLYGLA3,
		DLYGLA4,
		DLYGLADSS0,
		DLYGLADSS1,
		DLYGLADSS2,
		DLYGLADSS3,
		DLYGLADSS4,
		DLYGLACORE0,
		DLYGLACORE1,
		DLYGLACORE2,
		DLYGLACORE3,
		DLYGLACORE4,
		OBDIVRST,
		OBDIVHALF,
		OBDIV0,
		OBDIV1,
		OBDIV2,
		OBDIV3,
		OBDIV4,
		OBMUX0,
		OBMUX1,
		OBMUX2,
		BYPASSB,
		DLYGLB0,
		DLYGLB1,
		DLYGLB2,
		DLYGLB3,
		DLYGLB4,
		OCDIVRST,
		OCDIVHALF,
		OCDIV0,
		OCDIV1,
		OCDIV2,
		OCDIV3,
		OCDIV4,
		OCMUX0,
		OCMUX1,
		OCMUX2,
		BYPASSC,
		DLYGLC0,
		DLYGLC1,
		DLYGLC2,
		DLYGLC3,
		DLYGLC4,
		FINDIV0,
		FINDIV1,
		FINDIV2,
		FINDIV3,
		FINDIV4,
		FINDIV5,
		FINDIV6,
		FBDIV0,
		FBDIV1,
		FBDIV2,
		FBDIV3,
		FBDIV4,
		FBDIV5,
		FBDIV6,
		FBDLY0,
		FBDLY1,
		FBDLY2,
		FBDLY3,
		FBDLY4,
		FBSEL0,
		FBSEL1,
		XDLYSEL,
		GLA,
		GLADSS,
		LOCK,
		GLB,
		YB,
		GLC,
		MACCLK,
		YC,
		GLMUXSEL,
		GLMUXCFG,
		GLMUXINT
		);

   output GLA, GLADSS, LOCK, GLB, YB, GLC, YC, MACCLK;
   input  XDLYSEL, FBSEL1, FBSEL0; 
   input  FBDLY4, FBDLY3, FBDLY2, FBDLY1, FBDLY0;
   input  FBDIV6, FBDIV5, FBDIV4, FBDIV3;
   input  FBDIV2, FBDIV1, FBDIV0;
   input  FINDIV6, FINDIV5, FINDIV4, FINDIV3, FINDIV2, FINDIV1, FINDIV0;
   input  DLYGLC4, DLYGLC3, DLYGLC2, DLYGLC1, DLYGLC0;
   input  OCMUX2, OCMUX1, OCMUX0, OCDIV4, OCDIV3, OCDIV2, OCDIV1, OCDIV0;
   input  BYPASSC;
   input  DLYGLB4, DLYGLB3, DLYGLB2, DLYGLB1, DLYGLB0;
   input  OBMUX2, OBMUX1, OBMUX0;
   input  BYPASSB;
   input  OBDIV4, OBDIV3, OBDIV2, OBDIV1, OBDIV0;
   input  DLYGLA4, DLYGLA3, DLYGLA2, DLYGLA1, DLYGLA0;
   input  DLYGLADSS4, DLYGLADSS3, DLYGLADSS2, DLYGLADSS1, DLYGLADSS0;
   input  DLYGLACORE4, DLYGLACORE3, DLYGLACORE2, DLYGLACORE1, DLYGLACORE0;
   input  OAMUX2, OAMUX1, OAMUX0;
   input  BYPASSA;
   input  OADIV4, OADIV3, OADIV2, OADIV1, OADIV0;
   input  OADIVHALF, OADIVRST;
   input  OBDIVHALF, OBDIVRST;
   input  OCDIVHALF, OCDIVRST;
   input  POWERDOWN, EXTFB, CLKA;
   input  CLKB;
   input  CLKC;
   input  DYNSYNC;
   input  GLMUXCFG, GLMUXSEL, GLMUXINT;
   
   parameter       VCOFREQUENCY   = 0.0;
   parameter       f_CLKA_LOCK    = 3;
   parameter       CLKA_TO_REF_DELAY   =  147;
   parameter       EMULATED_SYSTEM_DELAY = 2028;
   parameter       IN_DIV_DELAY   =  266; // Input dividers intrinsic delay
   //  parameter       OUT_DIV_DELAY  =  770; // Output dividers intrinsic delay
   parameter       OUT_UDIV_DELAY  =  662; // Output dividers intrinsic delay
   parameter       OUT_VDIV_DELAY  =  887; // Output dividers intrinsic delay
   parameter       OUT_WDIV_DELAY  =  887; // Output dividers intrinsic delay
   parameter       MUX_DELAY      = 500; // MUXA/MUXB/MUXC intrinsic delay
   parameter       IN_DELAY_BYP1  = 647; // Instrinsic delay for CLKDIVDLY bypass mode
   //  parameter       BYP_MUX_DELAY  =   40; // Bypass MUX intrinsic delay, not used for Ys
   parameter       BYP_GLAMUX_DELAY  =   20; // Bypass MUX intrinsic delay, not used for Ys
   parameter       BYP_GLBMUX_DELAY  =   30; // Bypass MUX intrinsic delay, not used for Ys
   parameter       BYP_GLCMUX_DELAY  =   30; // Bypass MUX intrinsic delay, not used for Ys
   //  parameter       GL_DRVR_DELAY  =   60; // Global Driver intrinsic delay
   parameter       GLA_DRVR_DELAY  =   35; // Global Driver intrinsic delay
   parameter       GLB_DRVR_DELAY  =   47; // Global Driver intrinsic delay
   parameter       GLC_DRVR_DELAY  =   47; // Global Driver intrinsic delay
   parameter       Y_DRVR_DELAY   =  0; // Y Driver intrinsic delay
   parameter       FB_MUX_DELAY   =  125; // FBSEL MUX intrinsic delay
   parameter       BYP0_CLK_GL    =  202; // Instrinsic delay for CLKDLY bypass mode This delay includes GLA DRIVER DELAY also. 
   parameter       X_MUX_DELAY    =  528; // XDLYSEL MUX intrinsic delay
   parameter       FIN_LOCK_DELAY = 300; // FIN to LOCK propagation delay
   parameter       LOCK_OUT_DELAY = 120; // LOCK to OUT propagation delay
   parameter       t_rise = 0;
   parameter       t_fall = 0;
   parameter       PROG_STEP_INCREMENT  = 200;
   parameter       PROG_INIT_DELAY      = 535;
   //for GLA, GLB and GLC initial delay is 65ps
   //0     65 ps
   //1     735 ps
   //2     935 ps
   //......
   //31    6735 ps
   parameter       INIT_DELAY      = 65; 

   parameter 	  NGMUX_GLA = 0; //GLA -> NGMUXOUT delay
   parameter 	  NGMUX_GLC = 30; // GLC -> NGMUXOUT delay
   parameter 	  NGMUX_GLMUXINT = 27; //GLMUXINT -> NGMUXOUT delay    
   
   reg 	  GLB;
   reg 	  GLA;
   reg 	  GLADSS;
   reg 	  GLC;
   reg 	  MACCLK;
   reg 	  YB;
   reg 	  YC;

   reg 	  AOUT;
   reg 	  BOUT;
   reg 	  COUT;
   
   reg 	  RESET1;
   reg 	  RESET2;
   reg 	  RESET3;

   time   PLLDELAY;
   time   PLLCLK_pw;
   time   PLLCLK_period;
   time   DTDELAY;
   time   FBDELAY;
   time   negative_delay;
   time   tmp_delay;
   time   LOCK_re;
   time   UIN_re;
   time   VIN_re;
   time   WIN_re;
   time   UIN_prev_re;
   time   VIN_prev_re;
   time   WIN_prev_re;
   integer UIN_period;
   integer VIN_period;
   integer WIN_period;
   
   //Additional delay value variables for GLA and GLB path

   time    GLBDELAY;
   time    GLADELAY;
   time    GLACOREDELAY;
   time    GLADSSDELAY;
   time    GLCDELAY;

   time    CLKA_period;
   time    CLKA_re;

   reg 	   PLLCLK;

   reg 	   halveA;
   reg 	   halveB;
   reg 	   halveC;
   reg 	   CLKA2X;
   reg 	   CLKB2X;
   reg 	   CLKC2X;
   time    CLKA2X_CLKA_re;
   time    CLKA2X_CLKA_period;
   time    CLKB2X_CLKB_re;
   time    CLKB2X_CLKB_period;
   time    CLKC2X_CLKC_re;
   time    CLKC2X_CLKC_period;

   wire    UIN;
   wire    VIN;
   wire    WIN;

   integer DelayVal1;
   integer DelayVal2;
   integer DelayVal3;
   integer DelayVal4;
   integer DelayVal5;
   integer DelayVal6;
   integer i;
   integer DIVN;
   integer DIVM;
   integer DIVU;
   integer DIVV;
   integer DIVW;
   integer fb_loop_div; // Total division of feedback loop
   integer DivVal;
   integer DivVal1;
   integer DivVal2;
   integer DivVal3;
   integer DivVal4;
   integer A_num_edges;
   integer B_num_edges;
   integer C_num_edges;
   integer FBSEL_illegal;
   integer UIN_num_res;
   integer UIN_num_fes;
   integer VIN_num_res;
   integer VIN_num_fes;
   integer WIN_num_res;
   integer WIN_num_fes;

   integer dlygla_step;
   integer dlyglb_step;
   integer dlyglc_step;


   // internal PLL control signal

   wire [4:0] OADIV_ipd;
   wire [4:0] OBDIV_ipd;
   wire [4:0] OCDIV_ipd;
   wire [2:0] OAMUX_ipd;
   wire [2:0] OBMUX_ipd;
   wire [2:0] OCMUX_ipd;
   wire       BYPASSA_ipd;
   wire       BYPASSB_ipd;
   wire       BYPASSC_ipd;
   wire [4:0] DLYGLA_ipd;
   wire [4:0] DLYGLADSS_ipd;
   wire [4:0] DLYGLACORE_ipd;
   wire [4:0] DLYGLB_ipd;
   wire [4:0] DLYGLC_ipd;
   wire [4:0] DLYYB_ipd;
   wire [6:0] FINDIV_ipd;
   wire [6:0] FBDIV_ipd;
   wire [4:0] FBDLY_ipd;
   wire [1:0] FBSEL_ipd;
   wire       XDLYSEL_ipd;
   wire       CLKA_ipd;
   wire       CLKB_ipd;
   wire       CLKC_ipd;
   wire       POWERDOWN_ipd;
   wire       EXTFB_ipd;
   wire       OADIVHALF_ipd;
   wire       OBDIVHALF_ipd;
   wire       OCDIVHALF_ipd;

   integer    res_post_reseta1;
   integer    fes_post_reseta1;
   integer    res_post_reseta0;
   integer    fes_post_reseta0;
   reg        AOUT_CLKA_last_value;
   reg        UIN_last_value;
   reg        POWERDOWNA_ipd_last_value;
   reg        forcea_0;
   integer    res_post_resetb1;
   integer    fes_post_resetb1;
   integer    res_post_resetb0;
   integer    fes_post_resetb0;
   reg        BOUT_CLKB_last_value;
   reg        VIN_last_value;
   reg        POWERDOWNB_ipd_last_value;
   reg        forceb_0;
   integer    res_post_resetc1;
   integer    fes_post_resetc1;
   integer    res_post_resetc0;
   integer    fes_post_resetc0;
   reg        COUT_CLKC_last_value;
   reg        WIN_last_value;
   reg        POWERDOWNC_ipd_last_value;
   reg        forcec_0;
   reg        internal_lock;
   time       fin_period;
   reg        locked_fin_last_value;
   time       extfbin_fin_drift;
   time       fin_last_re;
   reg        locked;
   reg        vco0_divu;
   reg        vco0_divv;
   reg        vco0_divw;
   wire       vco180;
   integer    locked_vco_edges;
   integer    CLKA_num_re_stable;
   integer    core_config;
   integer    core_config_last_value;
   reg        CLKA_ipd_last_value;
   time       CLKA_to_VCO0_delay;

   reg        fin;
   reg        CLKA_period_stable;

   wire       using_EXTFB;
   reg        EXTFB_delay_dtrmd;
   reg        calibrate_EXTFB_delay;
   reg        GLA_free_running;
   reg        AOUT_using_EXTFB;
   time       GLA_pw;
   time       GLA_EXTFB_rise_dly;
   time       GLA_EXTFB_fall_dly;
   time       EXTFB_CLKA_dly;
   time       EXTFB_period;
   time       EXTFB_re;
   reg        expected_EXTFB;
   wire       external_dly_correct;

   reg        OADIVRST_ipd_last_value;
   reg        OBDIVRST_ipd_last_value;
   reg        OCDIVRST_ipd_last_value;

   time       gla_muxed_delay;
   time       glb_muxed_delay;
   time       glc_muxed_delay;

   time       internal_fb_delay;
   time       external_fb_delay;
   time       normalized_fb_delay;

   time       CLKA_2_GLA_dly;
   time       CLKA_2_GLA_bypass0_dly;
   time       CLKA_2_GLA_bypass1_dly;
   time       CLKA_2_GLB_dly;
   time       CLKB_2_GLB_bypass0_dly;
   time       CLKB_2_GLB_bypass1_dly;
   time       CLKA_2_YB_dly;
   time       CLKB_2_YB_bypass1_dly;
   time       CLKA_2_GLC_dly;
   time       CLKC_2_GLC_bypass0_dly;
   time       CLKC_2_GLC_bypass1_dly;
   time       CLKA_2_YC_dly;
   time       CLKC_2_YC_bypass1_dly;
   time       CLKA_2_LOCK_dly;

   time       ngmux_delay;
   time       pre_NGMUX_dly;
   time       CLKA_2_NGMUX_dly;
   time       CLKC_2_NGMUX_dly;
   reg 	      tmp_gla;
   reg 	      tmp_glc;
   wire       ngmuxout;
   reg 	      GLA_to_ngmux;
   reg 	      GLC_to_ngmux;
   
   integer    fin_num_CLKA_re;
   time       EXTFB_CLKA_edge;
   time       num_freerun_edges;
   reg [2:0]  prev_OAMUX;
   reg [2:0]  prev_OBMUX;
   reg [2:0]  prev_OCMUX;
   
   time       GLA_period, GLA_fe, GLA_re;
   reg        GLA_period_stable;
   integer    GLA_num_stable;
   
   reg        CLKA_2_GLB;

   function time output_mux_delay;
      input [ 2 : 0 ] outmux;
      input time      fbdly_delay;
      input time      vco_pw;
      begin
	 case ( outmux )
           1       : output_mux_delay = IN_DELAY_BYP1;
           2       : output_mux_delay = MUX_DELAY + fbdly_delay;
           5       : output_mux_delay = MUX_DELAY + ( vco_pw / 2.0 );
           6       : output_mux_delay = MUX_DELAY + vco_pw;
           7       : output_mux_delay = MUX_DELAY + ( vco_pw * 1.5 );
           default : output_mux_delay = MUX_DELAY;
         endcase
      end
   endfunction


   function output_mux_driver;
      input [ 2 : 0 ] outmux;
      input           halved;
      input           bypass;
      input           bypass2x;
      input           vco;
      input           clka_2_gl;

      begin
	 case ( outmux )
           1  : if ( 1'b1 === halved )
             output_mux_driver = bypass2x;
           else if ( 1'b0 === halved )
             output_mux_driver = bypass;
           else
             output_mux_driver = 1'bx;
           2  : output_mux_driver = vco;
           3  : output_mux_driver = clka_2_gl;
           4  : output_mux_driver = vco;
           5  : output_mux_driver = vco;
           6  : output_mux_driver = vco;
           7  : output_mux_driver = vco;
           default : output_mux_driver = 1'bx;
	 endcase
      end
   endfunction
   
   // Interconnect Delays

   // The following buf instantiations needed to enable SDF back annotation of 
   // PORT delays

   buf U0 ( CLKA_ipd,      CLKA      );
   buf U1 ( CLKB_ipd,      CLKB      );
   buf U2 ( CLKC_ipd,      CLKC      );
   buf U3 ( POWERDOWN_ipd, POWERDOWN );
   buf U4 ( EXTFB_ipd,     EXTFB     );
   buf U5 ( GLMUXINT_ipd,  GLMUXINT  );
   buf U6 ( GLMUXSEL_ipd,  GLMUXSEL  );
  
   assign    # ( t_rise, t_fall ) OADIV_ipd[0]  = OADIV0;
   assign    # ( t_rise, t_fall ) OADIV_ipd[1]  = OADIV1;
   assign    # ( t_rise, t_fall ) OADIV_ipd[2]  = OADIV2;
   assign    # ( t_rise, t_fall ) OADIV_ipd[3]  = OADIV3;
   assign    # ( t_rise, t_fall ) OADIV_ipd[4]  = OADIV4;
   assign    # ( t_rise, t_fall ) OADIVHALF_ipd = OADIVHALF;
   assign    # ( t_rise, t_fall ) OAMUX_ipd[0]  = OAMUX0;
   assign    # ( t_rise, t_fall ) OAMUX_ipd[1]  = OAMUX1;
   assign    # ( t_rise, t_fall ) OAMUX_ipd[2]  = OAMUX2;
   assign    # ( t_rise, t_fall ) BYPASSA_ipd   = BYPASSA;
   assign    # ( t_rise, t_fall ) DLYGLA_ipd[0] = DLYGLA0;
   assign    # ( t_rise, t_fall ) DLYGLA_ipd[1] = DLYGLA1;
   assign    # ( t_rise, t_fall ) DLYGLA_ipd[2] = DLYGLA2;
   assign    # ( t_rise, t_fall ) DLYGLA_ipd[3] = DLYGLA3;
   assign    # ( t_rise, t_fall ) DLYGLA_ipd[4] = DLYGLA4;
   assign    # ( t_rise, t_fall ) DLYGLADSS_ipd[0] = DLYGLADSS0;
   assign    # ( t_rise, t_fall ) DLYGLADSS_ipd[1] = DLYGLADSS1;
   assign    # ( t_rise, t_fall ) DLYGLADSS_ipd[2] = DLYGLADSS2;
   assign    # ( t_rise, t_fall ) DLYGLADSS_ipd[3] = DLYGLADSS3;
   assign    # ( t_rise, t_fall ) DLYGLADSS_ipd[4] = DLYGLADSS4;
   assign    # ( t_rise, t_fall ) DLYGLACORE_ipd[0] = DLYGLACORE0;
   assign    # ( t_rise, t_fall ) DLYGLACORE_ipd[1] = DLYGLACORE1;
   assign    # ( t_rise, t_fall ) DLYGLACORE_ipd[2] = DLYGLACORE2;
   assign    # ( t_rise, t_fall ) DLYGLACORE_ipd[3] = DLYGLACORE3;
   assign    # ( t_rise, t_fall ) DLYGLACORE_ipd[4] = DLYGLACORE4;
   assign    # ( t_rise, t_fall ) OBDIV_ipd[0]  = OBDIV0;
   assign    # ( t_rise, t_fall ) OBDIV_ipd[1]  = OBDIV1;
   assign    # ( t_rise, t_fall ) OBDIV_ipd[2]  = OBDIV2;
   assign    # ( t_rise, t_fall ) OBDIV_ipd[3]  = OBDIV3;
   assign    # ( t_rise, t_fall ) OBDIV_ipd[4]  = OBDIV4;
   assign    # ( t_rise, t_fall ) OBDIVHALF_ipd = OBDIVHALF;
   assign    # ( t_rise, t_fall ) OBMUX_ipd[0]  = OBMUX0;
   assign    # ( t_rise, t_fall ) OBMUX_ipd[1]  = OBMUX1;
   assign    # ( t_rise, t_fall ) OBMUX_ipd[2]  = OBMUX2;
   assign    # ( t_rise, t_fall ) BYPASSB_ipd   = BYPASSB;
   assign    # ( t_rise, t_fall ) DLYGLB_ipd[0] = DLYGLB0;
   assign    # ( t_rise, t_fall ) DLYGLB_ipd[1] = DLYGLB1;
   assign    # ( t_rise, t_fall ) DLYGLB_ipd[2] = DLYGLB2;
   assign    # ( t_rise, t_fall ) DLYGLB_ipd[3] = DLYGLB3;
   assign    # ( t_rise, t_fall ) DLYGLB_ipd[4] = DLYGLB4;
   assign    # ( t_rise, t_fall ) OCDIV_ipd[0]  = OCDIV0;
   assign    # ( t_rise, t_fall ) OCDIV_ipd[1]  = OCDIV1;
   assign    # ( t_rise, t_fall ) OCDIV_ipd[2]  = OCDIV2;
   assign    # ( t_rise, t_fall ) OCDIV_ipd[3]  = OCDIV3;
   assign    # ( t_rise, t_fall ) OCDIV_ipd[4]  = OCDIV4;
   assign    # ( t_rise, t_fall ) OCDIVHALF_ipd = OCDIVHALF;
   assign    # ( t_rise, t_fall ) OCMUX_ipd[0]  = OCMUX0;
   assign    # ( t_rise, t_fall ) OCMUX_ipd[1]  = OCMUX1;
   assign    # ( t_rise, t_fall ) OCMUX_ipd[2]  = OCMUX2;
   assign    # ( t_rise, t_fall ) BYPASSC_ipd   = BYPASSC;
   assign    # ( t_rise, t_fall ) DLYGLC_ipd[0] = DLYGLC0;
   assign    # ( t_rise, t_fall ) DLYGLC_ipd[1] = DLYGLC1;
   assign    # ( t_rise, t_fall ) DLYGLC_ipd[2] = DLYGLC2;
   assign    # ( t_rise, t_fall ) DLYGLC_ipd[3] = DLYGLC3;
   assign    # ( t_rise, t_fall ) DLYGLC_ipd[4] = DLYGLC4;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[0] = FINDIV0;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[1] = FINDIV1;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[2] = FINDIV2;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[3] = FINDIV3;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[4] = FINDIV4;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[5] = FINDIV5;
   assign    # ( t_rise, t_fall ) FINDIV_ipd[6] = FINDIV6;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[0]  = FBDIV0;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[1]  = FBDIV1;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[2]  = FBDIV2;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[3]  = FBDIV3;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[4]  = FBDIV4;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[5]  = FBDIV5;
   assign    # ( t_rise, t_fall ) FBDIV_ipd[6]  = FBDIV6;
   assign    # ( t_rise, t_fall ) FBDLY_ipd[0]  = FBDLY0;
   assign    # ( t_rise, t_fall ) FBDLY_ipd[1]  = FBDLY1;
   assign    # ( t_rise, t_fall ) FBDLY_ipd[2]  = FBDLY2;
   assign    # ( t_rise, t_fall ) FBDLY_ipd[3]  = FBDLY3;
   assign    # ( t_rise, t_fall ) FBDLY_ipd[4]  = FBDLY4;
   assign    # ( t_rise, t_fall ) FBSEL_ipd[0]  = FBSEL0;
   assign    # ( t_rise, t_fall ) FBSEL_ipd[1]  = FBSEL1;
   assign    # ( t_rise, t_fall ) XDLYSEL_ipd   = XDLYSEL;
   assign    # ( t_rise, t_fall ) OADIVRST_ipd  = OADIVRST;
   assign    # ( t_rise, t_fall ) OBDIVRST_ipd  = OBDIVRST;
   assign    # ( t_rise, t_fall ) OCDIVRST_ipd  = OCDIVRST;

   assign # ( CLKA_2_LOCK_dly, 0 ) LOCK = locked;

   always @ ( fin_period or normalized_fb_delay or gla_muxed_delay or GLADELAY )
     begin
	CLKA_2_GLA_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			  fin_period - normalized_fb_delay +
			  gla_muxed_delay + OUT_UDIV_DELAY +
			  BYP_GLAMUX_DELAY + GLADELAY + GLA_DRVR_DELAY;
     end

   always @ ( GLADELAY )
     begin
	CLKA_2_GLA_bypass0_dly <= BYP0_CLK_GL + GLADELAY;
     end

   always @ ( gla_muxed_delay, GLADELAY )
     begin
	CLKA_2_GLA_bypass1_dly <= gla_muxed_delay + OUT_UDIV_DELAY +
				  BYP_GLAMUX_DELAY + GLADELAY + GLA_DRVR_DELAY;
     end

   always @(CLKA_2_GLA_bypass1_dly, CLKA_2_GLA_bypass0_dly, CLKA_2_GLA_dly,
	    OAMUX_ipd, BYPASSA_ipd)
     begin
	if ( ( 3'b000 === OAMUX_ipd ) && ( BYPASSA_ipd === 1'b1 ) )
	  CLKA_2_NGMUX_dly <= CLKA_2_GLA_bypass0_dly - GLA_DRVR_DELAY +
		       NGMUX_GLA;
	else if ( 3'b001 === OAMUX_ipd )
   	  CLKA_2_NGMUX_dly <= CLKA_2_GLA_bypass1_dly - GLA_DRVR_DELAY +
			   + NGMUX_GLA;
	else
	  CLKA_2_NGMUX_dly <= CLKA_2_GLA_dly - GLA_DRVR_DELAY +
			       + NGMUX_GLA;
     end   
   
   always @(CLKC_2_GLC_bypass1_dly, CLKC_2_GLC_bypass0_dly, CLKA_2_GLC_dly,
	    OCMUX_ipd, BYPASSC_ipd)
     begin
	if ( ( 3'b000 === OCMUX_ipd ) && ( BYPASSC_ipd === 1'b1 ) )
	  CLKC_2_NGMUX_dly <= CLKC_2_GLC_bypass0_dly - GLC_DRVR_DELAY +
		       NGMUX_GLC ;
	else if ( 3'b001 === OCMUX_ipd )
   	  CLKC_2_NGMUX_dly <= CLKC_2_GLC_bypass1_dly - GLC_DRVR_DELAY +
			  NGMUX_GLC;
	else
	  CLKC_2_NGMUX_dly <= CLKA_2_GLC_dly - GLC_DRVR_DELAY + NGMUX_GLC;
     end   

always @(CLKA_2_NGMUX_dly, CLKC_2_NGMUX_dly, GLMUXSEL_ipd, GLMUXCFG)
  begin
     pre_NGMUX_dly = (GLMUXSEL_ipd == 1'b0) ? CLKA_2_NGMUX_dly :
		     ((GLMUXCFG == 1'b0) ? CLKC_2_NGMUX_dly : NGMUX_GLMUXINT);  
  end   
       
   always @ ( fin_period or normalized_fb_delay or 
	      glb_muxed_delay or pre_NGMUX_dly or GLBDELAY or OBMUX_ipd)
     begin
	if ( OBMUX_ipd !== 3'b011 )
	  CLKA_2_GLB_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			 fin_period - normalized_fb_delay +
			 glb_muxed_delay + OUT_VDIV_DELAY +
			 BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;	
	else
	  CLKA_2_GLB_dly <=  glb_muxed_delay + OUT_VDIV_DELAY +
			    BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;	
	  /*
	   * if ( (OAMUX_ipd === 3'b000) && (BYPASSA_ipd === 1'b1) )
	    CLKA_2_GLB_dly <= BYP0_CLK_GL - GLA_DRVR_DELAY + GLADELAY +
			   glb_muxed_delay + OUT_VDIV_DELAY +
			   BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;
	  else if ( OAMUX_ipd === 3'b001 )
	    CLKA_2_GLB_dly <= gla_muxed_delay + OUT_UDIV_DELAY +
			       BYP_GLAMUX_DELAY + GLADELAY +
			       glb_muxed_delay + OUT_VDIV_DELAY +
			       BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;
	  else begin
	     CLKA_2_GLB_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			       fin_period - normalized_fb_delay +
			       gla_muxed_delay + OUT_UDIV_DELAY +
			       BYP_GLAMUX_DELAY + GLADELAY +
			       glb_muxed_delay + OUT_VDIV_DELAY +
			       BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;
	  end
	   */
     end
   
   always @ ( GLBDELAY )
     begin
	CLKB_2_GLB_bypass0_dly <= BYP0_CLK_GL + GLBDELAY;
     end

   always @ ( glb_muxed_delay or GLBDELAY )
     begin
	CLKB_2_GLB_bypass1_dly <= glb_muxed_delay + OUT_VDIV_DELAY +
				  BYP_GLBMUX_DELAY + GLBDELAY + GLB_DRVR_DELAY;
     end

   always @ ( fin_period or normalized_fb_delay or glb_muxed_delay )
     begin
	CLKA_2_YB_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			 fin_period - normalized_fb_delay +
			 glb_muxed_delay + OUT_VDIV_DELAY + Y_DRVR_DELAY;
     end

   always @ ( glb_muxed_delay )
     begin
	CLKB_2_YB_bypass1_dly  <= glb_muxed_delay + OUT_VDIV_DELAY +
				  Y_DRVR_DELAY;
     end

   always @ ( fin_period or normalized_fb_delay or glc_muxed_delay or GLCDELAY )
     begin
	CLKA_2_GLC_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			  fin_period - normalized_fb_delay +
			  glc_muxed_delay + OUT_WDIV_DELAY + BYP_GLCMUX_DELAY +
			  GLCDELAY + GLC_DRVR_DELAY;
     end

   always @ ( GLCDELAY )
     begin
	CLKC_2_GLC_bypass0_dly <= BYP0_CLK_GL + GLCDELAY;
     end

   always @ ( glc_muxed_delay or GLCDELAY )
     begin
	CLKC_2_GLC_bypass1_dly <= glc_muxed_delay + OUT_WDIV_DELAY +
				  BYP_GLCMUX_DELAY + GLCDELAY + GLC_DRVR_DELAY;
     end

   always @ ( fin_period or normalized_fb_delay or glc_muxed_delay )
     begin
	CLKA_2_YC_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			 fin_period - normalized_fb_delay +
			 glc_muxed_delay + OUT_WDIV_DELAY + Y_DRVR_DELAY;
     end

   always @ ( glc_muxed_delay )
     begin
	CLKC_2_YC_bypass1_dly <= glc_muxed_delay + OUT_WDIV_DELAY +
				 Y_DRVR_DELAY;
     end

   always @ ( fin_period or normalized_fb_delay )
     begin
	CLKA_2_LOCK_dly <= CLKA_TO_REF_DELAY + IN_DIV_DELAY +
			   fin_period - normalized_fb_delay + LOCK_OUT_DELAY;
     end

   //
   // Deskew
   //

   always @ ( XDLYSEL_ipd )
     begin

	if ( XDLYSEL_ipd === 1'b1 )
	  DTDELAY = EMULATED_SYSTEM_DELAY;
	else
	  DTDELAY = 0;

     end

   always @ ( FBDLY_ipd )
     begin
	FBDELAY <= ( FBDLY_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY;
     end

   always @ ( DLYGLB_ipd )
     begin
	GLBDELAY = ( DLYGLB_ipd == 0 ) ? INIT_DELAY :
		   ( ( DLYGLB_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
     end

   always @ ( DLYGLC_ipd )
     begin
	GLCDELAY = ( DLYGLC_ipd == 0 ) ? INIT_DELAY :
		   ( ( DLYGLC_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
     end

   always @ ( DLYGLA_ipd )
     begin
	GLADELAY = ( DLYGLA_ipd == 0 ) ? INIT_DELAY :
		   ( ( DLYGLA_ipd * PROG_STEP_INCREMENT ) + PROG_INIT_DELAY );
     end
   
   always @ ( DLYGLACORE_ipd )
     begin
	GLACOREDELAY = ( DLYGLACORE_ipd * PROG_STEP_INCREMENT ) +
		       PROG_INIT_DELAY ;
     end
   
   always @ ( DLYGLADSS_ipd )
     begin
	GLADSSDELAY = ( DLYGLADSS_ipd * PROG_STEP_INCREMENT ) +
		      PROG_INIT_DELAY ;
     end
   
   always @ ( FBDIV_ipd )
     begin
	DIVM = FBDIV_ipd + 1;
     end


   always @ ( FINDIV_ipd )
     begin
	DIVN <= FINDIV_ipd + 1;
     end

   always @ ( OADIV_ipd )
     begin
	DIVU <= OADIV_ipd + 1;
     end

   always @ ( OBDIV_ipd )
     begin
	DIVV <= OBDIV_ipd + 1;
     end

   always @ ( OCDIV_ipd )
     begin
	DIVW <= OCDIV_ipd + 1;
     end

   // Check OADIVHALF
   always @( OADIVHALF_ipd or DIVU or OAMUX_ipd )
     begin
	if ( 1'b1 === OADIVHALF_ipd ) begin
           if ( 3'b001 !== OAMUX_ipd ) begin
              $display( " ** Warning: Illegal configuration.  OADIVHALF can only be used when OAMUX = 001. OADIVHALF ignored.");
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveA <= 1'b0;
           end else if ( ( DIVU < 3 ) || ( DIVU > 29 ) ||
			 ( ( DIVU % 2 ) != 1 ) ) begin
              $display( " ** Warning: Illegal configuration. Only even OADIV values from 2 to 28 (inclusive) are allowed with OADIVHALF." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveA <= 1'bx;
           end else begin
              halveA <= 1'b1;
           end
	end else if ( 1'bx === OADIVHALF_ipd ) begin
           $display( " ** Warning: OADIVHALF unknown." );
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveA <= 1'bx;
	end else begin
           halveA <= 1'b0;
	end
     end

   // Check OBDIVHALF
   always @( OBDIVHALF_ipd or DIVV or OBMUX_ipd )
     begin
	if ( 1'b1 === OBDIVHALF_ipd ) begin
           if ( 3'b001 !== OBMUX_ipd ) begin
              $display( " ** Warning: Illegal configuration.  OBDIVHALF can only be used when OBMUX = 001. OBDIVHALF ignored.");
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveB <= 1'b0;
           end else if ( ( DIVV < 3 ) || ( DIVV > 29 ) ||
			 ( ( DIVV % 2 ) != 1 ) ) begin
              $display( " ** Warning: Illegal configuration. Only even OBDIV values from 2 to 28 (inclusive) are allowed with OBDIVHALF." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveB <= 1'bx;
           end else begin
              halveB <= 1'b1;
           end
	end else if ( 1'bx === OBDIVHALF_ipd ) begin
           $display( " ** Warning: OBDIVHALF unknown." );
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveB <= 1'bx;
	end else begin
           halveB <= 1'b0;
	end
     end

   // Check OCDIVHALF
   always @( OCDIVHALF_ipd or DIVW or OCMUX_ipd )
     begin
	if ( 1'b1 === OCDIVHALF_ipd ) begin
           if ( 3'b001 !== OCMUX_ipd ) begin
              $display( " ** Warning: Illegal configuration.  OCDIVHALF can only be used when OCMUX = 001. OCDIVHALF ignored.");
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveC <= 1'b0;
           end else if ( ( DIVW < 3 ) || ( DIVW > 29 ) ||
			 ( ( DIVW % 2 ) != 1 ) ) begin
              $display( " ** Warning: Illegal configuration. Only even OCDIV values from 2 to 28 (inclusive) are allowed with OCDIVHALF." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
              halveC <= 1'bx;
           end else begin
              halveC <= 1'b1;
           end
	end else if ( 1'bx === OCDIVHALF_ipd ) begin
           $display( " ** Warning: OCDIVHALF unknown." );
           $display( " Time: %0.1f Instance: %m ", $realtime );
           halveC <= 1'bx;
	end else begin
           halveC <= 1'b0;
	end
     end

   always @( OAMUX_ipd or FBDELAY or PLLCLK_pw )
     begin
	gla_muxed_delay <= output_mux_delay( OAMUX_ipd, FBDELAY, PLLCLK_pw );
     end

   always @( OBMUX_ipd or FBDELAY or PLLCLK_pw )
     begin
	glb_muxed_delay <= output_mux_delay( OBMUX_ipd, FBDELAY, PLLCLK_pw );
     end

   always @( OCMUX_ipd or FBDELAY or PLLCLK_pw )
     begin
	glc_muxed_delay <= output_mux_delay( OCMUX_ipd, FBDELAY, PLLCLK_pw );
     end

   // Get internal (not using external feedback pin) feeback delay
   always @( FBSEL_ipd or FBDELAY or DTDELAY or fin_period )
     begin
	if ( 2'b10 === FBSEL_ipd ) begin
           internal_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY +
		    FB_MUX_DELAY + FBDELAY;
	end else begin
           internal_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY +
				FB_MUX_DELAY;
	end
     end

   // Get external (using external feedback pin) feedback delay
   always @( DTDELAY or GLADELAY or gla_muxed_delay or GLA_EXTFB_rise_dly )
     begin
	/*
	 * if (FBSEL_ipd == 2'b11)
	  external_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY +
		       FB_MUX_DELAY + GLA_DRVR_DELAY + GLADELAY +
		       BYP_GLAMUX_DELAY + OUT_UDIV_DELAY +
		       gla_muxed_delay;    
	else
	 */
          external_fb_delay <= IN_DIV_DELAY + X_MUX_DELAY + DTDELAY +
			       FB_MUX_DELAY + GLA_DRVR_DELAY +
			       GLACOREDELAY + GLADELAY +
			       BYP_GLAMUX_DELAY + OUT_UDIV_DELAY +
			       gla_muxed_delay + GLA_EXTFB_rise_dly;
     end

   // Normalize appropriate feedback delay
   always @( using_EXTFB or internal_fb_delay or
	     external_fb_delay or fin_period )
     begin
	if ( 0 >= fin_period ) begin
           normalized_fb_delay <= 0;
	end else if ( using_EXTFB === 1'b1 ) begin
           normalized_fb_delay <= ( external_fb_delay > fin_period ) ?
				   ( external_fb_delay % fin_period ) :
				   external_fb_delay;
	end else begin
           normalized_fb_delay <= ( internal_fb_delay > fin_period ) ?
				  ( internal_fb_delay % fin_period ) :
				  internal_fb_delay;
	end
     end

   // Check FBSEL
   always @( FBSEL_ipd or OAMUX_ipd or OBMUX_ipd or OCMUX_ipd or
	     DIVM or DIVU or DIVN or CLKA_period_stable or
	     PLLCLK_period or external_fb_delay )
     begin
	if ( 1'bx === ^FBSEL_ipd ) begin
           FBSEL_illegal <= 1'b1;
           $display( " ** Warning: FBSEL is unknown." );
           $display( " Time: %0.1f Instance: %m ", $realtime );
	end else if ( (2'b11 === FBSEL_ipd) || (2'b00 === FBSEL_ipd) ) begin // External feedback
           if ( 2 >  OAMUX_ipd ) begin
              FBSEL_illegal <= 1'b1;
              $display( " ** Warning: Illegal configuration. GLA cannot be in bypass mode (OAMUX = 000 or OAMUX = 001) when using external feedback (FBSEL = 11)." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
           end else if ( DIVM < 5 ) begin
              FBSEL_illegal <= 1'b1;
              $display( " ** Error: FBDIV must be greater than 4 when using external feedback (FBSEL = 11)." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
           end else if ( ( DIVM * DIVU ) > 232 ) begin
              FBSEL_illegal <= 1'b1;
              $display( " ** Error: Product of FBDIV and OADIV must be less than 233 when using external feedback (FBSEL = 11)." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
           end else if ( ( DIVN % DIVU ) != 0 ) begin
              FBSEL_illegal <= 1'b1;
              $display( " ** Error: Division factor FINDIV must be a multiple of OADIV when using external feedback (FBSEL = 11)." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
           end else if ( ( 1'b1 === CLKA_period_stable ) &&
			 ( 1'b1 === EXTFB_delay_dtrmd ) &&
			 ( ( 1 < OBMUX_ipd ) || ( 1 < OCMUX_ipd ) ) &&
			 ( ( external_fb_delay >= CLKA_period ) ||
			   ( external_fb_delay >= PLLCLK_period ) ) ) begin
              FBSEL_illegal <= 1'b1;
              $display( " ** Error: Total sum of delays in the feedback path must be less than 1 VCO period AND less than 1 CLKA period when V and/or W dividers when using external feedback (FBSEL = 11)." );
              $display( " Time: %0.1f Instance: %m ", $realtime );
           end else begin
              FBSEL_illegal <= 1'b0;
           end
	end else begin
           FBSEL_illegal <= 1'b0;
	end
     end

   // Generate fin
   // Mimicing silicon - no need for a 50/50 duty cycle and this way fin only changes on rising edge of CLKA (except when DIVN is 1)
   // Uses prefix fin for registers used locally
   always @( CLKA_ipd )
     begin
	if ( 1'bx === CLKA_ipd ) begin
           fin_num_CLKA_re = -1;
	end else if ( 1 == DIVN ) begin
           fin = CLKA;
	end else if ( 1'b1 === CLKA_ipd ) begin
           fin_num_CLKA_re = fin_num_CLKA_re + 1;
           if ( 0 == ( fin_num_CLKA_re % DIVN  ) ) begin
              fin = 1'b1;
              fin_num_CLKA_re = 0;
           end else if ( 1 == ( fin_num_CLKA_re % DIVN  ) ) begin
              fin = 1'b0;
           end
	end
     end

   always @ ( normalized_fb_delay or DIVN or DIVM )
     begin
	core_config = core_config + 1;
     end

   // Calculate CLKA period and establish internal lock
   always @ ( CLKA_ipd or POWERDOWN_ipd or FBSEL_illegal or
	      core_config or locked_vco_edges or external_dly_correct )
     // locked_vco_edges is in the sensitivity list so that we periodically check for CLKA stopped.
     begin
	if ( ( POWERDOWN_ipd === 1'b1 ) && ( FBSEL_illegal === 1'b0 ) ) begin
	   if ( ( core_config != core_config_last_value ) ||
		( ( 1'b1 === using_EXTFB ) &&
		  ( 1'b1 !== external_dly_correct ) ) ) begin
              internal_lock <= 1'b0;
              CLKA_num_re_stable <= -1;
              core_config_last_value <= core_config;
	   end
	   if ( CLKA_ipd_last_value !== CLKA_ipd ) begin
              CLKA_ipd_last_value <= CLKA_ipd;
              if ( CLKA_ipd === 1'b1 ) begin
		 if ( CLKA_period != ( $time - CLKA_re ) ) begin
		    CLKA_period <= $time - CLKA_re;
		    CLKA_num_re_stable <= -1;
		    internal_lock <= 1'b0;
		    CLKA_period_stable <= 1'b0;
		 end else begin
		    if ( f_CLKA_LOCK > CLKA_num_re_stable ) begin
		       CLKA_num_re_stable <= CLKA_num_re_stable + 1;
		    end else if ( f_CLKA_LOCK == CLKA_num_re_stable ) begin
		       internal_lock <= 1'b1;
		    end
		    CLKA_period_stable <= 1'b1;
		 end
		 CLKA_re <= $time;
              end
	   end else if ( CLKA_period < ( $time - CLKA_re ) ) begin
              CLKA_num_re_stable <= -1;
              internal_lock <= 1'b0;
              CLKA_period_stable <= 1'b0;
	   end
	end else begin
	   CLKA_num_re_stable <= -1;
	   internal_lock <= 1'b0;
	   CLKA_period_stable <= 1'b0;
	end
     end

   always @( CLKA_period_stable or CLKA_period or DIVN )
     begin
	if ( CLKA_period_stable) begin
	   fin_period <= CLKA_period * ( DIVN * 1.0 );
	end
     end
   
   always @( GLA )
     begin
	if ( GLA === 1'b1 ) begin
	   GLA_re = $time;
	   if (GLA_period != (GLA_re - GLA_fe)) begin
              GLA_period <= GLA_re - GLA_fe;
              GLA_period_stable <= 1'b0;
              GLA_num_stable <= 0;
	   end
	   else begin
              GLA_num_stable <= GLA_num_stable + 1;
              if (GLA_num_stable == f_CLKA_LOCK)
		GLA_period_stable <= 1'b1;
	   end
	end else if (GLA === 1'b0) begin
	   GLA_fe = $time;
	   if (GLA_period != (GLA_fe - GLA_re)) begin
              GLA_period <= GLA_fe - GLA_re;
              GLA_period_stable <= 1'b0;
              GLA_num_stable <= 0;
	   end
	   else begin
              GLA_num_stable <= GLA_num_stable + 1;
              if (GLA_num_stable == f_CLKA_LOCK)
		GLA_period_stable <= 1'b1;
	   end
	end
     end

   always @( PLLCLK_pw or DIVU )
     begin
	GLA_pw <= PLLCLK_pw * ( DIVU * 1.0 );
     end

   always @( GLA_pw or DIVM or fin_period )
     begin
	extfbin_fin_drift <= ( GLA_pw * DIVM * 2.0 ) - fin_period;
     end

   always @( fin_period or fb_loop_div )
     begin
	PLLCLK_period <= fin_period / ( fb_loop_div * 1.0 );
	   PLLCLK_pw     <= fin_period / ( fb_loop_div * 2.0 );
     end

   // Calculate feedback loop divider
   always @( DIVM or DIVU or using_EXTFB )
     begin
	if ( 1'b1 === using_EXTFB ) begin
           fb_loop_div <= DIVM * DIVU; 
	end else begin
           fb_loop_div <= DIVM;
	end        
     end 

   // Generated locked
   // Uses prefix locked for internal registers
   always @( fin or internal_lock or DYNSYNC )
     begin
	if ( ( 1'b0 === internal_lock ) || ( 1'b1 === DYNSYNC ) ) begin
	   locked <= 1'b0;       
	end
	else if ( ( 1'b1 === fin ) &&
		  ( 1'b0 === locked_fin_last_value ) ) begin
	   locked <= 1'b1;
	end
	locked_fin_last_value <= fin;
     end

   // Use vco180 to count locked edges since it will have all edges delayed from locked by uniform PLLCLK_pw.
   // Initial edge count is set to 0 by locked rising (below).
   // Need inertial delay
   assign # PLLCLK_pw vco180 = ( locked === 1'b1 ) ? ~vco180 : 1'b0;

   always @ ( vco180 )
     begin
	if ( ( locked_vco_edges % ( DIVU * DIVV * DIVW * DIVM * 2 ) ) == 0 ) begin
	   locked_vco_edges <= 1;
	end else begin
	   locked_vco_edges <= locked_vco_edges + 1;
	end
     end

   always @ ( locked )
     begin
	if ( locked === 1'b1 ) begin
	   assign locked_vco_edges = 0;
	   deassign locked_vco_edges;
	end else begin
	   assign locked_vco_edges = -1;
	end
     end

   always @ ( locked_vco_edges )
     begin
	if ( locked_vco_edges == -1 ) begin
	   vco0_divu <= 1'b0;
	   vco0_divv <= 1'b0;
	   vco0_divw <= 1'b0;
	end else begin
	   if ( ( locked_vco_edges % DIVU ) == 0 ) begin
              vco0_divu <= ~vco0_divu;
	   end
	   if ( ( locked_vco_edges % DIVV ) == 0 ) begin
              vco0_divv <= ~vco0_divv;
	   end
	   if ( ( locked_vco_edges % DIVW ) == 0 ) begin
              vco0_divw <= ~vco0_divw;
	   end
	end
     end

   always @( OAMUX_ipd or BYPASSA_ipd or CLKA_ipd or
	     using_EXTFB or AOUT_using_EXTFB or AOUT )
     begin
	if (GLMUXSEL == 0) begin
	   if ((OAMUX_ipd === 3'b000) && (BYPASSA_ipd === 1'b1))
	     CLKA_2_GLB = CLKA_ipd;
	   else if ( OAMUX_ipd === 3'b011 )
	     CLKA_2_GLB = 1'bx;
	   else if ( using_EXTFB === 1'b1)
	     CLKA_2_GLB = AOUT_using_EXTFB;
	   else
	     CLKA_2_GLB = AOUT;
	end
	else
	  CLKA_2_GLB = vco0_divw;	
     end

   assign UIN = output_mux_driver(  OAMUX_ipd, halveA, CLKA_ipd,
				    CLKA2X, vco0_divu, 1'bx);
   assign VIN = output_mux_driver(  OBMUX_ipd, halveB, CLKB_ipd,
				    CLKB2X, vco0_divv, ngmuxout );
   assign WIN = output_mux_driver(  OCMUX_ipd, halveC, CLKC_ipd,
				    CLKC2X, vco0_divw, 1'bx);

   // Generate doubled CLKA
   // Uses prefix CLKA2X for internal registers
   always @( CLKA_ipd )
     begin
	if ( 1'b1 === CLKA_ipd ) begin
	   CLKA2X_CLKA_period = $time - CLKA2X_CLKA_re;
	   CLKA2X_CLKA_re = $time;
	   if ( CLKA2X_CLKA_period > 0 ) begin
              CLKA2X <= 1'b1;
              CLKA2X <= # ( CLKA2X_CLKA_period / 4.0 ) 1'b0;
              CLKA2X <= # ( CLKA2X_CLKA_period / 2.0 ) 1'b1;
              CLKA2X <= # ( CLKA2X_CLKA_period * 3.0 / 4.0 ) 1'b0;
	   end
	end
     end

   // Generate doubled CLKB
   // Uses prefix CLKB2X for internal registers
   always @( CLKB_ipd )
     begin
	if ( 1'b1 === CLKB_ipd ) begin
	   CLKB2X_CLKB_period = $time - CLKB2X_CLKB_re;
	   CLKB2X_CLKB_re = $time;
	   if ( CLKB2X_CLKB_period > 0 ) begin
              CLKB2X <= 1'b1;
              CLKB2X <= # ( CLKB2X_CLKB_period / 4.0 ) 1'b0;
              CLKB2X <= # ( CLKB2X_CLKB_period / 2.0 ) 1'b1;
              CLKB2X <= # ( CLKB2X_CLKB_period * 3.0 / 4.0 ) 1'b0;
	   end
	end
     end

   // Generate doubled CLKC
   // Uses prefix CLKC2X for internal registers
   always @( CLKC_ipd )
     begin
	if ( 1'b1 === CLKC_ipd ) begin
	   CLKC2X_CLKC_period = $time - CLKC2X_CLKC_re;
	   CLKC2X_CLKC_re = $time;
	   if ( CLKC2X_CLKC_period > 0 ) begin
              CLKC2X <= 1'b1;
              CLKC2X <= # ( CLKC2X_CLKC_period / 4.0 ) 1'b0;
              CLKC2X <= # ( CLKC2X_CLKC_period / 2.0 ) 1'b1;
              CLKC2X <= # ( CLKC2X_CLKC_period * 3.0 / 4.0 ) 1'b0;
	   end
	end
     end

   // AOUT Output of Divider U
   always @ ( UIN, CLKA_ipd, POWERDOWN_ipd, OADIVRST_ipd, OADIVHALF_ipd )
     begin
	
	if ( OAMUX_ipd === 3'b001 ) begin
	   
	   // PLL core bypassed.  

	   if ( CLKA_ipd !== AOUT_CLKA_last_value ) begin
              if ( ( CLKA_ipd === 1'b1 ) &&
		   ( AOUT_CLKA_last_value === 1'b0 ) ) begin
		 if ( 4 > res_post_reseta1 ) begin
		    res_post_reseta1 = res_post_reseta1 + 1;
		 end
		 if ( 4 > res_post_reseta0 ) begin
		    res_post_reseta0 = res_post_reseta0 + 1;
		 end
		 if ( res_post_reseta1 == 3 ) begin
		    forcea_0 = 1'b0;
		    A_num_edges = -1;
		 end
              end else if ( ( CLKA_ipd === 1'b0 ) &&
			    ( AOUT_CLKA_last_value === 1'b1 ) ) begin
		 if ( 4 > fes_post_reseta1 ) begin
		    fes_post_reseta1 = fes_post_reseta1 + 1;
		 end
		 if ( 4 > fes_post_reseta0 ) begin
		    fes_post_reseta0 = fes_post_reseta0 + 1;
		 end
		 if ( fes_post_reseta1 == 1 ) begin
		    forcea_0 = 1'b1;
		 end
              end
              AOUT_CLKA_last_value = CLKA;
	   end

	   if ( OADIVRST_ipd !== OADIVRST_ipd_last_value ) begin
              if ( OADIVRST_ipd === 1'b1 ) begin
		 if ( ( OADIVRST_ipd_last_value === 1'b0 ) &&
		      ( ( res_post_reseta0 < 1 ) ||
			( fes_post_reseta0 < 1 ) ) ) begin
		    $display( " ** Error: OADIVRST must be held low for at least one CLKA period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_reseta1 = 0;
		 fes_post_reseta1 = 0;
              end else if ( OADIVRST_ipd === 1'b0 ) begin
		 if ( ( OADIVRST_ipd_last_value === 1'b1 ) &&
		      ( ( res_post_reseta1 < 3 ) ||
			( fes_post_reseta1 < 3 ) ) ) begin
		    $display( " ** Error: OADIVRST must be held high for at least three CLKA periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_reseta0 = 0;
		 fes_post_reseta0 = 0;
              end else begin
		 $display( " ** Error: OADIVRST is unknown. Edge alignment unpredictable." );
		 $display( " Time: %0.1f Instance: %m ", $realtime );
              end
              OADIVRST_ipd_last_value = OADIVRST_ipd;
	   end
  	   
	   if ( UIN !== UIN_last_value ) begin
              A_num_edges = A_num_edges + 1;
              if ( forcea_0 === 1'b1 ) begin
		 AOUT <= 1'b0;
              end else if ( UIN === 1'bx ) begin
		 AOUT <= 1'bx;
              end else if ( ( A_num_edges % DIVU ) == 0 ) begin
		 if ( AOUT === 1'bx ) begin
		    AOUT <= UIN;
		 end else begin
		    AOUT <= !AOUT;
		 end
              end
	   end

	end else if ( ( UIN !== UIN_last_value ) ||
		      ( POWERDOWN_ipd !== POWERDOWNA_ipd_last_value ) ) begin
	   // PLL core not bypassed. 
	   if ( POWERDOWN_ipd === 1'b0 ) begin
              AOUT <= 1'b0;
	   end else if ( POWERDOWN_ipd === 1'b1 ) begin
              AOUT <= UIN;
	   end else begin // POWERDOWN unknown
              AOUT <= 1'bx;
	   end
	end

	if ( UIN !== UIN_last_value ) begin
	   UIN_last_value = UIN;
	end
	if ( POWERDOWN_ipd !== POWERDOWNA_ipd_last_value ) begin
	   POWERDOWNA_ipd_last_value = POWERDOWN_ipd;
	end
     end


   //
   // BOUT Output of Divider V
   //
   always @ ( VIN, CLKB_ipd, POWERDOWN_ipd, OBDIVRST_ipd, OBDIVHALF_ipd )
     begin
	if ( OBMUX_ipd === 3'b000 ) begin
	   BOUT <= 1'bx;
	end else if ( OBMUX_ipd === 3'b001 ) begin
	   // PLL core bypassed.  
	   if ( CLKB_ipd !== BOUT_CLKB_last_value ) begin
              if ( ( CLKB_ipd === 1'b1 ) &&
		   ( BOUT_CLKB_last_value === 1'b0 ) ) begin
		 if ( 4 > res_post_resetb1 ) begin
		    res_post_resetb1 = res_post_resetb1 + 1;
		 end
		 if ( 4 > res_post_resetb0 ) begin
		    res_post_resetb0 = res_post_resetb0 + 1;
		 end
		 if ( res_post_resetb1 == 3 ) begin
		    forceb_0 = 1'b0;
		    B_num_edges = -1;
		 end
              end else if ( ( CLKB_ipd === 1'b0 ) &&
			    ( BOUT_CLKB_last_value === 1'b1 ) ) begin
		 if ( 4 > fes_post_resetb1 ) begin
		    fes_post_resetb1 = fes_post_resetb1 + 1;
		 end
		 if ( 4 > fes_post_resetb0 ) begin
		    fes_post_resetb0 = fes_post_resetb0 + 1;
		 end
		 if ( fes_post_resetb1 == 1 ) begin
		    forceb_0 = 1'b1;
		 end
              end
              BOUT_CLKB_last_value = CLKB_ipd;
	   end

	   if ( OBDIVRST_ipd !== OBDIVRST_ipd_last_value ) begin
              if ( OBDIVRST_ipd === 1'b1 ) begin
		 if ( ( OBDIVRST_ipd_last_value === 1'b0 ) &&
		      ( ( res_post_resetb0 < 1 ) ||
			( fes_post_resetb0 < 1 ) ) ) begin
		    $display( " ** Error: OBDIVRST must be held low for at least one CLKB period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_resetb1 = 0;
		 fes_post_resetb1 = 0;
              end else if ( OBDIVRST_ipd === 1'b0 ) begin
		 if ( ( OBDIVRST_ipd_last_value === 1'b1 ) &&
		      ( ( res_post_resetb1 < 3 ) ||
			( fes_post_resetb1 < 3 ) ) ) begin
		    $display( " ** Error: OBDIVRST must be held high for at least three CLKB periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_resetb0 = 0;
		 fes_post_resetb0 = 0;
              end else begin
		 $display( " ** Error: OBDIVRST is unknown. Edge alignment unpredictable." );
		 $display( " Time: %0.1f Instance: %m ", $realtime );
              end
              OBDIVRST_ipd_last_value = OBDIVRST_ipd;
	   end
	   
	   if ( VIN !== VIN_last_value ) begin
              B_num_edges = B_num_edges + 1;
              if ( forceb_0 === 1'b1 ) begin
		 BOUT <= 1'b0;
              end else if ( VIN === 1'bx ) begin
		 BOUT <= 1'bx;
              end else if ( ( B_num_edges % DIVV ) == 0 ) begin
		 if ( BOUT === 1'bx ) begin
		    BOUT <= VIN;
		 end else begin
		    BOUT <= !BOUT;
		 end
              end
	   end
	end else if (OBMUX_ipd === 3'b011) begin
	   if ( VIN !== VIN_last_value ) begin
              if (B_num_edges == -1) begin
		 BOUT <= VIN;
		 if ( VIN_last_value === 1'b0)//start counting from posedge
		   B_num_edges = 0;
              end else begin
		 B_num_edges = B_num_edges + 1;
		 if ( VIN === 1'bx ) begin
		    BOUT <= 1'bx;
		 end else if ( ( B_num_edges % DIVV ) == 0 ) begin
		    if ( BOUT === 1'bx ) begin
		       BOUT <= VIN;
		    end else begin
		       BOUT <= !BOUT;
		    end
		 end else if ( (EXTFB_delay_dtrmd === 1'b0) &&
			       (using_EXTFB === 1'b1) )
		   BOUT <= VIN;
              end
	   end
	end else if ( ( VIN !== VIN_last_value ) ||
		      ( POWERDOWN_ipd !== POWERDOWNB_ipd_last_value ) ) begin
	   if ( POWERDOWN_ipd === 1'b0 ) begin
              BOUT <= 1'b0;
	   end else if ( POWERDOWN_ipd === 1'b1 ) begin
              BOUT <= VIN;
	   end else begin
              BOUT <= 1'bx;
	   end
	end

	if ( VIN !== VIN_last_value ) begin
	   VIN_last_value = VIN;
	end
	if ( POWERDOWN_ipd !== POWERDOWNB_ipd_last_value ) begin
	   POWERDOWNB_ipd_last_value = POWERDOWN_ipd;
	end
     end


   //
   // COUT Output of Divider W
   //

   always @ ( WIN, CLKC_ipd, POWERDOWN_ipd, OCDIVRST_ipd, OCDIVHALF_ipd )
     begin
	
	if ( OCMUX_ipd === 3'b000 ) begin
	   COUT <= 1'bx;
	end else if ( OCMUX_ipd === 3'b001 ) begin
	   
	   // PLL core bypassed. 
	   if ( CLKC_ipd !== COUT_CLKC_last_value ) begin
              if ( ( CLKC_ipd === 1'b1 ) &&
		   ( COUT_CLKC_last_value === 1'b0 ) ) begin
		 if ( 4 > res_post_resetc1 ) begin
		    res_post_resetc1 = res_post_resetc1 + 1;
		 end
		 if ( 4 > res_post_resetc0 ) begin
		    res_post_resetc0 = res_post_resetc0 + 1;
		 end
		 if ( res_post_resetc1 == 3 ) begin
		    forcec_0 = 1'b0;
		    C_num_edges = -1;
		 end
              end else if ( ( CLKC_ipd === 1'b0 ) &&
			    ( COUT_CLKC_last_value === 1'b1 ) ) begin
		 if ( 4 > fes_post_resetc1 ) begin
		    fes_post_resetc1 = fes_post_resetc1 + 1;
		 end
		 if ( 4 > fes_post_resetc0 ) begin
		    fes_post_resetc0 = fes_post_resetc0 + 1;
		 end
		 if ( fes_post_resetc1 == 1 ) begin
		    forcec_0 = 1'b1;
		 end
              end
              COUT_CLKC_last_value = CLKC_ipd;
	   end

	   if ( OCDIVRST_ipd !== OCDIVRST_ipd_last_value ) begin
              if ( OCDIVRST_ipd === 1'b1 ) begin
		 if ( ( OCDIVRST_ipd_last_value === 1'b0 ) &&
		      ( ( res_post_resetc0 < 1 ) ||
			( fes_post_resetc0 < 1 ) ) ) begin
		    $display( " ** Error: OCDIVRST must be held low for at least one CLKC period for the reset operation to work correctly: reset operation may not be successful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_resetc1 = 0;
		 fes_post_resetc1 = 0;
              end else if ( OCDIVRST_ipd === 1'b0 ) begin
		 if ( ( OCDIVRST_ipd_last_value === 1'b1 ) &&
		      ( ( res_post_resetc1 < 3 ) ||
			( fes_post_resetc1 < 3 ) ) ) begin
		    $display( " ** Error: OCDIVRST must be held high for at least three CLKC periods for the reset operation to work correctly: reset operation may not be succesful, edge alignment unpredictable" );
		    $display( " Time: %0.1f Instance: %m ", $realtime );
		 end
		 res_post_resetc0 = 0;
		 fes_post_resetc0 = 0;
              end else begin
		 $display( " ** Error: OCDIVRST is unknown. Edge alignment unpredictable." );
		 $display( " Time: %0.1f Instance: %m ", $realtime );
              end
              OCDIVRST_ipd_last_value = OCDIVRST_ipd;
	   end
	   
	   if ( WIN !== WIN_last_value ) begin
              C_num_edges = C_num_edges + 1;
              if ( forcec_0 === 1'b1 ) begin
		 COUT <= 1'b0;
              end else if ( WIN === 1'bx ) begin
		 COUT <= 1'bx;
              end else if ( ( C_num_edges % DIVW ) == 0 ) begin
		 if ( COUT === 1'bx ) begin
		    COUT <= WIN;
		 end else begin
		    COUT <= !COUT;
		 end
              end
	   end

	end else if ( ( WIN !== WIN_last_value ) ||
		      ( POWERDOWN_ipd !== POWERDOWNC_ipd_last_value ) ) begin
	   if ( POWERDOWN_ipd === 1'b0 ) begin
              COUT <= 1'b0;
	   end else if ( POWERDOWN_ipd === 1'b1 ) begin
              COUT <= WIN;
	   end else begin
              COUT <= 1'bx;
	   end
	end

	if ( WIN !== WIN_last_value ) begin
	   WIN_last_value = WIN;
	end
	if ( POWERDOWN_ipd !== POWERDOWNC_ipd_last_value ) begin
	   POWERDOWNC_ipd_last_value = POWERDOWN_ipd;
	end
	
     end

   assign using_EXTFB = ( FBSEL_ipd[1] ^~ FBSEL_ipd[0] );

   assign #1 external_dly_correct = expected_EXTFB ^~ EXTFB_ipd;

   // Get EXTFB period, rising edge, and falling edge
   always @( posedge EXTFB_ipd )
     begin
	EXTFB_period <= $time - EXTFB_re;
	EXTFB_re <= $time;
     end

   // Calculate EXTFB delay
   always
     begin
	EXTFB_delay_dtrmd = 1'b0;
	if ( ( 1'b1 !== using_EXTFB ) || ( 1'b1 !== CLKA_period_stable ) ) begin
	   wait ( ( 1'b1 === using_EXTFB ) && ( 1'b1 === CLKA_period_stable ) );
	end
	#GLA_EXTFB_rise_dly;
	GLA_EXTFB_fall_dly = 0;
	GLA_EXTFB_rise_dly = 0;
	EXTFB_CLKA_dly = 0;
	# ( CLKA_2_GLA_dly * 2 );
	calibrate_EXTFB_delay = 1'b1;

	if ( 1'b1 !== EXTFB_ipd ) begin
	   wait ( 1'b1 === EXTFB_ipd );
	end
	@ ( negedge CLKA_ipd );
	EXTFB_CLKA_edge = $time;
	calibrate_EXTFB_delay = 1'b0;
	    @ ( negedge EXTFB_ipd );
        GLA_EXTFB_fall_dly = $time - EXTFB_CLKA_edge - CLKA_2_GLA_dly
			     - GLACOREDELAY;
	@ ( posedge CLKA_ipd );
	EXTFB_CLKA_edge = $time;
	calibrate_EXTFB_delay = 1'b1;
	@ ( posedge EXTFB_ipd );
              GLA_EXTFB_rise_dly = $time - EXTFB_CLKA_edge - CLKA_2_GLA_dly
				   - GLACOREDELAY;
	@ ( posedge CLKA_ipd );
    wait ( 1'b1 === CLKA_period_stable );
	@ ( posedge fin );
	EXTFB_delay_dtrmd = 1'b1;
		
	/*
	 * if (FBSEL_ipd === 2'b11) begin
	   if ( 1'b1 !== GLA_period_stable ) begin
              wait ( 1'b1 === GLA_period_stable );
	   end
	   if (OBDIV_ipd === 5'b00000) begin
              @ ( posedge GLA );
              EXTFB_CLKA_edge = $time;
	   end else begin
              @ ( posedge GLB );
              EXTFB_CLKA_edge = $time;
	   end
	   @ ( posedge EXTFB_ipd );
	   GLA_EXTFB_rise_dly = $time - EXTFB_CLKA_edge;
	   
	   if (OBDIV_ipd === 5'b00000) begin
              @ ( negedge GLA );
	   end else begin
              @ ( negedge GLB );
	   end
	   EXTFB_CLKA_edge = $time;
	   @ ( negedge EXTFB_ipd );
	   GLA_EXTFB_fall_dly = $time - EXTFB_CLKA_edge;	   
	end
	 */
	
	
	@ ( negedge expected_EXTFB );
	if ( 1'b1 !== external_dly_correct ) begin
	   $display( " ** Error: EXTFB must be a simple, time-delayed derivative of CORE_CLK. Simulation cannot continue until user-logic is corrected" );
	   $display( " Time: %0.1f Instance: %m ", $realtime );
	   $finish;
	end
	wait ( 1'b1 !== external_dly_correct );
     end

   // Generate GLA directly from CLA, includes drift adjustment so everything syncs up when PLL is locked
   always @( GLA_free_running or EXTFB_delay_dtrmd )
     begin
	if ( EXTFB_delay_dtrmd ) begin
	   //if ( ( num_freerun_edges % ( DIVM * 2 ) ) == 0 ) begin
	   if ( num_freerun_edges == 0 ) begin
              GLA_free_running <= # ( GLA_pw - extfbin_fin_drift ) ~GLA_free_running;
              num_freerun_edges <= 0;
	   end else begin
              GLA_free_running <= # GLA_pw ~GLA_free_running;
	   end
	   num_freerun_edges <= num_freerun_edges + 1;
	end else begin
	   num_freerun_edges <= 1;
	   GLA_free_running <= # GLA_pw 1'b1;
	end
     end

   // Generate AOUT_using_EXTFB
   always @( AOUT or GLA_free_running or calibrate_EXTFB_delay or
	     locked_vco_edges or EXTFB_delay_dtrmd )
     begin
	if ( 1 <= locked_vco_edges ) begin
	   AOUT_using_EXTFB <= AOUT;
	end else if ( EXTFB_delay_dtrmd ) begin
	   AOUT_using_EXTFB <= GLA_free_running;
	end else begin
	   AOUT_using_EXTFB <= calibrate_EXTFB_delay;
	end
     end

   always @( GLA or EXTFB_delay_dtrmd )
     begin
	   if ( 1'b1 !== EXTFB_delay_dtrmd ) begin
              expected_EXTFB <= 1'bx;
	   end else if ( 1'b1 === GLA ) begin
              expected_EXTFB <= # GLA_EXTFB_rise_dly GLA;
	   end else begin
              expected_EXTFB <= # GLA_EXTFB_fall_dly GLA;
	   end
     end
   
   /*
    * always @( GLB or EXTFB_delay_dtrmd or OBDIV_ipd )
     begin
	if (OBDIV_ipd !== 5'b00000) begin
	   if ( 1'b1 !== EXTFB_delay_dtrmd ) begin
              expected_EXTFB <= 1'bx;
	   end else if ( 1'b1 === GLB ) begin
              expected_EXTFB <= # GLA_EXTFB_rise_dly GLB;
	   end else begin
              expected_EXTFB <= # GLA_EXTFB_fall_dly GLB;
	   end
	end
     end
    */

   always @(CLKA_ipd, OAMUX_ipd, BYPASSA_ipd, AOUT, AOUT_using_EXTFB)
     begin
	if ( ( 3'b000 === OAMUX_ipd ) && ( BYPASSA_ipd === 1'b1 ) )
	  tmp_gla <= CLKA_ipd;
	else if(using_EXTFB == 1'b1)
	  tmp_gla <= AOUT_using_EXTFB;
	else
	  tmp_gla <= AOUT;	
     end

   always @(CLKC_ipd, OCMUX_ipd, BYPASSC_ipd, COUT)
     begin
	if ( ( 3'b000 === OCMUX_ipd ) && ( BYPASSC_ipd === 1'b1 ) )
	  tmp_glc <= CLKC_ipd;
	else
	  tmp_glc <= COUT;
     end
   
//   wire ngmux_clk0 = tmp_gla;
   always @(tmp_gla)
	GLA_to_ngmux <= #(CLKA_2_NGMUX_dly) tmp_gla;

   always @(tmp_glc)
     GLC_to_ngmux <= #(CLKC_2_NGMUX_dly) tmp_glc;
   
   
//glmuxcfg[1:0]
   // 00 gla and glc
   // 01 gla and glmuxint
   wire ngmux_clk1 = GLMUXCFG ? GLMUXINT_ipd : GLC_to_ngmux;

   NGMUXPRIM NGMUX0 (
		     .GL   ( ngmuxout ),
		     .CLK0 ( GLA_to_ngmux ),
		     .CLK1 ( ngmux_clk1 ),
		     .S    ( GLMUXSEL )
		     );   
		      
   // GLA and GLADSS
   always @ ( AOUT or CLKA_ipd or AOUT_using_EXTFB or OAMUX_ipd )
     begin
	if ( ( 3'b000 === OAMUX_ipd ) || ( BYPASSA_ipd === 1'b1 ) ) begin
	   if ( ( 3'b000 === OAMUX_ipd ) && ( BYPASSA_ipd === 1'b1 ) ) begin
	   end
	   else if ($time > 0) begin
              $display( " ** Warning: For the bypass feature to be activated, both OAMUX and BYPASSA must be set to 000 and 1, respectively " );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else if ( 3'b011 === OAMUX_ipd ) begin
	   if ( OAMUX_ipd !== prev_OAMUX ) begin
              $display( " ** Warning: Illegal OAMUX configuration 011" );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end
	if ( OAMUX_ipd !== prev_OAMUX ) begin
	   prev_OAMUX <= OAMUX_ipd;
	end
     end

   always @(ngmuxout)
     begin
	GLA <= #( GLACOREDELAY + GLA_DRVR_DELAY) ngmuxout;
	GLADSS <= #( GLADSSDELAY + GLA_DRVR_DELAY) ngmuxout;
     end
   
/*
 ---------------------------------------------------------------
     always @ ( AOUT or CLKA_ipd or AOUT_using_EXTFB or OAMUX_ipd )
     begin
	if ( ( 3'b000 === OAMUX_ipd ) || ( BYPASSA_ipd === 1'b1 ) ) begin
	   if ( ( 3'b000 === OAMUX_ipd ) && ( BYPASSA_ipd === 1'b1 ) ) begin
              GLA <= # (CLKA_2_GLA_bypass0_dly + GLACOREDELAY) CLKA_ipd;
              GLADSS <= # (CLKA_2_GLA_bypass0_dly + GLADSSDELAY) CLKA_ipd;
              //GLA_to_ngmux <= # (CLKA_2_GLA_bypass0_dly - GLA_DRVR_DELAY) CLKA_ipd;
              A_num_edges <= -1;
	   end
	   else if ($time > 0) begin
              $display( " ** Warning: For the bypass feature to be activated, both OAMUX and BYPASSA must be set to 000 and 1, respectively " );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else if ( 3'b001 === OAMUX_ipd ) begin
	   //GLA <= # (CLKA_2_GLA_bypass1_dly + GLACOREDELAY) AOUT;
	   //GLADSS <= # (CLKA_2_GLA_bypass1_dly + GLADSSDELAY) AOUT;
	   GLA_to_ngmux <= # (CLKA_2_GLA_bypass1_dly - GLA_DRVR_DELAY) AOUT;
	end else if ( 3'b011 === OAMUX_ipd ) begin
	   //GLA <= # (CLKA_2_GLA_dly + GLACOREDELAY) 1'bx;
	   //GLADSS <= # (CLKA_2_GLA_dly + GLADSSDELAY) 1'bx;
	   GLA_to_ngmux <= # (CLKA_2_GLA_dly - GLA_DRVR_DELAY) 1'bx;
	   if ( OAMUX_ipd !== prev_OAMUX ) begin
              $display( " ** Warning: Illegal OAMUX configuration 011" );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else if ( 1'b1 === using_EXTFB ) begin
	   if ( OBDIV_ipd === 5'b00000 ) begin
              //GLA <= # (CLKA_2_GLA_dly) AOUT_using_EXTFB;
              //GLADSS <= # (CLKA_2_GLA_dly) AOUT_using_EXTFB;
              GLA_to_ngmux <= # (CLKA_2_GLA_dly - GLA_DRVR_DELAY) AOUT_using_EXTFB;
	   end else begin
              //GLA <= # (CLKA_2_GLA_dly + GLACOREDELAY) AOUT_using_EXTFB;
              //GLADSS <= # (CLKA_2_GLA_dly + GLACOREDELAY) AOUT_using_EXTFB;
              GLA_to_ngmux <= # (CLKA_2_GLA_dly - GLA_DRVR_DELAY) AOUT_using_EXTFB;
	   end
	end else begin
	   //GLA <= # (CLKA_2_GLA_dly + GLACOREDELAY) AOUT;
	   //GLADSS <= # (CLKA_2_GLA_dly + GLADSSDELAY) AOUT;
           GLA_to_ngmux <= # (CLKA_2_GLA_dly - GLA_DRVR_DELAY) AOUT;
	end
	if ( OAMUX_ipd !== prev_OAMUX ) begin
	   prev_OAMUX <= OAMUX_ipd;
	end
     end
--------------------------------------------------------------
  */
  
   // GLB and YB
   always @ ( BOUT or CLKB_ipd or OBMUX_ipd )
     begin
	if ( ( 3'b000 === OBMUX_ipd ) || ( BYPASSB_ipd === 1'b1 ) ) begin
	   if ( ( 3'b000 === OBMUX_ipd ) && ( BYPASSB_ipd === 1'b1 ) ) begin
              GLB <= # CLKB_2_GLB_bypass0_dly CLKB_ipd;
              YB  <= 1'bx;
              B_num_edges <= -1;
	   end
	   else if ($time > 0) begin
              $display( " ** Warning: For the bypass feature to be activated, both OBMUX and BYPASSB must be set to 000 and 1, respectively " );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else if ( 3'b001 === OBMUX_ipd ) begin
	   GLB <= # CLKB_2_GLB_bypass1_dly BOUT;
	   YB  <= # CLKB_2_YB_bypass1_dly  BOUT;
	end else begin
	   GLB <= # CLKA_2_GLB_dly BOUT;
	   YB  <= # CLKA_2_YB_dly  BOUT;
	end
	if ( OBMUX_ipd !== prev_OBMUX ) begin
	   prev_OBMUX <= OBMUX_ipd;
	end
     end

   // GLC and YC
   always @ ( COUT or CLKC_ipd or OCMUX_ipd )
     begin
	if ( ( 3'b000 === OCMUX_ipd ) || ( BYPASSC === 1'b1 )) begin
	   if ( ( 3'b000 === OCMUX_ipd ) && ( BYPASSC === 1'b1 )) begin
              GLC <= # CLKC_2_GLC_bypass0_dly CLKC_ipd;
              MACCLK <= # CLKC_2_GLC_bypass0_dly CLKC_ipd;
//	      GLC_to_ngmux <= #(CLKC_2_GLC_bypass0_dly - GLC_DRVR_DELAY) CLKC_ipd;
              YC  <= 1'bx;
              C_num_edges <= -1;
	   end
	   else if ($time > 0) begin
              $display( " ** Warning: For the bypass feature to be activated, both OCMUX and BYPASSC must be set to 000 and 1, respectively " );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else if ( 3'b001 === OCMUX_ipd ) begin
	   GLC <= # CLKC_2_GLC_bypass1_dly COUT;
	   MACCLK <= # CLKC_2_GLC_bypass1_dly COUT;
	    YC  <= # CLKC_2_YC_bypass1_dly  COUT;
//	    GLC_to_ngmux <= #(CLKC_2_GLC_bypass1_dly - GLC_DRVR_DELAY) CLKC_ipd;
	end else if ( 3'b011 === OCMUX_ipd ) begin
	   GLC <= # CLKA_2_GLC_dly 1'bx;
	   MACCLK <= # CLKA_2_GLC_dly 1'bx;
	   YC  <= # CLKA_2_YC_dly  1'bx;
//	    GLC_to_ngmux <= #(CLKA_2_GLC_dly - GLC_DRVR_DELAY) 1'bx;
	   if ( OCMUX_ipd !== prev_OCMUX ) begin
              $display( " ** Warning: Illegal OCMUX configuration 011" );
              $display( " Time: %0.1f Instance: %m ", $realtime );
	   end
	end else begin
	   GLC <= # CLKA_2_GLC_dly COUT;
	   MACCLK <= # CLKA_2_GLC_dly COUT;
	   YC  <= # CLKA_2_YC_dly  COUT;
//	   GLC_to_ngmux <= # (CLKA_2_GLC_dly - GLC_DRVR_DELAY) COUT;
	end
	if ( OCMUX_ipd !== prev_OCMUX ) begin
	   prev_OCMUX <= OCMUX_ipd;
	end
     end

   //
   // Initialization
   //

   initial
     begin
	
	PLLCLK = 1'bx;
	CLKA_re = 0;
	DTDELAY = 0;
	DelayVal1 = 0;
	DelayVal2 = 0;
	DelayVal3 = 0;
	DelayVal4 = 0;
	DelayVal5 = 0;
	DelayVal6 = 0;
	DIVN = 1;
	DIVM = 1;
	DIVU = 1;
	DIVV = 1;
	DIVW = 1;
	FBDELAY = 0;
	GLADELAY = 0;
	GLACOREDELAY = 0;
	GLADSSDELAY = 0;
	GLBDELAY = 0;
	GLCDELAY = 0;
	PLLDELAY = 0;
	DivVal = 0;
	DivVal1 = 0;
	DivVal2 = 0;
	DivVal3 = 0;
	DivVal4 = 0;
	CLKA_period = 0;
	AOUT = 1'bx;
	A_num_edges = -1;
	UIN_num_res = 0;
	UIN_num_fes = 0;
	BOUT = 1'bx;
	B_num_edges = -1;
	VIN_num_res = 0;
	VIN_num_fes = 0;
	COUT = 1'bx;
	C_num_edges = -1;
	WIN_num_res = 0;
	WIN_num_fes = 0;
	FBSEL_illegal = 0;
	UIN_re = 0;
	UIN_prev_re = 0;
	UIN_period = 0;
	VIN_re = 0;
	VIN_prev_re = 0;
	VIN_period = 0;
	WIN_re = 0;
	WIN_prev_re = 0;
	WIN_period = 0;

	RESET1 = 1'b1;
	RESET2 = 1'b1;
	RESET3 = 1'b1;

	res_post_reseta1          = 0;
	fes_post_reseta1          = 0;
	res_post_reseta0          = 0;
	fes_post_reseta0          = 0;
	AOUT_CLKA_last_value      = 1'bx;
	UIN_last_value            = 1'bx;
	POWERDOWNA_ipd_last_value = 1'bx;
	forcea_0                  = 1'b1;
	res_post_resetb1          = 0;
	fes_post_resetb1          = 0;
	res_post_resetb0          = 0;
	fes_post_resetb0          = 0;
	BOUT_CLKB_last_value      = 1'bx;
	VIN_last_value            = 1'bx;
	POWERDOWNB_ipd_last_value = 1'bx;
	forceb_0                  = 1'b1;
	res_post_resetc1          = 0;
	fes_post_resetc1          = 0;
	res_post_resetc0          = 0;
	fes_post_resetc0          = 0;
	COUT_CLKC_last_value      = 1'bx;
	WIN_last_value            = 1'bx;
	POWERDOWNC_ipd_last_value = 1'bx;
	forcec_0                  = 1'b1;
	PLLCLK_pw                 = 10000;
	PLLCLK_period             = 10000;
	internal_lock             = 1'b0;
	fin_period                = 0;
	fin_last_re               = 0;
	CLKA_num_re_stable        = -1;
	core_config               = 0;
	core_config_last_value    = -1;
	CLKA_ipd_last_value       = 1'bx;
	CLKA_to_VCO0_delay        = 0;
	locked_vco_edges          = -1;

	halveA                    = 1'bx;
	halveB                    = 1'bx;
	halveC                    = 1'bx;
	CLKA2X                    = 1'bx;
	CLKB2X                    = 1'bx;
	CLKC2X                    = 1'bx;
	CLKA2X_CLKA_re            = 0;
	CLKA2X_CLKA_period        = 0;
	CLKB2X_CLKB_re            = 0;
	CLKB2X_CLKB_period        = 0;
	CLKC2X_CLKC_re            = 0;
	CLKC2X_CLKC_period        = 0;
	fin                       = 1'b0;
	CLKA_period_stable        = 1'b0;
	EXTFB_delay_dtrmd         = 1'b0;
	calibrate_EXTFB_delay     = 1'b0;
	GLA_free_running          = 1'b1;
	AOUT_using_EXTFB          = 1'b1;
	GLA_pw                    = 10000;
	GLA_EXTFB_rise_dly        = 0;
	GLA_EXTFB_fall_dly        = 0;
	EXTFB_CLKA_dly            = 0;
	EXTFB_period              = 20000;
	EXTFB_re                  = 0;
	expected_EXTFB            = 1'bx;
	gla_muxed_delay           = 0;
	glb_muxed_delay           = 0;
	glc_muxed_delay           = 0;
	internal_fb_delay         = 0;
	external_fb_delay         = 0;
	normalized_fb_delay       = 0;
	CLKA_2_GLA_dly            = 0;
	CLKA_2_GLA_bypass0_dly    = 0;
	CLKA_2_GLA_bypass1_dly    = 0;
	CLKA_2_GLB_dly            = 0;
	CLKB_2_GLB_bypass0_dly    = 0;
	CLKB_2_GLB_bypass1_dly    = 0;
	CLKA_2_YB_dly             = 0;
	CLKB_2_YB_bypass1_dly     = 0;
	CLKA_2_GLC_dly            = 0;
	CLKC_2_GLC_bypass0_dly    = 0;
	CLKC_2_GLC_bypass1_dly    = 0;
	CLKA_2_YC_dly             = 0;
	CLKC_2_YC_bypass1_dly     = 0;
	fin_num_CLKA_re           = -1;
	extfbin_fin_drift         = 0;
	fb_loop_div               = 1;
	locked_fin_last_value     = 1'bx;
	EXTFB_CLKA_edge           = 0;
	num_freerun_edges         = 1;
	GLA_period_stable         = 1'b0;
	GLA_re                    = 0;
	GLA_fe                    = 0;
	GLA_num_stable            = 0;
	GLA_period                = 0;
	prev_OAMUX                = 1'bx;
	prev_OBMUX                = 1'bx;
	prev_OCMUX                = 1'bx;
	ngmux_delay               = 0;
	pre_NGMUX_dly             = 0;
	CLKA_2_NGMUX_dly          = 0;
	CLKC_2_NGMUX_dly          = 0;
     end

endmodule
//---- END MODULE PLLPRIM ----

//---- MODULE PLL ----
/*--------------------------------------------------------------------
 CELL NAME : PLL
 
--  9/10/04: Initial version of Fusion Static PLL.
-- 10/12/04: Updated with latest G3 changes.
--  1/31/05: Updated as per G3 PLL spec. rev. 31 updates.
--  2/08/05: Remove OBDIVHALF & OCDIVHALF.  Add OADIVRST.
--  3/10/05: Added VCOFREQUENCY parameter.
--  6/16/05: Use PLLPRIM as the underlying PLL primitive to support DYNPLL.

---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module PLL (
         CLKA,
         EXTFB,
         POWERDOWN,
         OADIVRST,
         OADIVHALF,
         OADIV0,
         OADIV1,
         OADIV2,
         OADIV3,
         OADIV4,
         OAMUX0,
         OAMUX1,
         OAMUX2,
         DLYGLA0,
         DLYGLA1,
         DLYGLA2,
         DLYGLA3,
         DLYGLA4,
         OBDIV0,
         OBDIV1,
         OBDIV2,
         OBDIV3,
         OBDIV4,
         OBMUX0,
         OBMUX1,
         OBMUX2,
         DLYYB0,
         DLYYB1,
         DLYYB2,
         DLYYB3,
         DLYYB4,
         DLYGLB0,
         DLYGLB1,
         DLYGLB2,
         DLYGLB3,
         DLYGLB4,
         OCDIV0,
         OCDIV1,
         OCDIV2,
         OCDIV3,
         OCDIV4,
         OCMUX0,
         OCMUX1,
         OCMUX2,
         DLYYC0,
         DLYYC1,
         DLYYC2,
         DLYYC3,
         DLYYC4,
         DLYGLC0,
         DLYGLC1,
         DLYGLC2,
         DLYGLC3,
         DLYGLC4,
         FINDIV0,
         FINDIV1,
         FINDIV2,
         FINDIV3,
         FINDIV4,
         FINDIV5,
         FINDIV6,
         FBDIV0,
         FBDIV1,
         FBDIV2,
         FBDIV3,
         FBDIV4,
         FBDIV5,
         FBDIV6,
         FBDLY0,
         FBDLY1,
         FBDLY2,
         FBDLY3,
         FBDLY4,
         FBSEL0,
         FBSEL1,
         XDLYSEL,
         VCOSEL0,
         VCOSEL1,
         VCOSEL2,
         GLA,
         LOCK,
         GLB,
         YB,
         GLC,
         YC
        );

  output GLA, LOCK, GLB, YB, GLC, YC;
  input  VCOSEL2, VCOSEL1, VCOSEL0, XDLYSEL, FBSEL1, FBSEL0; 
  input  FBDLY4, FBDLY3, FBDLY2, FBDLY1, FBDLY0;
  input  FBDIV6, FBDIV5, FBDIV4, FBDIV3;
  input  FBDIV2, FBDIV1, FBDIV0;
  input  FINDIV6, FINDIV5, FINDIV4, FINDIV3, FINDIV2, FINDIV1, FINDIV0;
  input  DLYGLC4, DLYGLC3, DLYGLC2, DLYGLC1, DLYGLC0;
  input  DLYYC4, DLYYC3, DLYYC2, DLYYC1, DLYYC0;
  input  OCMUX2, OCMUX1, OCMUX0, OCDIV4, OCDIV3, OCDIV2, OCDIV1, OCDIV0;
  input  DLYGLB4, DLYGLB3, DLYGLB2, DLYGLB1, DLYGLB0;
  input  DLYYB4, DLYYB3, DLYYB2, DLYYB1, DLYYB0;
  input  OBMUX2, OBMUX1, OBMUX0;
  input  OBDIV4, OBDIV3, OBDIV2, OBDIV1, OBDIV0;
  input  DLYGLA4, DLYGLA3, DLYGLA2, DLYGLA1, DLYGLA0;
  input  OAMUX2, OAMUX1, OAMUX0;
  input  OADIV4, OADIV3, OADIV2, OADIV1, OADIV0;
  input  OADIVHALF;
  input  OADIVRST;
  input  POWERDOWN, EXTFB, CLKA;

  parameter       VCOFREQUENCY   = 0.0;
  parameter       f_CLKA_LOCK    = 3;

  supply0 GND;
  wire    unused;
  wire    CLKA_ipd;
  wire    EXTFB_ipd;
  wire    POWERDOWN_ipd;

  buf    U0 ( CLKA_ipd, CLKA );
  buf    U1 ( EXTFB_ipd, EXTFB );
  buf    U2 ( POWERDOWN_ipd, POWERDOWN );

  defparam P1.VCOFREQUENCY = VCOFREQUENCY;
  defparam P1.f_CLKA_LOCK = f_CLKA_LOCK;
  
  PLLPRIM P1   (
                .DYNSYNC ( GND ),
                .CLKA ( CLKA_ipd ),
                .EXTFB ( EXTFB_ipd ),
                .POWERDOWN ( POWERDOWN_ipd ),
                .CLKB ( unused ),
                .CLKC ( unused ),
                .OADIVRST ( OADIVRST ),
                .OADIVHALF ( OADIVHALF ),
                .OADIV0 ( OADIV0 ),
                .OADIV1 ( OADIV1 ),
                .OADIV2 ( OADIV2 ),
                .OADIV3 ( OADIV3 ),
                .OADIV4 ( OADIV4 ),
                .OAMUX0 ( OAMUX0 ),
                .OAMUX1 ( OAMUX1 ),
                .OAMUX2 ( OAMUX2 ),
                .DLYGLA0 ( DLYGLA0 ),
                .DLYGLA1 ( DLYGLA1 ),
                .DLYGLA2 ( DLYGLA2 ),
                .DLYGLA3 ( DLYGLA3 ),
                .DLYGLA4 ( DLYGLA4 ),
                .OBDIVRST ( GND ),
                .OBDIVHALF ( GND ),
                .OBDIV0 ( OBDIV0 ),
                .OBDIV1 ( OBDIV1 ),
                .OBDIV2 ( OBDIV2 ),
                .OBDIV3 ( OBDIV3 ),
                .OBDIV4 ( OBDIV4 ),
                .OBMUX0 ( OBMUX0 ),
                .OBMUX1 ( OBMUX1 ),
                .OBMUX2 ( OBMUX2 ),
                .DLYYB0 ( DLYYB0 ),
                .DLYYB1 ( DLYYB1 ),
                .DLYYB2 ( DLYYB2 ),
                .DLYYB3 ( DLYYB3 ),
                .DLYYB4 ( DLYYB4 ),
                .DLYGLB0 ( DLYGLB0 ),
                .DLYGLB1 ( DLYGLB1 ),
                .DLYGLB2 ( DLYGLB2 ),
                .DLYGLB3 ( DLYGLB3 ),
                .DLYGLB4 ( DLYGLB4 ),
                .OCDIVRST ( GND ),
                .OCDIVHALF ( GND ),
                .OCDIV0 ( OCDIV0 ),
                .OCDIV1 ( OCDIV1 ),
                .OCDIV2 ( OCDIV2 ),
                .OCDIV3 ( OCDIV3 ),
                .OCDIV4 ( OCDIV4 ),
                .OCMUX0 ( OCMUX0 ),
                .OCMUX1 ( OCMUX1 ),
                .OCMUX2 ( OCMUX2 ),
                .DLYYC0 ( DLYYC0 ),
                .DLYYC1 ( DLYYC1 ),
                .DLYYC2 ( DLYYC2 ),
                .DLYYC3 ( DLYYC3 ),
                .DLYYC4 ( DLYYC4 ),
                .DLYGLC0 ( DLYGLC0 ),
                .DLYGLC1 ( DLYGLC1 ),
                .DLYGLC2 ( DLYGLC2 ),
                .DLYGLC3 ( DLYGLC3 ),
                .DLYGLC4 ( DLYGLC4 ),
                .FINDIV0 ( FINDIV0 ),
                .FINDIV1 ( FINDIV1 ),
                .FINDIV2 ( FINDIV2 ),
                .FINDIV3 ( FINDIV3 ),
                .FINDIV4 ( FINDIV4 ),
                .FINDIV5 ( FINDIV5 ),
                .FINDIV6 ( FINDIV6 ),
                .FBDIV0 ( FBDIV0 ),
                .FBDIV1 ( FBDIV1 ),
                .FBDIV2 ( FBDIV2 ),
                .FBDIV3 ( FBDIV3 ),
                .FBDIV4 ( FBDIV4 ),
                .FBDIV5 ( FBDIV5 ),
                .FBDIV6 ( FBDIV6 ),
                .FBDLY0 ( FBDLY0 ),
                .FBDLY1 ( FBDLY1 ),
                .FBDLY2 ( FBDLY2 ),
                .FBDLY3 ( FBDLY3 ),
                .FBDLY4 ( FBDLY4 ),
                .FBSEL0 ( FBSEL0 ),
                .FBSEL1 ( FBSEL1 ),
                .XDLYSEL ( XDLYSEL ),
                .VCOSEL0 ( VCOSEL0 ),
                .VCOSEL1 ( VCOSEL1 ),
                .VCOSEL2 ( VCOSEL2 ),
                .GLA ( GLA ),
                .LOCK ( LOCK ),
                .GLB ( GLB ),
                .YB ( YB ),
                .GLC ( GLC ),
                .YC ( YC )
             );

 specify

    // Timing paths for PLL related signals

    (CLKA      => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLA)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLB)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => GLC)  = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YB)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (POWERDOWN => YC)   = (0.00:0.00:0.00, 0.00:0.00:0.00);

    (CLKA      => LOCK) = (0.00:0.00:0.00, 0.00:0.00:0.00);

 endspecify

endmodule
//---- END MODULE PLL ----

//---- MODULE MSS_XTLOSC ----
/*--------------------------------------------------------------------
 CELL NAME : MSS_XTLOSC 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module MSS_XTLOSC 
  (
  XTL,
  CLKOUT
  );

  output CLKOUT;
  input  XTL;

  `define PW_limit_high 15625000
  `define PW_limit_low    25000

  wire XTL_int;
  reg  CLKOUT_int;
  reg  XTL_last_value = 1'bx;

  reg  chk_PW  = 1'b1;
  time PW;
  time XTL_last_change = 0;

  buf U0 ( XTL_int, XTL );
  buf U6 ( CLKOUT, CLKOUT_int );

  always @( XTL_int )
  begin
    PW = $time - XTL_last_change;
    if ( XTL_int === 1'bx )
    begin
      CLKOUT_int = 1'bx;
    end else if ( chk_PW === 1'b1 &&
                  ( ( PW > `PW_limit_high ) || ( PW < `PW_limit_low ) ) &&
                  ( XTL_last_change > 0 ) )
    begin
      CLKOUT_int = 1'b0;
      $display( "XTL frequency not within acceptable frequency range at time %10g", $realtime);
      $display( "XTL frequency should be between 32KHz and 20MHz");	
    end else
    begin
      CLKOUT_int = XTL_int;
    end
    XTL_last_change = $time;
    XTL_last_value = XTL_int;
  end

  specify

    specparam tpdLH_XTL_to_CLKOUT = ( 100 : 100 : 100 );
    specparam tpdHL_XTL_to_CLKOUT = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( XTL => CLKOUT ) = ( tpdLH_XTL_to_CLKOUT, tpdHL_XTL_to_CLKOUT );
  
  endspecify

endmodule
//---- END MODULE XTLOSC ----

//---- MODULE MSS_LPXTLOSC ----
/*--------------------------------------------------------------------
 CELL NAME : MSS_LPXTLOSC 
---------------------------------------------------------------------*/

`timescale 1 ps/1 ps

module MSS_LPXTLOSC 
  (
  LPXIN,
  CLKOUT
  );

  output CLKOUT;
  input  LPXIN;

  `define PW_limit 15625000

  wire LPXIN_int;
  reg  CLKOUT_int;
  reg  LPXIN_last_value = 1'bx;

  reg  chk_PW  = 1'b1;
  time PW;
  time LPXIN_last_change = 0;

  buf U0 ( LPXIN_int, LPXIN );
  buf U6 ( CLKOUT, CLKOUT_int );

  always @( LPXIN_int )
  begin
    PW = $time - LPXIN_last_change;
    if ( LPXIN_int === 1'bx )
    begin
      CLKOUT_int = 1'bx;
    end else if ( chk_PW === 1'b1 &&
                   ( PW != `PW_limit ) &&
                  ( LPXIN_last_change > 0 ) )
    begin
      CLKOUT_int = 1'b0;
      $display( "LPXIN frequency should be 32KHz");
      $display( "Time: %0.1f Instance: %m", $realtime);
    end else
    begin
      CLKOUT_int = LPXIN_int;
    end
    LPXIN_last_change = $time;
    LPXIN_last_value = LPXIN_int;
  end

  specify

    specparam tpdLH_LPXIN_to_CLKOUT = ( 100 : 100 : 100 );
    specparam tpdHL_LPXIN_to_CLKOUT = ( 100 : 100 : 100 );

    // pin to pin path delay

    ( LPXIN => CLKOUT ) = ( tpdLH_LPXIN_to_CLKOUT, tpdHL_LPXIN_to_CLKOUT );
  
  endspecify

endmodule
//---- END MODULE MSS_LPXTLOSC ----

//---- MODULE SHREG ----
//------------------------
// CELL NAME: SHREG
//------------------------

`timescale 1 ps / 1 ps

module SHREG (
              SDOUT,
              SUPDATELATCH,
              SDIN,
              SCLK,
              SSHIFT,	
              SUPDATE	
       	     );

input	SDIN;    // Serial data input.  Applies data to a 88-bit shift register.
input	SCLK;    // Serial Clock signal for the shift register.
input	SSHIFT;  // Serial shift enable signal for the shift register.
input	SUPDATE; // Load data from the shift register into the update latch.
output	SDOUT;   // Serial data output.  Data from LSB of the shift register is shifted out.
output  [ 88 : 0 ] SUPDATELATCH;

reg	[ 88 : 0 ] SH_REG;       // 89-bit shift register
reg	[ 88 : 0 ] SUPDATELATCH; // 89-bit latch
reg	SDOUT;


always @ ( posedge SCLK )
  begin
    if ( SSHIFT ) begin
      // Serial input data enters through the MSB of the shift register 
      SH_REG [ 88 : 0 ] <= { SDIN, SH_REG [ 88 : 1 ] }; 
      // Serial output data comes from the LSB of the shift register
      SDOUT <= SH_REG [ 0 ]; 
      // SDOUT gets the LSB value after one SCLK delay
    end else
      SH_REG [ 88 : 0 ] <= SH_REG [ 88 : 0 ];
  end	


always @ ( SUPDATE or SH_REG )
  begin
    if ( SUPDATE )
      // SUPDATE latch gets SH_REG value with one SCLK delay
      SUPDATELATCH [ 88 : 0 ] <= SH_REG [ 88 : 0 ]; 
    else
      SUPDATELATCH [ 88 : 0 ] <= SUPDATELATCH [ 88 : 0 ];
  end
endmodule
//---- END MODULE SHREG ----

`timescale 1ns/1ps

  module MSS_CCC (
		  CLKA,
		  EXTFB,
		  GLA,
		  GLAMSS,
		  LOCK,
		  LOCKMSS,
		  CLKB,
		  GLB,
		  YB,
		  CLKC,
		  GLC,
		  YC,
		  MACCLK,
		  OADIV,
		  OADIVHALF,
		  OAMUX,
		  BYPASSA,
		  DLYGLA,
		  DLYGLAMSS,
		  DLYGLAFAB,
		  OBDIV,
		  OBDIVHALF,
		  OBMUX,
		  BYPASSB,
		  DLYGLB,
		  OCDIV,
		  OCDIVHALF,
		  OCMUX,
		  BYPASSC,
		  DLYGLC,
		  FINDIV,
		  FBDIV,
		  FBDLY,
		  FBSEL,
		  XDLYSEL,
		  GLMUXSEL,
		  GLMUXCFG
		  );

  output       GLA;
  output       GLAMSS;
  output       LOCK;
  output       LOCKMSS;
  output       GLB;
  output       YB;
  output       GLC;
  output       YC;
  output       MACCLK;
  
  input  [1:0] GLMUXCFG;
  input  [1:0] GLMUXSEL;
  input        XDLYSEL;
  input  [1:0] FBSEL;
  input  [4:0] FBDLY;
  input  [6:0] FBDIV;
  input  [6:0] FINDIV;
  
  input  [4:0] DLYGLC;
  input        BYPASSC;
  input  [2:0] OCMUX;
  input        OCDIVHALF;
  input  [4:0] OCDIV;
  
  input  [4:0] DLYGLB;
  input        BYPASSB;
  input  [2:0] OBMUX;
  input        OBDIVHALF;
  input  [4:0] OBDIV;
  
  input  [4:0] DLYGLA;
  input  [4:0] DLYGLAMSS;
  input  [4:0] DLYGLAFAB;
  input  [2:0] OAMUX;
  input        BYPASSA ;
  input  [4:0] OADIV;
  input        OADIVHALF;
  
  input        CLKA;
  input        CLKB;
  input        CLKC;
  input        EXTFB;

   parameter   VCOFREQUENCY = 0.0;
   parameter   f_CLKA_LOCK  = 3;      // Number of CLKA cycles to wait before raising LOCK
   parameter   CLKA_TO_REF_DELAY   =  0;
   parameter   EMULATED_SYSTEM_DELAY = 0;
   parameter   IN_DIV_DELAY   =  0; // Input dividers intrinsic delay
  //parameter    OUT_DIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_UDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_VDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_WDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   MUX_DELAY      = 0; // MUXA/MUXB/MUXC intrinsic delay
   parameter   IN_DELAY_BYP1  = 0; // Instrinsic delay for CLKDIVDLY bypass mode
  //parameter    BYP_MUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLAMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLBMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLCMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
  //parameter    GL_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLA_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLB_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLC_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   Y_DRVR_DELAY   =  0; // Y Driver intrinsic delay
   parameter   FB_MUX_DELAY   =  0; // FBSEL MUX intrinsic delay
   parameter   BYP0_CLK_GL    =  0; // Instrinsic delay for CLKDLY bypass mode
   parameter   X_MUX_DELAY    =  0; // XDLYSEL MUX intrinsic delay
   parameter   FIN_LOCK_DELAY = 0; // FIN to LOCK propagation delay
   parameter   LOCK_OUT_DELAY = 0; // LOCK to OUT propagation delay
   parameter   t_rise = 0;
   parameter   t_fall = 0;
   parameter   PROG_STEP_INCREMENT  = 0;
   parameter   PROG_INIT_DELAY      = 0;
   parameter   INIT_DELAY      = 0;
   parameter 	  NGMUX_GLA = 0; //GLA -> NGMUXOUT delay
   parameter 	  NGMUX_GLC = 0; // GLC -> NGMUXOUT delay
   parameter 	  NGMUX_GLMUXINT = 0; //GLMUXINT -> NGMUXOUT delay    

   reg 	       NOTIFY_REG;

  wire EXTFB;

  
  wire [4:0] DLYYB;
  wire [4:0] DLYYC;
  
  
   MSS_CCC_IP    #(.VCOFREQUENCY(VCOFREQUENCY),
		   .f_CLKA_LOCK(f_CLKA_LOCK),
		   .CLKA_TO_REF_DELAY(CLKA_TO_REF_DELAY),
		   .EMULATED_SYSTEM_DELAY(EMULATED_SYSTEM_DELAY),
		   .IN_DIV_DELAY(IN_DIV_DELAY),
		   //.OUT_DIV_DELAY(OUT_DIV_DELAY),
		   .OUT_UDIV_DELAY(OUT_UDIV_DELAY),
		   .OUT_VDIV_DELAY(OUT_VDIV_DELAY),
		   .OUT_WDIV_DELAY(OUT_WDIV_DELAY),
		   .MUX_DELAY(MUX_DELAY),
		   .IN_DELAY_BYP1(IN_DELAY_BYP1),
		   //.BYP_MUX_DELAY(BYP_MUX_DELAY),
		   .BYP_GLAMUX_DELAY(BYP_GLAMUX_DELAY),
		   .BYP_GLBMUX_DELAY(BYP_GLBMUX_DELAY),
		   .BYP_GLCMUX_DELAY(BYP_GLCMUX_DELAY),
		   //.GL_DRVR_DELAY(GL_DRVR_DELAY),
		   .GLA_DRVR_DELAY(GLA_DRVR_DELAY),
		   .GLB_DRVR_DELAY(GLB_DRVR_DELAY),
		   .GLC_DRVR_DELAY(GLC_DRVR_DELAY),
		   .Y_DRVR_DELAY(Y_DRVR_DELAY),
		   .FB_MUX_DELAY(FB_MUX_DELAY),
		   .BYP0_CLK_GL(BYP0_CLK_GL),
		   .X_MUX_DELAY(X_MUX_DELAY),
		   .FIN_LOCK_DELAY(FIN_LOCK_DELAY),
		   .LOCK_OUT_DELAY(LOCK_OUT_DELAY),
		   .PROG_STEP_INCREMENT(PROG_STEP_INCREMENT),
		   .PROG_INIT_DELAY(PROG_INIT_DELAY),
		   .INIT_DELAY(INIT_DELAY),
		   .NGMUX_GLA(NGMUX_GLA),
		   .NGMUX_GLC(NGMUX_GLC),
		   .NGMUX_GLMUXINT(NGMUX_GLMUXINT))
		  
   CCCP1 (
	  .CLKA      ( CLKA ),
	  .EXTFB     ( EXTFB ),
	  .PLLEN     ( 1'b1 ),
	  .CLKB      ( CLKB ),
	  .CLKC      ( CLKC ),
	  .OADIVRST  ( 1'b0  ),
	  .OBDIVRST  ( 1'b0  ),
	  .OCDIVRST  ( 1'b0  ),
	  .OADIV     ( OADIV ),
	  .OAMUX     ( OAMUX ),
	  .BYPASSA   ( BYPASSA ),
	  .DLYGLA    ( DLYGLA ),
	  .DLYGLAMSS ( DLYGLAMSS  ),
	  .DLYGLAFAB ( DLYGLAFAB  ),
	  .OBDIV     ( OBDIV  ),
	  .OBMUX     ( OBMUX  ),
	  .BYPASSB   ( BYPASSB ),
	  .DLYGLB    ( DLYGLB  ),
	  .OCDIV     ( OCDIV  ),
	  .OCMUX     ( OCMUX  ),
	  .BYPASSC   ( BYPASSC ),
	  .DLYGLC    ( DLYGLC  ),
	  .FINDIV    ( FINDIV  ),
	  .FBDIV     ( FBDIV  ),
	  .FBDLY     ( FBDLY  ),
	  .FBSEL     ( FBSEL  ),
	  .XDLYSEL   ( XDLYSEL ),
	  .OADIVHALF ( OADIVHALF ),
	  .OBDIVHALF ( OBDIVHALF ),
	  .OCDIVHALF ( OCDIVHALF ),
	  .GLMUXSEL  ( GLMUXSEL),
	  .GLMUXCFG  ( GLMUXCFG),
	  .GLMUXINT  ( 1'b0 ),
	  .SDIN      ( 1'b0 ),
	  .SCLK      ( 1'b0 ),
	  .SSHIFT    ( 1'b0 ),
	  .SUPDATE   ( 1'b0 ),
	  .MODE      ( 1'b0 ),
	  .GLA       ( GLA_int ),
	  .GLAMSS    ( GLAMSS_int ),
	  .LOCK      ( LOCK_int ),
	  .LOCKMSS   ( LOCKMSS_int ),
	  .GLB       ( GLB_int  ),
	  .YB        ( YB_int   ),
	  .GLC       ( GLC_int  ),
	  .MACCLK    ( MACCLK_int ),
	  .YC        ( YC_int   ),
	  .SDOUT     (),
	  .VCOSEL    ( 3'b0 )
	  );
  
  buf #0.1 bufgla( GLA, GLA_int);
  buf #0.1 bufglamss( GLAMSS, GLAMSS_int);
  buf #0.1 bufLOCK( LOCK, LOCK_int);
  buf #0.1 bufLOCKMSS( LOCKMSS, LOCKMSS_int);
  buf #0.1 bufGLB( GLB, GLB_int);
  buf #0.1 bufYB( YB, YB_int);
  buf #0.1 bufGLC( GLC, GLC_int);
  buf #0.1 bufYC( YC, YC_int);
  buf #0.1 bufMACCLK( MACCLK, MACCLK_int);
  
endmodule  

`timescale 1ns/1ps

module MSS_CCC_IP (
		   CLKA,
		   EXTFB,
		   PLLEN,		   
		   GLA,
		   GLAMSS,
		   LOCK,
		   LOCKMSS,
		   CLKB,
		   GLB,
		   YB,
		   CLKC,
		   GLC,
		   YC,
		   MACCLK,
		   OADIV,
		   OADIVHALF,
		   OADIVRST,
		   OAMUX,
		   SDIN,
		   SCLK,
		   SSHIFT,
		   SUPDATE,
		   MODE,
		   BYPASSA,
		   DLYGLA,
		   DLYGLAMSS,
		   DLYGLAFAB,
		   OBDIV,
		   OBDIVHALF,
		   OBDIVRST,
		   OBMUX,
		   BYPASSB,
		   DLYGLB,
		   OCDIV,
		   OCDIVHALF,
		   OCDIVRST,
		   OCMUX,
		   BYPASSC,
		   DLYGLC,
		   FINDIV,
		   FBDIV,
		   FBDLY,
		   FBSEL,
		   XDLYSEL,
		   GLMUXINT,
		   GLMUXSEL,
		   GLMUXCFG,
		   SDOUT,
		   VCOSEL
		   );

   output       GLA;
   output 	GLAMSS;
   output 	LOCK;
   output 	LOCKMSS;
   output 	GLB;
   output 	YB;
   output 	GLC;
   output 	YC;
   output 	MACCLK;
   output 	SDOUT;
  
   input 	GLMUXINT;
   input [1:0] 	GLMUXCFG;
   input [1:0] 	GLMUXSEL;
   input 	XDLYSEL;
   input [1:0] 	FBSEL;
   input [4:0] 	FBDLY;
   input [6:0] 	FBDIV;
   input [6:0] 	FINDIV;
  
   input [4:0] 	DLYGLC;
   input 	BYPASSC;
   input [2:0] 	OCMUX;
   input 	OCDIVHALF;
   input [4:0] 	OCDIV;
   input 	OCDIVRST;
  
   input [4:0] 	DLYGLB;
   input 	BYPASSB;
   input [2:0] 	OBMUX;
   input 	OBDIVHALF;
   input [4:0] 	OBDIV;
   input 	OBDIVRST;
  
   input [4:0] 	DLYGLA;
   input [4:0] 	DLYGLAMSS;
   input [4:0] 	DLYGLAFAB;
   input [2:0] 	OAMUX;
   input 	BYPASSA ;
   input [4:0] 	OADIV;
   input 	OADIVHALF;
   input 	OADIVRST;
  
   input 	CLKA;
   input 	CLKB;
   input 	CLKC;
   input 	EXTFB;
   input 	PLLEN;
   input 	SDIN;
   input 	SCLK;
   input 	SSHIFT;
   input 	SUPDATE;
   input 	MODE;

   input [2:0] 	VCOSEL;
  
  parameter VCOFREQUENCY = 0.0;
  parameter f_CLKA_LOCK  = 3;      // Number of CLKA cycles to wait before raising LOCK
  parameter       CLKA_TO_REF_DELAY   =  147;
  parameter       EMULATED_SYSTEM_DELAY = 2028;
  parameter       IN_DIV_DELAY   =  266; // Input dividers intrinsic delay
//  parameter       OUT_DIV_DELAY  =  770; // Output dividers intrinsic delay
  parameter       OUT_UDIV_DELAY  =  662; // Output dividers intrinsic delay
  parameter       OUT_VDIV_DELAY  =  887; // Output dividers intrinsic delay
  parameter       OUT_WDIV_DELAY  =  887; // Output dividers intrinsic delay
  parameter       MUX_DELAY      = 500; // MUXA/MUXB/MUXC intrinsic delay
  parameter       IN_DELAY_BYP1  = 647; // Instrinsic delay for CLKDIVDLY bypass mode
//  parameter       BYP_MUX_DELAY  =   40; // Bypass MUX intrinsic delay, not used for Ys
  parameter       BYP_GLAMUX_DELAY  =   20; // Bypass MUX intrinsic delay, not used for Ys
  parameter       BYP_GLBMUX_DELAY  =   30; // Bypass MUX intrinsic delay, not used for Ys
  parameter       BYP_GLCMUX_DELAY  =   30; // Bypass MUX intrinsic delay, not used for Ys
//  parameter       GL_DRVR_DELAY  =   60; // Global Driver intrinsic delay
  parameter       GLA_DRVR_DELAY  =   35; // Global Driver intrinsic delay
  parameter       GLB_DRVR_DELAY  =   47; // Global Driver intrinsic delay
  parameter       GLC_DRVR_DELAY  =   47; // Global Driver intrinsic delay
  parameter       Y_DRVR_DELAY   =  0; // Y Driver intrinsic delay
  parameter       FB_MUX_DELAY   =  125; // FBSEL MUX intrinsic delay
  parameter       BYP0_CLK_GL    =  202; // Instrinsic delay for CLKDLY bypass mode
  parameter       X_MUX_DELAY    =  528; // XDLYSEL MUX intrinsic delay
   parameter 	  FIN_LOCK_DELAY = 300; // FIN to LOCK propagation delay
   parameter 	  LOCK_OUT_DELAY = 120; // LOCK to OUT propagation delay
   parameter 	  t_rise = 0;
   parameter 	  t_fall = 0;
   parameter 	  PROG_STEP_INCREMENT  = 200;
   parameter 	  PROG_INIT_DELAY      = 535;
  //for GLA, GLB and GLC initial delay is 65ps
  //0     65 ps
  //1     735 ps
  //2     935 ps
  //......
  //31    6735 ps
   parameter 	  INIT_DELAY      = 65;
  
   parameter 	  NGMUX_GLA = 0; //GLA -> NGMUXOUT delay
   parameter 	  NGMUX_GLC = 30; // GLC -> NGMUXOUT delay
   parameter 	  NGMUX_GLMUXINT = 27; //GLMUXINT -> NGMUXOUT delay    
  
   reg 		  NOTIFY_REG;

   wire 	  CLKA_ipd;
   wire 	  CLKB_ipd;
   wire 	  CLKC_ipd;
   wire 	  EXTFB;
   wire 	  pll_lock;
   wire 	  OADIVRST_ipd;
   wire 	  OBDIVRST_ipd;
   wire 	  OCDIVRST_ipd;
   wire 	  SDIN_ipd;
   wire 	  SCLK_ipd;
   wire 	  SSHIFT_ipd;
   wire 	  SUPDATE_ipd;
   wire 	  MODE_ipd;

  // Unused configuration bits
   wire 	  GLMUXCFG1;
   wire 	  GLMUXCFG0;
   wire 	  RXCSEL;
   wire 	  RXBSEL;
   wire 	  RXASEL;
   wire 	  DYNCSEL;
   wire 	  DYNBSEL;
   wire 	  DYNASEL;
   wire 	  STATCSEL;
   wire 	  STATBSEL;
   wire 	  STATASEL;
   wire 	  PLLEN_ipd;
   wire 	  NC1, VCOSEL0, VCOSEL1, VCOSEL2;
  
   wire [ 88 : 0 ] C;
   wire [ 88 : 0 ] SUPDATELATCH;
   wire [ 88 : 0 ] PC;
   wire 	   SDOUT_int;
  

   reg 		   RESETENA_latched;
   reg 		   DYNSYNC;  
  
  
  buf CLKA_BUF (CLKA_ipd, CLKA);
  buf CLKB_BUF (CLKB_ipd, CLKB);
  buf CLKC_BUF (CLKC_ipd, CLKC);
  buf EXTFB_BUF (EXTFB_ipd, EXTFB);
  buf PLLEN_BUF ( PLLEN_ipd, PLLEN );
  buf SDIN_BUF      ( SDIN_ipd,           SDIN );
  buf SCLK_BUF      ( SCLK_ipd,           SCLK );
  buf SSHIFT_BUF    ( SSHIFT_ipd,       SSHIFT );
  buf SUPDATE_BUF   ( SUPDATE_ipd,     SUPDATE );
  buf MODE_BUF      ( MODE_ipd,           MODE );

  buf OADIVRST_BUF  ( OADIVRST_ipd,   OADIVRST );
  buf OBDIVRST_BUF  ( OBDIVRST_ipd,   OBDIVRST );
  buf OCDIVRST_BUF  ( OCDIVRST_ipd,   OCDIVRST );
 
  buf GLMUXSEL_BUF (GLMUXSEL_ipd, GLMUXSEL);
  buf GLMUXINT_BUF (GLMUXINT_ipd, GLMUXINT);

  assign PC [ 88 : 0 ] = { GLMUXCFG,    // 88:87
                         OCDIVHALF,      // 86
                         OBDIVHALF,      // 85
                         OADIVHALF,      // 84
                         RXCSEL,         // 83
                         RXBSEL,         // 82
                         RXASEL,         // 81
			 NC1,       // NO CONNECTION
                         DYNCSEL,        // 79
                         DYNBSEL,        // 78
                         DYNASEL,        // 77
                         VCOSEL2,        // 76
                         VCOSEL1,        // 75
                         VCOSEL0,        // 74
                         STATCSEL,       // 73
                         STATBSEL,       // 72
                         STATASEL,       // 71
                         DLYGLAFAB,         // 70//YC delay line 5 bit
                         DLYGLAMSS,//YB Delay line 5 bit
                         DLYGLC, //5 bit
                         DLYGLB, // 5 bit
                         DLYGLA, // 5 bit
                         XDLYSEL,
                         FBDLY, // 5 bit
                         FBSEL, // 2 bit
                         OCMUX, // 3 bit
                         OBMUX, // 3 bit
                         OAMUX, // 3 bit
                         OCDIV, // 5 bit
                         OBDIV, // 5 bit
                         OADIV, // 5 bit
                         FBDIV, // 7 bit
                         FINDIV // 7 bit
                       };


  //Multiplexer functionality

  assign C [ 88 : 0 ] = MODE_ipd ? 
                         SUPDATELATCH [ 88 : 0 ] : 
                        PC [ 88 : 0 ];

  //Logic for generating DYNSYNC

  always @ ( SUPDATE_ipd )
  begin

    if ( SUPDATE_ipd == 1'b1 )
    begin
      if ( MODE_ipd == 1'b1 && RESETENA_latched == 1'b1 )
      begin
        DYNSYNC <= 1'b1;
      end
    end
    else if ( SUPDATE_ipd == 1'b0 )
    begin
      DYNSYNC <= 1'b0;
      RESETENA_latched <= SUPDATELATCH [ 80 ];
    end

  end
 
  assign LOCKMSS = pll_lock;
  assign LOCK = pll_lock;
  
  defparam P1.VCOFREQUENCY = VCOFREQUENCY;
  defparam P1.f_CLKA_LOCK  = f_CLKA_LOCK;
  
   PLLPRIM   #(.VCOFREQUENCY(VCOFREQUENCY),
	       .f_CLKA_LOCK(f_CLKA_LOCK),
	       .CLKA_TO_REF_DELAY(CLKA_TO_REF_DELAY),
	       .EMULATED_SYSTEM_DELAY(EMULATED_SYSTEM_DELAY),
	       .IN_DIV_DELAY(IN_DIV_DELAY),
	       //.OUT_DIV_DELAY(OUT_DIV_DELAY),
	       .OUT_UDIV_DELAY(OUT_UDIV_DELAY),
	       .OUT_VDIV_DELAY(OUT_VDIV_DELAY),
	       .OUT_WDIV_DELAY(OUT_WDIV_DELAY),
	       .MUX_DELAY(MUX_DELAY),
	       .IN_DELAY_BYP1(IN_DELAY_BYP1),
	       //.BYP_MUX_DELAY(BYP_MUX_DELAY),
	       .BYP_GLAMUX_DELAY(BYP_GLAMUX_DELAY),
	       .BYP_GLBMUX_DELAY(BYP_GLBMUX_DELAY),
	       .BYP_GLCMUX_DELAY(BYP_GLCMUX_DELAY),
	       //.GL_DRVR_DELAY(GL_DRVR_DELAY),
	       .GLA_DRVR_DELAY(GLA_DRVR_DELAY),
	       .GLB_DRVR_DELAY(GLB_DRVR_DELAY),
	       .GLC_DRVR_DELAY(GLC_DRVR_DELAY),
	       .Y_DRVR_DELAY(Y_DRVR_DELAY),
	       .FB_MUX_DELAY(FB_MUX_DELAY),
	       .BYP0_CLK_GL(BYP0_CLK_GL),
	       .X_MUX_DELAY(X_MUX_DELAY),
	       .FIN_LOCK_DELAY(FIN_LOCK_DELAY),
	       .LOCK_OUT_DELAY(LOCK_OUT_DELAY),
	       .t_rise(t_rise),
	       .t_fall(t_fall),
	       .PROG_STEP_INCREMENT(PROG_STEP_INCREMENT),
	       .PROG_INIT_DELAY(PROG_INIT_DELAY),
	       .INIT_DELAY(INIT_DELAY),
	       .NGMUX_GLA(NGMUX_GLA),
	       .NGMUX_GLC(NGMUX_GLC),
	       .NGMUX_GLMUXINT(NGMUX_GLMUXINT))
      P1 (
	  .DYNSYNC      ( DYNSYNC       ),
	  .CLKA         ( CLKA_ipd      ),
	  .EXTFB        ( EXTFB_ipd     ),
	  .POWERDOWN    ( PLLEN         ),
	  .CLKB         ( CLKB_ipd      ),
	  .CLKC         ( CLKC_ipd      ),
	  .OADIVRST     ( OADIVRST_ipd  ),
	  .OBDIVRST     ( OBDIVRST_ipd  ),
	  .OCDIVRST     ( OCDIVRST_ipd  ),
	  .BYPASSA      ( BYPASSA ),
	  .OADIV0       ( C [ 14 ] ),
	  .OADIV1       ( C [ 15 ] ),
	  .OADIV2       ( C [ 16 ] ),
	  .OADIV3       ( C [ 17 ] ),
	  .OADIV4       ( C [ 18 ] ),
	  .OAMUX0       ( C [ 29 ] ),
	  .OAMUX1       ( C [ 30 ] ),
	  .OAMUX2       ( C [ 31 ] ),
	  .DLYGLA0      ( C [ 46 ] ),
	  .DLYGLA1      ( C [ 47 ] ),
	  .DLYGLA2      ( C [ 48 ] ),
	  .DLYGLA3      ( C [ 49 ] ),
	  .DLYGLA4      ( C [ 50 ] ), 
	  .DLYGLADSS0   ( C [ 61 ] ),
	  .DLYGLADSS1   ( C [ 62 ] ),
	  .DLYGLADSS2   ( C [ 63 ] ),
	  .DLYGLADSS3   ( C [ 64 ] ),
	  .DLYGLADSS4   ( C [ 65 ] ), 
	  .DLYGLACORE0  ( C [ 66 ] ),
	  .DLYGLACORE1  ( C [ 67 ] ),
	  .DLYGLACORE2  ( C [ 68 ] ),
	  .DLYGLACORE3  ( C [ 69 ] ),
	  .DLYGLACORE4  ( C [ 70 ] ),
	  .OBDIV0       ( C [ 19 ] ),
	  .OBDIV1       ( C [ 20 ] ),
	  .OBDIV2       ( C [ 21 ] ),
	  .OBDIV3       ( C [ 22 ] ),
	  .OBDIV4       ( C [ 23 ] ),
	  .OBMUX0       ( C [ 32 ] ),
	  .OBMUX1       ( C [ 33 ] ),
	  .OBMUX2       ( C [ 34 ] ),
	  .BYPASSB      ( BYPASSB ),
	  .DLYGLB0      ( C [ 51 ] ),
	  .DLYGLB1      ( C [ 52 ] ),
	  .DLYGLB2      ( C [ 53 ] ),
	  .DLYGLB3      ( C [ 54 ] ),
	  .DLYGLB4      ( C [ 55 ] ),
	  .OCDIV0       ( C [ 24 ] ),
	  .OCDIV1       ( C [ 25 ] ),
	  .OCDIV2       ( C [ 26 ] ),
	  .OCDIV3       ( C [ 27 ] ),
	  .OCDIV4       ( C [ 28 ] ),
	  .OCMUX0       ( C [ 35 ] ),
	  .OCMUX1       ( C [ 36 ] ),
	  .OCMUX2       ( C [ 37 ] ),
	  .BYPASSC      ( BYPASSC ),
	  .DLYGLC0      ( C [ 56 ] ),
	  .DLYGLC1      ( C [ 57 ] ),
	  .DLYGLC2      ( C [ 58 ] ),
	  .DLYGLC3      ( C [ 59 ] ),
	  .DLYGLC4      ( C [ 60 ] ),
	  .FINDIV0      ( C [  0 ] ),
	  .FINDIV1      ( C [  1 ] ),
	  .FINDIV2      ( C [  2 ] ),
	  .FINDIV3      ( C [  3 ] ),
	  .FINDIV4      ( C [  4 ] ),
	  .FINDIV5      ( C [  5 ] ),
	  .FINDIV6      ( C [  6 ] ),
	  .FBDIV0       ( C [  7 ] ),
	  .FBDIV1       ( C [  8 ] ),
	  .FBDIV2       ( C [  9 ] ),
	  .FBDIV3       ( C [ 10 ] ),
	  .FBDIV4       ( C [ 11 ] ),
	  .FBDIV5       ( C [ 12 ] ),
	  .FBDIV6       ( C [ 13 ] ),
	  .FBDLY0       ( C [ 40 ] ),
	  .FBDLY1       ( C [ 41 ] ),
	  .FBDLY2       ( C [ 42 ] ),
	  .FBDLY3       ( C [ 43 ] ),
	  .FBDLY4       ( C [ 44 ] ),
	  .FBSEL0       ( C [ 38 ] ),
	  .FBSEL1       ( C [ 39 ] ),
	  .XDLYSEL      ( C [ 45 ] ),
	  .OADIVHALF    ( C [ 84 ] ),
	  .OBDIVHALF    ( C [ 85 ] ),
	  .OCDIVHALF    ( C [ 86 ] ),
	  .GLA          ( GLA ),
	  .GLADSS       ( GLAMSS ),
	  .LOCK         ( pll_lock ),
	  .GLB          ( GLB  ),
	  .YB           ( YB   ),
	  .GLC          ( GLC  ),
	  .MACCLK       ( MACCLK ),
	  .YC           ( YC   ),
	  .GLMUXSEL     ( GLMUXSEL[0] ),
	  .GLMUXCFG     ( GLMUXCFG[0] ),
	  .GLMUXINT     ( GLMUXINT )
	  );

 //instantiating the shift register

  SHREG     Sh1 (
                .SDOUT        ( SDOUT        ),
                .SUPDATELATCH ( SUPDATELATCH ),
                .SDIN         ( SDIN_ipd     ),
                .SCLK         ( SCLK_ipd     ),
                .SSHIFT       ( SSHIFT_ipd   ),
                .SUPDATE      ( SUPDATE_ipd  )
                );
  
  specify
    
    specparam   LibName     = "smartfusion";

    // Timing paths for PLL related signals
    (CLKA      => GLA)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLA)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => GLAMSS)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLAMSS)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => GLB)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLB)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => GLC)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => GLC)      = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => MACCLK)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => MACCLK)   = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => YB)       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YB)       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => YC)       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (EXTFB     => YC)       = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    (CLKA      => LOCK)     = (0.00:0.00:0.00, 0.00:0.00:0.00);
    (CLKA      => LOCKMSS)     = (0.00:0.00:0.00, 0.00:0.00:0.00);
    
    ( posedge SCLK => (SDOUT+:SDOUT) ) =  ( 0.0:0.0:0.0, 0.0:0.0:0.0 );

    
    $setup(posedge SDIN, posedge SCLK, 0.0, NOTIFY_REG);
    $setup(negedge SDIN, posedge SCLK, 0.0, NOTIFY_REG);
    $width(posedge SCLK, 0.0, 0, NOTIFY_REG);
    $width(negedge SCLK, 0.0, 0, NOTIFY_REG);
    $setup(posedge SSHIFT, posedge SCLK, 0.0, NOTIFY_REG);
    $setup(negedge SSHIFT, posedge SCLK, 0.0, NOTIFY_REG);
    $width(posedge SUPDATE, 0.0, 0, NOTIFY_REG);
    $width(negedge SUPDATE, 0.0, 0, NOTIFY_REG);
    $hold(posedge CLKA, posedge GLMUXSEL[0], 0.0, NOTIFY_REG);
    $hold(posedge CLKA, negedge GLMUXSEL[0], 0.0, NOTIFY_REG);
    $hold(posedge CLKC, negedge GLMUXSEL[0], 0.0, NOTIFY_REG);
    $hold(posedge GLMUXINT, negedge GLMUXSEL[0], 0.0, NOTIFY_REG);
    $setup(negedge GLMUXSEL[0], posedge CLKC, 0.0, NOTIFY_REG);
    $setup(posedge GLMUXSEL[0], posedge CLKA, 0.0, NOTIFY_REG);
    $setup(negedge GLMUXSEL[0], posedge GLMUXINT, 0.0, NOTIFY_REG);
    $setup(negedge GLMUXSEL[0], posedge CLKA, 0.0, NOTIFY_REG);

  endspecify
  
endmodule  

`timescale 1ns/1ps

module FAB_CCC_DYN (
		    CLKA,
		    EXTFB,
		    PLLEN,		   
		    GLA,
		    LOCK,
		    CLKB,
		    GLB,
		    YB,
		    CLKC,
		    GLC,
		    YC,
		    SDIN,
		    SCLK,
		    SSHIFT,
		    SUPDATE,
		    MODE,
		    SDOUT,
		    OADIV,
		    OADIVHALF,
		    OADIVRST,
		    OAMUX,
		    BYPASSA,
		    DLYGLA,
		    DLYGLAFAB,
		    OBDIV,
		    OBDIVHALF,
		    OBDIVRST,
		    OBMUX,
		    BYPASSB,
		    DLYGLB,
		    OCDIV,
		    OCDIVHALF,
		    OCDIVRST,
		    OCMUX,
		    BYPASSC,
		    DLYGLC,
		    FINDIV,
		    FBDIV,
		    FBDLY,
		    FBSEL,
		    XDLYSEL,
		    VCOSEL,
		    GLMUXSEL,
		    GLMUXCFG,
		    GLMUXINT
		    );

   output       GLA;
   output       LOCK;
   output       GLB;
   output       YB;
   output       GLC;
   output       YC;
   output 	SDOUT;
   
   input [1:0] 	GLMUXCFG;
   input [1:0] 	GLMUXSEL;
   input 	GLMUXINT;
   input 	XDLYSEL;
   input [1:0] 	FBSEL;
   input [4:0] 	FBDLY;
   input [6:0] 	FBDIV;
   input [6:0] 	FINDIV;
   
   input [4:0] 	DLYGLC;
   input        BYPASSC;
   input [2:0] 	OCMUX;
   input        OCDIVHALF;
   input [4:0] 	OCDIV;
   input        OCDIVRST;
   
   input [4:0] 	DLYGLB;
   input        BYPASSB;
   input [2:0] 	OBMUX;
   input        OBDIVHALF;
   input [4:0] 	OBDIV;
   input        OBDIVRST;
   
   input [4:0] 	DLYGLA;
   input [4:0] 	DLYGLAFAB;
   input [2:0] 	OAMUX;
   input        BYPASSA ;
   input [4:0] 	OADIV;
   input        OADIVHALF;
   input        OADIVRST;
   
   input        CLKA;
   input        CLKB;
   input        CLKC;
   input        EXTFB;
   input        PLLEN;
   input 	SDIN;
   input 	SCLK;
   input 	SSHIFT;
   input 	SUPDATE;
   input 	MODE;

   input [2:0] 	VCOSEL;


   parameter   VCOFREQUENCY = 0.0;
   parameter   f_CLKA_LOCK  = 3;      // Number of CLKA cycles to wait before raising LOCK
   parameter   CLKA_TO_REF_DELAY   =  0;
   parameter   EMULATED_SYSTEM_DELAY = 2028;
   parameter   IN_DIV_DELAY   =  0; // Input dividers intrinsic delay
   //parameter    OUT_DIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_UDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_VDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_WDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   MUX_DELAY      = 0; // MUXA/MUXB/MUXC intrinsic delay
   parameter   IN_DELAY_BYP1  = 0; // Instrinsic delay for CLKDIVDLY bypass mode
   //parameter    BYP_MUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLAMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLBMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLCMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   //parameter    GL_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLA_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLB_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLC_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   Y_DRVR_DELAY   =  0; // Y Driver intrinsic delay
   parameter   FB_MUX_DELAY   =  0; // FBSEL MUX intrinsic delay
   parameter   BYP0_CLK_GL    =  0; // Instrinsic delay for CLKDLY bypass mode
   parameter   X_MUX_DELAY    =  0; // XDLYSEL MUX intrinsic delay
   parameter   FIN_LOCK_DELAY = 0; // FIN to LOCK propagation delay
   parameter   LOCK_OUT_DELAY = 0; // LOCK to OUT propagation delay
   parameter   t_rise = 0;
   parameter   t_fall = 0;
   parameter   PROG_STEP_INCREMENT  = 200;
   parameter   PROG_INIT_DELAY      = 535;
   parameter   INIT_DELAY      = 65;
   parameter 	  NGMUX_GLA = 0; //GLA -> NGMUXOUT delay
   parameter 	  NGMUX_GLC = 0; // GLC -> NGMUXOUT delay
   parameter 	  NGMUX_GLMUXINT = 0; //GLMUXINT -> NGMUXOUT delay    
   
   wire 	EXTFB;

   
   MSS_CCC_IP    #(.VCOFREQUENCY(VCOFREQUENCY),
		   .f_CLKA_LOCK(f_CLKA_LOCK),
		   .CLKA_TO_REF_DELAY(CLKA_TO_REF_DELAY),
		   .EMULATED_SYSTEM_DELAY(EMULATED_SYSTEM_DELAY),
		   .IN_DIV_DELAY(IN_DIV_DELAY),
		   //.OUT_DIV_DELAY(OUT_DIV_DELAY),
		   .OUT_UDIV_DELAY(OUT_UDIV_DELAY),
		   .OUT_VDIV_DELAY(OUT_VDIV_DELAY),
		   .OUT_WDIV_DELAY(OUT_WDIV_DELAY),
		   .MUX_DELAY(MUX_DELAY),
		   .IN_DELAY_BYP1(IN_DELAY_BYP1),
		   //.BYP_MUX_DELAY(BYP_MUX_DELAY),
		   .BYP_GLAMUX_DELAY(BYP_GLAMUX_DELAY),
		   .BYP_GLBMUX_DELAY(BYP_GLBMUX_DELAY),
		   .BYP_GLCMUX_DELAY(BYP_GLCMUX_DELAY),
		   //.GL_DRVR_DELAY(GL_DRVR_DELAY),
		   .GLA_DRVR_DELAY(GLA_DRVR_DELAY),
		   .GLB_DRVR_DELAY(GLB_DRVR_DELAY),
		   .GLC_DRVR_DELAY(GLC_DRVR_DELAY),
		   .Y_DRVR_DELAY(Y_DRVR_DELAY),
		   .FB_MUX_DELAY(FB_MUX_DELAY),
		   .BYP0_CLK_GL(BYP0_CLK_GL),
		   .X_MUX_DELAY(X_MUX_DELAY),
		   .FIN_LOCK_DELAY(FIN_LOCK_DELAY),
		   .LOCK_OUT_DELAY(LOCK_OUT_DELAY),
		   .PROG_STEP_INCREMENT(PROG_STEP_INCREMENT),
		   .PROG_INIT_DELAY(PROG_INIT_DELAY),
		   .INIT_DELAY(INIT_DELAY),
		   .NGMUX_GLA(NGMUX_GLA),
		   .NGMUX_GLC(NGMUX_GLC),
		   .NGMUX_GLMUXINT(NGMUX_GLMUXINT))
   
   CCCP1 (
	  .CLKA      ( CLKA ),
	  .EXTFB     ( EXTFB ),
	  .PLLEN     ( PLLEN ),
	  .CLKB      ( CLKB ),
	  .CLKC      ( CLKC ),
	  .OADIVRST  ( OADIVRST  ),
	  .OBDIVRST  ( OBDIVRST  ),
	  .OCDIVRST  ( OCDIVRST  ),
	  .OADIV     ( OADIV ),
	  .OAMUX     ( OAMUX ),
	  .BYPASSA   ( BYPASSA ),
	  .DLYGLA    ( DLYGLA ),
	  .DLYGLAMSS (  5'b0 ),
	  .DLYGLAFAB ( DLYGLAFAB  ),
	  .OBDIV     ( OBDIV  ),
	  .OBMUX     ( OBMUX  ),
	  .BYPASSB   ( BYPASSB ),
	  .DLYGLB    ( DLYGLB  ),
	  .OCDIV     ( OCDIV  ),
	  .OCMUX     ( OCMUX  ),
	  .BYPASSC   ( BYPASSC ),
	  .DLYGLC    ( DLYGLC  ),
	  .FINDIV    ( FINDIV  ),
	  .FBDIV     ( FBDIV  ),
	  .FBDLY     ( FBDLY  ),
	  .FBSEL     ( FBSEL  ),
	  .XDLYSEL   ( XDLYSEL ),
	  .OADIVHALF ( OADIVHALF ),
	  .OBDIVHALF ( OBDIVHALF ),
	  .OCDIVHALF ( OCDIVHALF ),
	  .GLMUXSEL  ( GLMUXSEL),
	  .GLMUXCFG  ( GLMUXCFG),
	  .GLMUXINT  ( GLMUXINT),
	  .SDIN      ( SDIN ),
	  .SCLK      ( SCLK ),
	  .SSHIFT    ( SSHIFT ),
	  .SUPDATE   ( SUPDATE ),
	  .MODE      ( MODE ),
	  .GLA       ( GLA_int ),
	  .GLAMSS    (  ),
	  .LOCK      ( LOCK_int ),
	  .LOCKMSS   (  ),
	  .GLB       ( GLB_int  ),
	  .YB        ( YB_int   ),
	  .GLC       ( GLC_int  ),
	  .MACCLK    (  ),
	  .YC        ( YC_int   ),
	  .SDOUT     ( SDOUT    ),
	  .VCOSEL    ( 3'b0 )
	  );
   
   buf #0.1 bufgla( GLA, GLA_int);
   buf #0.1 bufLOCK( LOCK, LOCK_int);
   buf #0.1 bufGLB( GLB, GLB_int);
   buf #0.1 bufYB( YB, YB_int);
   buf #0.1 bufGLC( GLC, GLC_int);
   buf #0.1 bufYC( YC, YC_int);

endmodule  

`timescale 1ns/1ps

  module FAB_CCC (
		  CLKA,
		  EXTFB,
		  PLLEN,		   
		  GLA,
		  LOCK,
		  CLKB,
		  GLB,
		  YB,
		  CLKC,
		  GLC,
		  YC,
		  OADIV,
		  OADIVHALF,
		  OADIVRST,
		  OAMUX,
		  BYPASSA,
		  DLYGLA,
		  DLYGLAFAB,
		  OBDIV,
		  OBDIVHALF,
		  OBDIVRST,
		  OBMUX,
		  BYPASSB,
		  DLYGLB,
		  OCDIV,
		  OCDIVHALF,
		  OCDIVRST,
		  OCMUX,
		  BYPASSC,
		  DLYGLC,
		  FINDIV,
		  FBDIV,
		  FBDLY,
		  FBSEL,
		  XDLYSEL,
		  VCOSEL,
		  GLMUXSEL,
		  GLMUXCFG,
		  GLMUXINT
		  );

  output       GLA;
  output       LOCK;
  output       GLB;
  output       YB;
  output       GLC;
  output       YC;
 
  input  [1:0] GLMUXCFG;
  input  [1:0] GLMUXSEL;
   input       GLMUXINT;
   
  input        XDLYSEL;
  input  [1:0] FBSEL;
  input  [4:0] FBDLY;
  input  [6:0] FBDIV;
  input  [6:0] FINDIV;
  
  input  [4:0] DLYGLC;
  input        BYPASSC;
  input  [2:0] OCMUX;
  input        OCDIVHALF;
  input  [4:0] OCDIV;
  input        OCDIVRST;
  
  input  [4:0] DLYGLB;
  input        BYPASSB;
  input  [2:0] OBMUX;
  input        OBDIVHALF;
  input  [4:0] OBDIV;
  input        OBDIVRST;
  
  input  [4:0] DLYGLA;
  input  [4:0] DLYGLAFAB;
  input  [2:0] OAMUX;
  input        BYPASSA ;
  input  [4:0] OADIV;
  input        OADIVHALF;
  input        OADIVRST;
  
  input        CLKA;
  input        CLKB;
  input        CLKC;
  input        EXTFB;
  input        PLLEN;

   input [2:0] VCOSEL;

   parameter   VCOFREQUENCY = 0.0;
   parameter   f_CLKA_LOCK  = 3;      // Number of CLKA cycles to wait before raising LOCK
   parameter   CLKA_TO_REF_DELAY   =  0;
   parameter   EMULATED_SYSTEM_DELAY = 2028;
   parameter   IN_DIV_DELAY   =  0; // Input dividers intrinsic delay
  //parameter    OUT_DIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_UDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_VDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   OUT_WDIV_DELAY  =  0; // Output dividers intrinsic delay
   parameter   MUX_DELAY      = 0; // MUXA/MUXB/MUXC intrinsic delay
   parameter   IN_DELAY_BYP1  = 0; // Instrinsic delay for CLKDIVDLY bypass mode
  //parameter    BYP_MUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLAMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLBMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
   parameter   BYP_GLCMUX_DELAY  =   0; // Bypass MUX intrinsic delay, not used for Ys
  //parameter    GL_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLA_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLB_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   GLC_DRVR_DELAY  =   0; // Global Driver intrinsic delay
   parameter   Y_DRVR_DELAY   =  0; // Y Driver intrinsic delay
   parameter   FB_MUX_DELAY   =  0; // FBSEL MUX intrinsic delay
   parameter   BYP0_CLK_GL    =  0; // Instrinsic delay for CLKDLY bypass mode
   parameter   X_MUX_DELAY    =  0; // XDLYSEL MUX intrinsic delay
   parameter   FIN_LOCK_DELAY = 0; // FIN to LOCK propagation delay
   parameter   LOCK_OUT_DELAY = 0; // LOCK to OUT propagation delay
   parameter   t_rise = 0;
   parameter   t_fall = 0;
   parameter   PROG_STEP_INCREMENT  = 200;
   parameter   PROG_INIT_DELAY      = 535;
   parameter   INIT_DELAY      = 65;

   parameter 	  NGMUX_GLA = 0; //GLA -> NGMUXOUT delay
   parameter 	  NGMUX_GLC = 0; // GLC -> NGMUXOUT delay
   parameter 	  NGMUX_GLMUXINT = 0; //GLMUXINT -> NGMUXOUT delay    

  wire EXTFB;

  
   MSS_CCC_IP    #(.VCOFREQUENCY(VCOFREQUENCY),
		   .f_CLKA_LOCK(f_CLKA_LOCK),
		   .CLKA_TO_REF_DELAY(CLKA_TO_REF_DELAY),
		   .EMULATED_SYSTEM_DELAY(EMULATED_SYSTEM_DELAY),
		   .IN_DIV_DELAY(IN_DIV_DELAY),
		   //.OUT_DIV_DELAY(OUT_DIV_DELAY),
		   .OUT_UDIV_DELAY(OUT_UDIV_DELAY),
		   .OUT_VDIV_DELAY(OUT_VDIV_DELAY),
		   .OUT_WDIV_DELAY(OUT_WDIV_DELAY),
		   .MUX_DELAY(MUX_DELAY),
		   .IN_DELAY_BYP1(IN_DELAY_BYP1),
		   //.BYP_MUX_DELAY(BYP_MUX_DELAY),
		   .BYP_GLAMUX_DELAY(BYP_GLAMUX_DELAY),
		   .BYP_GLBMUX_DELAY(BYP_GLBMUX_DELAY),
		   .BYP_GLCMUX_DELAY(BYP_GLCMUX_DELAY),
		   //.GL_DRVR_DELAY(GL_DRVR_DELAY),
		   .GLA_DRVR_DELAY(GLA_DRVR_DELAY),
		   .GLB_DRVR_DELAY(GLB_DRVR_DELAY),
		   .GLC_DRVR_DELAY(GLC_DRVR_DELAY),
		   .Y_DRVR_DELAY(Y_DRVR_DELAY),
		   .FB_MUX_DELAY(FB_MUX_DELAY),
		   .BYP0_CLK_GL(BYP0_CLK_GL),
		   .X_MUX_DELAY(X_MUX_DELAY),
		   .FIN_LOCK_DELAY(FIN_LOCK_DELAY),
		   .LOCK_OUT_DELAY(LOCK_OUT_DELAY),
		   .PROG_STEP_INCREMENT(PROG_STEP_INCREMENT),
		   .PROG_INIT_DELAY(PROG_INIT_DELAY),
		   .INIT_DELAY(INIT_DELAY),
		   .NGMUX_GLA(NGMUX_GLA),
		   .NGMUX_GLC(NGMUX_GLC),
		   .NGMUX_GLMUXINT(NGMUX_GLMUXINT))
		  
      CCCP1 (
	     .CLKA      ( CLKA ),
	     .EXTFB     ( EXTFB ),
	     .PLLEN     ( PLLEN ),
	     .CLKB      ( CLKB ),
	     .CLKC      ( CLKC ),
	     .OADIVRST  ( OADIVRST  ),
	     .OBDIVRST  ( OBDIVRST  ),
	     .OCDIVRST  ( OCDIVRST  ),
	     .OADIV     ( OADIV ),
	     .OAMUX     ( OAMUX ),
	     .BYPASSA   ( BYPASSA ),
	     .DLYGLA    ( DLYGLA ),
	     .DLYGLAMSS (  5'b0 ),
	     .DLYGLAFAB ( DLYGLAFAB  ),
	     .OBDIV     ( OBDIV  ),
	     .OBMUX     ( OBMUX  ),
	     .BYPASSB   ( BYPASSB ),
	     .DLYGLB    ( DLYGLB  ),
	     .OCDIV     ( OCDIV  ),
	     .OCMUX     ( OCMUX  ),
	     .BYPASSC   ( BYPASSC ),
	     .DLYGLC    ( DLYGLC  ),
	     .FINDIV    ( FINDIV  ),
	     .FBDIV     ( FBDIV  ),
	     .FBDLY     ( FBDLY  ),
	     .FBSEL     ( FBSEL  ),
	     .XDLYSEL   ( XDLYSEL ),
	     .OADIVHALF ( OADIVHALF ),
	     .OBDIVHALF ( OBDIVHALF ),
	     .OCDIVHALF ( OCDIVHALF ),
	     .GLMUXSEL  ( GLMUXSEL),
	     .GLMUXCFG  ( GLMUXCFG),
	     .GLMUXINT  ( GLMUXINT),
	     .SDIN      ( 1'b0 ),
	     .SCLK      ( 1'b0 ),
	     .SSHIFT    ( 1'b0 ),
	     .SUPDATE   ( 1'b0 ),
	     .MODE      ( 1'b0 ),
	     .GLA       ( GLA_int ),
	     .GLAMSS    (  ),
	     .LOCK      ( LOCK_int ),
	     .LOCKMSS   (  ),
	     .GLB       ( GLB_int  ),
	     .YB        ( YB_int   ),
	     .GLC       ( GLC_int  ),
	     .MACCLK    (  ),
	     .YC        ( YC_int   ),
	     .SDOUT     (),
	     .VCOSEL    ( 3'b0 )
	     );
  
  buf #0.1 bufgla( GLA, GLA_int);
  buf #0.1 bufLOCK( LOCK, LOCK_int);
  buf #0.1 bufGLB( GLB, GLB_int);
  buf #0.1 bufYB( YB, YB_int);
  buf #0.1 bufGLC( GLC, GLC_int);
  buf #0.1 bufYC( YC, YC_int);

endmodule  

//---- MODULE MSS_CCC_IF ----
/*--------------------------------------------------------------------
 CELL NAME : MSS_CCC_IF
 CELL TYPE : comb
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1ns/1ps
    module MSS_CCC_IF ( input PIN2,
			input PIN3,
			input PIN4,
			output PIN1,
			output PIN2INT,
			output PIN3INT,
			output PIN4INT,
			input PIN1INT);
  

  buf inst1 (PIN1, PIN1INT);
  buf inst2 (PIN2INT, PIN2);
  buf inst3 (PIN3INT, PIN3);
  buf inst4 (PIN4INT, PIN4);

  specify
      
      ( PIN1INT => PIN1 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN2 => PIN2INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN3 => PIN3INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN4 => PIN4INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );

  endspecify
  
endmodule // MSS_CCC_IF

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MSS_CCC_IF ----

//---- MODULE MSS_CCC_GL_IF ----
/*--------------------------------------------------------------------
 CELL NAME : MSS_CCC_GL_IF
 CELL TYPE : comb
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1ns/1ps
module MSS_CCC_GL_IF ( input PIN2,
		input PIN3,
		input PIN4,
		output PIN1,
		output PIN5,
		output PIN2INT,
		output PIN3INT,
		output PIN4INT,
		input PIN1INT,
		input PIN5INT);
  

  buf inst1 (PIN1, PIN1INT);
  buf inst2 (PIN2INT, PIN2);
  buf inst3 (PIN3INT, PIN3);
  buf inst4 (PIN4INT, PIN4);
  buf inst5 (PIN5, PIN5INT);

  specify
      
      ( PIN1INT => PIN1 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN2 => PIN2INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN3 => PIN3INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );

      ( PIN4 => PIN4INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN5INT => PIN5 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );

  endspecify
  
endmodule // MSS_CCC_GL_IF

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MSS_CCC_GL_IF ----

//---- MODULE MSS_IF ----
/*--------------------------------------------------------------------
 CELL NAME : MSS_IF
 CELL TYPE : comb
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1ns/100ps
module MSS_IF (input PIN4,
	       input PIN5,
	       input PIN6,
	       output PIN1,
	       output PIN2,
	       output PIN3,
	       output PIN4INT,
	       output PIN5INT,
	       output PIN6INT,
	       input PIN1INT,
	       input PIN2INT,
	       input PIN3INT);
  
  buf inst1 (PIN1, PIN1INT);
  buf inst2 (PIN2, PIN2INT);
  buf inst3 (PIN3, PIN3INT);
  buf inst4 (PIN4INT, PIN4);
  buf inst5 (PIN5INT, PIN5);
  buf inst6 (PIN6INT, PIN6);

  specify
      
      ( PIN1INT => PIN1 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN2INT => PIN2 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN3INT => PIN3 ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );

      ( PIN4 => PIN4INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN5 => PIN5INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );
      ( PIN6 => PIN6INT ) = (0.1:0.1:0.1, 0.1:0.1:0.1 );

  endspecify
  
endmodule // MSS_IF

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE MSS_IF ----

//---- MODULE CORERAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : CORERAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps  / 1 ps

module CORERAM4K9 (ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5,
               ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0, DINA8, DINA7, DINA6,
               DINA5, DINA4, DINA3, DINA2, DINA1, DINA0, DOUTA8, DOUTA7,
               DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
               WIDTHA1, WIDTHA0, PIPEA, WMODEA, BLKA, WENA, CLKA,
               ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
               ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0, DINB8, DINB7, DINB6,
               DINB5, DINB4, DINB3, DINB2, DINB1, DINB0, DOUTB8, DOUTB7,
               DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
               WIDTHB1, WIDTHB0, PIPEB, WMODEB, BLKB, WENB, CLKB, RESET
              );

parameter DELAY_TWO = 2;
parameter TC2CWWH = 303;
parameter TC2CRWH = 452;
parameter TC2CWRH = 493;


input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8, DINA7, DINA6, DINA5, DINA4, DINA3, DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA, WMODEA, BLKA, WENA, CLKA;
input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8, DINB7, DINB6, DINB5, DINB4, DINB3, DINB2, DINB1, DINB0;
input WIDTHB1, WIDTHB0, PIPEB, WMODEB, BLKB, WENB, CLKB, RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 


reg DOUTAP8, DOUTAP7, DOUTAP6, DOUTAP5, DOUTAP4, DOUTAP3, DOUTAP2, DOUTAP1, DOUTAP0;
reg DOUTBP8, DOUTBP7, DOUTBP6, DOUTBP5, DOUTBP4, DOUTBP3, DOUTBP2, DOUTBP1, DOUTBP0;

reg DOUTAP8_stg1, DOUTAP7_stg1, DOUTAP6_stg1, DOUTAP5_stg1, DOUTAP4_stg1, DOUTAP3_stg1, DOUTAP2_stg1, DOUTAP1_stg1, DOUTAP0_stg1;
reg DOUTBP8_stg1, DOUTBP7_stg1, DOUTBP6_stg1, DOUTBP5_stg1, DOUTBP4_stg1, DOUTBP3_stg1, DOUTBP2_stg1, DOUTBP1_stg1, DOUTBP0_stg1;

wire CLKA_int, CLKB_int;
wire WENA_int, WENB_int, WMODEA_int, WMODEB_int;
wire BLKA_int, BLKB_int, RESET_int,  PIPEA_int, PIPEB_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int, ADDRA5_int, ADDRA4_int;
wire ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int, ADDRB5_int, ADDRB4_int;
wire ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg [8:0] MEM_512_9 [0:511];

reg NOTIFY_REG;

integer ADDRA;            // Address of PORT A
integer ADDRB;            // Address of PORT B
integer DEPTH;
integer MAXADD;

reg ADDRA_VALID;
reg ADDRB_VALID;

time CLKA_wr_re, CLKA_rd_re;
time CLKB_wr_re, CLKB_rd_re;

reg  WENA_lat, WENB_lat;

reg  DINA8_reg, DINA7_reg, DINA6_reg, DINA5_reg, DINA4_reg, DINA3_reg, DINA2_reg, DINA1_reg, DINA0_reg;
reg  DINB8_reg, DINB7_reg, DINB6_reg, DINB5_reg, DINB4_reg, DINB3_reg, DINB2_reg, DINB1_reg, DINB0_reg;

reg  DINA8_bypass, DINA7_bypass, DINA6_bypass, DINA5_bypass, DINA4_bypass;
reg  DINA3_bypass, DINA2_bypass, DINA1_bypass, DINA0_bypass;

reg  DINB8_bypass, DINB7_bypass, DINB6_bypass, DINB5_bypass, DINB4_bypass;
reg  DINB3_bypass, DINB2_bypass, DINB1_bypass, DINB0_bypass;

/********************* TEXT MACRO DEFINITIONS ******************/

`define BLKA_WIDTH_CFG {WIDTHA1,WIDTHA0}
`define BLKB_WIDTH_CFG {WIDTHB1,WIDTHB0}

`define BLKA_ADDR          {ADDRA11_int,ADDRA10_int,ADDRA9_int,ADDRA8_int,ADDRA7_int,ADDRA6_int,ADDRA5_int,ADDRA4_int,ADDRA3_int,ADDRA2_int,ADDRA1_int,ADDRA0_int}

`define BLKB_ADDR          {ADDRB11_int,ADDRB10_int,ADDRB9_int,ADDRB8_int,ADDRB7_int,ADDRB6_int,ADDRB5_int,ADDRB4_int,ADDRB3_int,ADDRB2_int,ADDRB1_int,ADDRB0_int}

`define DATA_A_OUT     {DOUTAP8,DOUTAP7,DOUTAP6,DOUTAP5,DOUTAP4,DOUTAP3,DOUTAP2,DOUTAP1,DOUTAP0}
`define DATA_B_OUT     {DOUTBP8,DOUTBP7,DOUTBP6,DOUTBP5,DOUTBP4,DOUTBP3,DOUTBP2,DOUTBP1,DOUTBP0}

`define DATAP_A_OUT    {DOUTAP8_stg1,DOUTAP7_stg1,DOUTAP6_stg1,DOUTAP5_stg1,DOUTAP4_stg1,DOUTAP3_stg1,DOUTAP2_stg1,DOUTAP1_stg1,DOUTAP0_stg1}
`define DATAP_B_OUT    {DOUTBP8_stg1,DOUTBP7_stg1,DOUTBP6_stg1,DOUTBP5_stg1,DOUTBP4_stg1,DOUTBP3_stg1,DOUTBP2_stg1,DOUTBP1_stg1,DOUTBP0_stg1}

`define DATA_A_IN      {DINA8_int,DINA7_int,DINA6_int,DINA5_int,DINA4_int,DINA3_int,DINA2_int,DINA1_int,DINA0_int}
`define DATA_B_IN      {DINB8_int,DINB7_int,DINB6_int,DINB5_int,DINB4_int,DINB3_int,DINB2_int,DINB1_int,DINB0_int}

`define DATA_A_REG     {DINA8_reg,DINA7_reg,DINA6_reg,DINA5_reg,DINA4_reg,DINA3_reg,DINA2_reg,DINA1_reg,DINA0_reg}
`define DATA_B_REG     {DINB8_reg,DINB7_reg,DINB6_reg,DINB5_reg,DINB4_reg,DINB3_reg,DINB2_reg,DINB1_reg,DINB0_reg}

`define DATA_A_BYP     {DINA8_bypass,DINA7_bypass,DINA6_bypass,DINA5_bypass,DINA4_bypass,DINA3_bypass,DINA2_bypass,DINA1_bypass,DINA0_bypass}
`define DATA_B_BYP     {DINB8_bypass,DINB7_bypass,DINB6_bypass,DINB5_bypass,DINB4_bypass,DINB3_bypass,DINB2_bypass,DINB1_bypass,DINB0_bypass}

buf b0(CLKA_int, CLKA);
buf b1(CLKB_int, CLKB);
buf b2(WENA_int, WENA);
buf b3(WENB_int, WENB);

buf b4(DINA0_int, DINA0);
buf b5(DINA1_int, DINA1);
buf b6(DINA2_int, DINA2);
buf b7(DINA3_int, DINA3);
buf b8(DINA4_int, DINA4);
buf b9(DINA5_int, DINA5);
buf b10(DINA6_int, DINA6);
buf b11(DINA7_int, DINA7);
buf b12(DINA8_int, DINA8);


buf b13(DINB0_int, DINB0);
buf b14(DINB1_int, DINB1);
buf b15(DINB2_int, DINB2);
buf b16(DINB3_int, DINB3);
buf b17(DINB4_int, DINB4);
buf b18(DINB5_int, DINB5);
buf b19(DINB6_int, DINB6);
buf b20(DINB7_int, DINB7);
buf b21(DINB8_int, DINB8);

buf b22(ADDRA0_int, ADDRA0);
buf b23(ADDRA1_int, ADDRA1);
buf b24(ADDRA2_int, ADDRA2);
buf b25(ADDRA3_int, ADDRA3);
buf b26(ADDRA4_int, ADDRA4);
buf b27(ADDRA5_int, ADDRA5);
buf b28(ADDRA6_int, ADDRA6);
buf b29(ADDRA7_int, ADDRA7);
buf b30(ADDRA8_int, ADDRA8);
buf b31(ADDRA9_int, ADDRA9);
buf b32(ADDRA10_int, ADDRA10);
buf b33(ADDRA11_int, ADDRA11);

buf b34(ADDRB0_int, ADDRB0);
buf b35(ADDRB1_int, ADDRB1);
buf b36(ADDRB2_int, ADDRB2);
buf b37(ADDRB3_int, ADDRB3);
buf b38(ADDRB4_int, ADDRB4);
buf b39(ADDRB5_int, ADDRB5);
buf b40(ADDRB6_int, ADDRB6);
buf b41(ADDRB7_int, ADDRB7);
buf b42(ADDRB8_int, ADDRB8);
buf b43(ADDRB9_int, ADDRB9);
buf b44(ADDRB10_int, ADDRB10);
buf b45(ADDRB11_int, ADDRB11);

buf b46(RESET_int, RESET);
buf b47(BLKA_int, BLKA);
buf b48(BLKB_int, BLKB);
buf b49(PIPEA_int, PIPEA);
buf b50(PIPEB_int, PIPEB);
buf b51(WMODEA_int, WMODEA);
buf b52(WMODEB_int, WMODEB);

pmos inst1(DOUTA0, DOUTAP0, 0);
pmos inst2(DOUTA1, DOUTAP1, 0);
pmos inst3(DOUTA2, DOUTAP2, 0);
pmos inst4(DOUTA3, DOUTAP3, 0);
pmos inst5(DOUTA4, DOUTAP4, 0);
pmos inst6(DOUTA5, DOUTAP5, 0);
pmos inst7(DOUTA6, DOUTAP6, 0);
pmos inst8(DOUTA7, DOUTAP7, 0);
pmos inst9(DOUTA8, DOUTAP8, 0);

pmos inst10(DOUTB0, DOUTBP0, 0);
pmos inst11(DOUTB1, DOUTBP1, 0);
pmos inst12(DOUTB2, DOUTBP2, 0);
pmos inst13(DOUTB3, DOUTBP3, 0);
pmos inst14(DOUTB4, DOUTBP4, 0);
pmos inst15(DOUTB5, DOUTBP5, 0);
pmos inst16(DOUTB6, DOUTBP6, 0);
pmos inst17(DOUTB7, DOUTBP7, 0);
pmos inst18(DOUTB8, DOUTBP8, 0);

parameter DYNAMIC = 1;
parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

  initial
    begin
    
      if ( WARNING_MSGS_ON == 0 )
        $display("Note: RAM4K9 warnings disabled. Set WARNING_MSGS_ON = 1 to enable.");

      if ( MEMORYFILE != "")
        $readmemb ( MEMORYFILE, MEM_512_9 );
      else
        begin
          //if ( WARNING_MSGS_ON == 1 )
            //$display ( "Note: Module %m, memory initialization file parameter MEMORYFILE not defined" );
        end
    end


always @(CLKA_int === 1'bx )
begin
  if ($time > 0) begin
    if (BLKA_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : CLKA went unknown at time %0.1f. Instance: %m\n",$realtime);
    end
  end
end

always @(CLKB_int === 1'bx )
begin
  if ($time > 0) begin
    if (BLKB_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : CLKB went unknown at time %0.1f. Instance: %m\n",$realtime);
    end
  end
end

  always @(RESET_int )
      begin
	  if(RESET_int === 1'b0 )
	      begin
		  if (PIPEA_int == 1'b0) begin 
		      case (`BLKA_WIDTH_CFG)
			 2'b00 : DOUTAP0 = 1'b0;
			 2'b01 : begin
			     DOUTAP0 = 1'b0;
			     DOUTAP1 = 1'b0;
			 end
			 2'b10 : begin
			     DOUTAP0= 1'b0;
			     DOUTAP1 = 1'b0;
			     DOUTAP2 = 1'b0;
			     DOUTAP3 = 1'b0;
			 end
			 2'b11 : begin
			     DOUTAP0 = 1'b0;
			     DOUTAP1 = 1'b0;
			     DOUTAP2 = 1'b0;
			     DOUTAP3 = 1'b0;
			     DOUTAP4 = 1'b0;
			     DOUTAP5 = 1'b0;
			     DOUTAP6 = 1'b0;
			     DOUTAP7 = 1'b0;
			     DOUTAP8 = 1'b0;
			 end
			 default:
			     begin
				 //if ( WARNING_MSGS_ON == 1 )
				 //    $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
			     end
		      endcase
		  end else if (PIPEA_int == 1'b1) begin
		      case (`BLKA_WIDTH_CFG)
			 2'b00 : begin
			     DOUTAP0      = 1'b0;
			     DOUTAP0_stg1 = 1'b0;
			 end
			 2'b01 : begin
			     DOUTAP0 = 1'b0;
			     DOUTAP1 = 1'b0;
			     DOUTAP0_stg1 = 1'b0;
			     DOUTAP1_stg1 = 1'b0;
			 end
			 2'b10 : begin
			     DOUTAP0= 1'b0;
			     DOUTAP1 = 1'b0;
			     DOUTAP2 = 1'b0;
			     DOUTAP3 = 1'b0;
			     DOUTAP0_stg1= 1'b0;
			     DOUTAP1_stg1 = 1'b0;
			     DOUTAP2_stg1 = 1'b0;
			     DOUTAP3_stg1 = 1'b0;
			 end
			 2'b11 : begin
			     DOUTAP0 = 1'b0;
			     DOUTAP1 = 1'b0;
			     DOUTAP2 = 1'b0;
			     DOUTAP3 = 1'b0;
			     DOUTAP4 = 1'b0;
			     DOUTAP5 = 1'b0;
			     DOUTAP6 = 1'b0;
			     DOUTAP7 = 1'b0;
			     DOUTAP8 = 1'b0;
			     DOUTAP0_stg1 = 1'b0;
			     DOUTAP1_stg1 = 1'b0;
			     DOUTAP2_stg1 = 1'b0;
			     DOUTAP3_stg1 = 1'b0;
			     DOUTAP4_stg1 = 1'b0;
			     DOUTAP5_stg1 = 1'b0;
			     DOUTAP6_stg1 = 1'b0;
			     DOUTAP7_stg1 = 1'b0;
			     DOUTAP8_stg1 = 1'b0;

			 end
			 default:
			     begin
				 //if ( WARNING_MSGS_ON == 1 )
				 //    $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
			     end
		      endcase
		  end

		  if (PIPEB_int == 1'b0) begin  
		      case (`BLKB_WIDTH_CFG)
			 2'b00 : DOUTBP0 = 1'b0;
			 2'b01 : begin
			     DOUTBP0 = 1'b0;
			     DOUTBP1 = 1'b0;
			 end
			 2'b10 : begin
			     DOUTBP0= 1'b0;
			     DOUTBP1 = 1'b0;
			     DOUTBP2 = 1'b0;
			     DOUTBP3 = 1'b0;
			 end
			 2'b11 : begin
			     DOUTBP0 = 1'b0;
			     DOUTBP1 = 1'b0;
			     DOUTBP2 = 1'b0;
			     DOUTBP3 = 1'b0;
			     DOUTBP4 = 1'b0;
			     DOUTBP5 = 1'b0;
			     DOUTBP6 = 1'b0;
			     DOUTBP7 = 1'b0;
			     DOUTBP8 = 1'b0;
			 end
			 default:
			     begin
				 //if ( WARNING_MSGS_ON == 1 )
				//     $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
			     end
		      endcase

		  end else if (PIPEB_int == 1'b1) begin
		      case (`BLKB_WIDTH_CFG)
			 2'b00 : begin
			     DOUTBP0 = 1'b0;
			     DOUTBP0_stg1 = 1'b0;
			 end
			 2'b01 : begin
			     DOUTBP0 = 1'b0;
			     DOUTBP1 = 1'b0;
			     DOUTBP0_stg1 = 1'b0;
			     DOUTBP1_stg1 = 1'b0;

			 end
			 2'b10 : begin
			     DOUTBP0= 1'b0;
			     DOUTBP1 = 1'b0;
			     DOUTBP2 = 1'b0;
			     DOUTBP3 = 1'b0;
			     DOUTBP0_stg1= 1'b0;
			     DOUTBP1_stg1 = 1'b0;
			     DOUTBP2_stg1 = 1'b0;
			     DOUTBP3_stg1 = 1'b0;

			 end
			 2'b11 : begin
			     DOUTBP0 = 1'b0;
			     DOUTBP1 = 1'b0;
			     DOUTBP2 = 1'b0;
			     DOUTBP3 = 1'b0;
			     DOUTBP4 = 1'b0;
			     DOUTBP5 = 1'b0;
			     DOUTBP6 = 1'b0;
			     DOUTBP7 = 1'b0;
			     DOUTBP8 = 1'b0;
			     DOUTBP0_stg1 = 1'b0;
			     DOUTBP1_stg1 = 1'b0;
			     DOUTBP2_stg1 = 1'b0;
			     DOUTBP3_stg1 = 1'b0;
			     DOUTBP4_stg1 = 1'b0;
			     DOUTBP5_stg1 = 1'b0;
			     DOUTBP6_stg1 = 1'b0;
			     DOUTBP7_stg1 = 1'b0;
			     DOUTBP8_stg1 = 1'b0;

			 end
			 default:
			     begin
				 //if ( WARNING_MSGS_ON == 1 )
				 //    $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9", $time);
			     end
		      endcase
		  end
	      end
      end // Reset

// start the RAM BLKA write/read  behavior section

always @(posedge CLKA_int) begin

  if (PIPEA_int == 1'b1) begin
    case (`BLKA_WIDTH_CFG)
      2'b00 : begin 
               DOUTAP0 = DOUTAP0_stg1;
              end
      2'b01 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
              end
      2'b10 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
               DOUTAP2 = DOUTAP2_stg1;
               DOUTAP3 = DOUTAP3_stg1;
              end
      2'b11 : begin
               DOUTAP0 = DOUTAP0_stg1;
               DOUTAP1 = DOUTAP1_stg1;
               DOUTAP2 = DOUTAP2_stg1;
               DOUTAP3 = DOUTAP3_stg1;
               DOUTAP4 = DOUTAP4_stg1;
               DOUTAP5 = DOUTAP5_stg1;
               DOUTAP6 = DOUTAP6_stg1;
               DOUTAP7 = DOUTAP7_stg1;
               DOUTAP8 = DOUTAP8_stg1;
             end
      default:
              begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
              end
    endcase
  end
  else if (PIPEA_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: PIPEA unknown at time %d ns, no data was read. Instance: %m", $time);
    DOUTAP0 = 1'bx;
    DOUTAP1 = 1'bx;
    DOUTAP2 = 1'bx;
    DOUTAP3 = 1'bx;
    DOUTAP4 = 1'bx;
    DOUTAP5 = 1'bx;
    DOUTAP6 = 1'bx;
    DOUTAP7 = 1'bx;
    DOUTAP8 = 1'bx;
  end

  if ((BLKA_int == 1'b0) && (RESET_int == 1'b1)) begin

    WENA_lat = WENA_int;

    ADDRA = get_address(`BLKA_ADDR, `BLKA_WIDTH_CFG);   // get the address (read or write ) 
    ADDRA_VALID = 1;

    if ( DYNAMIC == 1 ) begin
      ADDRA = ADDRA >> `BLKA_WIDTH_CFG;
    end

    if ((^ADDRA) === 1'bx) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b00) && (ADDRA > 4095)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b01) && (ADDRA > 2047)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b10) && (ADDRA > 1023)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKA_WIDTH_CFG == 2'b11) && (ADDRA > 511)) begin
      ADDRA_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end

    // Write mode

    if ( (WENA_int == 1'b0) && ADDRA_VALID ) begin 

      CLKA_wr_re = $time;

      // Check if Write from Port B and Write from Port A are to the same address, write data is non-deterministic
      if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0} ) &&
                                                            ((CLKB_wr_re + TC2CWWH) > CLKA_wr_re) ) begin
        $display (" ** Warning: Port B Write and Port A Write to same address at same time. Write data conflict. Updating memory contents at conflicting address with X"); 
        $display (" Time: %0.1f Instance: %m ", $realtime );
        // function call to determine conflicting write data bits based on address and width configuration
        `DATA_A_REG = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_IN);
      end
      else begin
        // assign write data to data registers for writing into the memory array
        `DATA_A_REG = `DATA_A_IN;
      end
			
			// assign write data to bypass registers for driving onto RD if MODE=1
			`DATA_A_BYP = `DATA_A_IN;

      // Check for Read from Port B and Write from Port A to the same address, read data on Port B is driven to X
      if ( (WENB_lat == 1'b1) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                              ((CLKB_rd_re + TC2CRWH) > CLKA_wr_re) ) begin
        $display (" ** Warning: Port B Read and Port A Write to same address at same time. Port B read data is unpredictable, driving read data to X");
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPEB_int == 1'b1)
				begin
					case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
                    end
            2'b01 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
                    DOUTBP2_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
                    DOUTBP3_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTBP8_stg1, DOUTBP7_stg1, DOUTBP6_stg1, DOUTBP5_stg1, DOUTBP4_stg1,
                                   DOUTBP3_stg1, DOUTBP2_stg1, DOUTBP1_stg1, DOUTBP0_stg1} = MEM_512_9[ ADDRB[8:0] ];
                    end
            default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
               end
					endcase
					
          `DATAP_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATAP_B_OUT);
				end
        else if (PIPEB_int == 1'b0)
				begin
					case (`BLKB_WIDTH_CFG)
						2'b00 : begin
										DOUTBP0 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
										end
						2'b01 : begin
										DOUTBP0 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
										DOUTBP1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
										end
						2'b10 : begin
										DOUTBP0 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
										DOUTBP1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
										DOUTBP2 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
										DOUTBP3 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
										end
						2'b11 : begin
										{DOUTBP8, DOUTBP7, DOUTBP6, DOUTBP5, DOUTBP4,
															DOUTBP3, DOUTBP2, DOUTBP1, DOUTBP0} = MEM_512_9[ ADDRB[8:0] ];
										end
						default:
							 begin
								if ( WARNING_MSGS_ON == 1 )
									$display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
							 end
					endcase
					
					`DATA_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_OUT);
				end
      end

			case (`BLKA_WIDTH_CFG)
					2'b00 : begin
						MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ] = DINA0_reg;
						if (WMODEA_int == 1'b1) begin
							if (PIPEA_int == 1'b0) begin 
								DOUTAP0 = DINA0_bypass;
							end else if (PIPEA_int == 1'b1) begin
								DOUTAP0_stg1 = DINA0_bypass;
							end 
						end
					end
					2'b01 : begin
						MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ] = DINA0_reg;
						MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ] = DINA1_reg;
						if (WMODEA_int == 1'b1) begin
							if (PIPEA_int == 1'b0) begin
								DOUTAP0 = DINA0_bypass;
								DOUTAP1 = DINA1_bypass;
							end else if (PIPEA_int == 1'b1) begin
								DOUTAP0_stg1 = DINA0_bypass;
								DOUTAP1_stg1 = DINA1_bypass;
							end
						end
					end
					2'b10 : begin
						MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ] = DINA0_reg;
						MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ] = DINA1_reg;
						MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ] = DINA2_reg;
						MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ] = DINA3_reg;
						if (WMODEA_int == 1'b1) begin
							if (PIPEA_int == 1'b0) begin
								DOUTAP0 = DINA0_bypass;
								DOUTAP1 = DINA1_bypass;
								DOUTAP2 = DINA2_bypass;
								DOUTAP3 = DINA3_bypass;
							end else if (PIPEA_int == 1'b1) begin
								DOUTAP0_stg1 = DINA0_bypass;
								DOUTAP1_stg1 = DINA1_bypass;
								DOUTAP2_stg1 = DINA2_bypass;
								DOUTAP3_stg1 = DINA3_bypass;
							end
						end
					end
					2'b11 : begin
						MEM_512_9[ ADDRA[8:0] ] = {DINA8_reg,DINA7_reg,DINA6_reg,DINA5_reg,DINA4_reg,DINA3_reg,DINA2_reg,DINA1_reg,DINA0_reg};
						if (WMODEA_int == 1'b1) begin
							if (PIPEA_int == 1'b0) begin
								DOUTAP0 = DINA0_bypass;
								DOUTAP1 = DINA1_bypass;
								DOUTAP2 = DINA2_bypass;
								DOUTAP3 = DINA3_bypass;
								DOUTAP4 = DINA4_bypass;
								DOUTAP5 = DINA5_bypass;
								DOUTAP6 = DINA6_bypass;
								DOUTAP7 = DINA7_bypass;
								DOUTAP8 = DINA8_bypass;
							end else if (PIPEA_int == 1'b1) begin
								DOUTAP0_stg1 = DINA0_bypass;
								DOUTAP1_stg1 = DINA1_bypass;
								DOUTAP2_stg1 = DINA2_bypass;
								DOUTAP3_stg1 = DINA3_bypass;
								DOUTAP4_stg1 = DINA4_bypass;
								DOUTAP5_stg1 = DINA5_bypass;
								DOUTAP6_stg1 = DINA6_bypass;
								DOUTAP7_stg1 = DINA7_bypass;
								DOUTAP8_stg1 = DINA8_bypass;
							end
						end
					end
					default: begin
						if ( WARNING_MSGS_ON == 1 )
							$display ("Warning: Invalid WIDTH configuration at time %d ns. Legal Width: 1, 2, 4, 9. Instance: %m", $time);
					end
			endcase
   end else if ( (WENA_int == 1'b1) && ADDRA_VALID ) begin // Read mode

        CLKA_rd_re = $time;

        if (PIPEA_int == 1'b0) begin
					case (`BLKA_WIDTH_CFG)
						2'b00 : begin 
										DOUTAP0 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
										end
						2'b01 : begin
										DOUTAP0 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
										DOUTAP1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
								end
						2'b10 : begin
										DOUTAP0 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
										DOUTAP1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
										DOUTAP2 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
										DOUTAP3 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
								end
						2'b11 : begin
										{DOUTAP8, DOUTAP7, DOUTAP6, DOUTAP5, DOUTAP4, 
															DOUTAP3, DOUTAP2, DOUTAP1, DOUTAP0} = MEM_512_9[ ADDRA[8:0] ];
										end
						 default:
							 begin
								if ( WARNING_MSGS_ON == 1 )
									$display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
							 end
					endcase
					// Check for Write from Port B and Read from Port A to the same address, read data on Port A is driven to X
         if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                                  ((CLKB_wr_re + TC2CWRH) > CLKA_rd_re) ) begin
						$display (" ** Warning: Port B Write and Port A Read to same address at same time. Port A read data is unpredictable, driving read data to X.");
						$display (" Time: %0.1f Instance: %m ", $realtime );
						`DATA_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_OUT);
         end
				end else if (PIPEA_int == 1'b1) begin
          case (`BLKA_WIDTH_CFG)
						2'b00 : begin 
										DOUTAP0_stg1 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
										end
						2'b01 : begin
										DOUTAP0_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
										DOUTAP1_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
										end
						2'b10 : begin
										DOUTAP0_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
										DOUTAP1_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
										DOUTAP2_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
										DOUTAP3_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
										end
						2'b11 : begin
										{DOUTAP8_stg1, DOUTAP7_stg1, DOUTAP6_stg1, DOUTAP5_stg1, DOUTAP4_stg1,
																	 DOUTAP3_stg1, DOUTAP2_stg1, DOUTAP1_stg1, DOUTAP0_stg1} = MEM_512_9[ ADDRA[8:0] ];
										end
						 default:
							 begin
								if ( WARNING_MSGS_ON == 1 )
									$display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
							 end
					endcase
					// Check for Write from Port B and Read from Port A to the same address, read data on Port A is driven to X
					if ( (WENB_lat == 1'b0) && same_addr(ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}) &&
                                                                 ((CLKB_wr_re + TC2CWRH) > CLKA_rd_re) ) begin
						$display (" ** Warning: Port B Write and Port A Read to same address at same time. Port A read data is unpredictable, driving read data to X");
						$display (" Time: %0.1f Instance: %m ", $realtime );
						`DATAP_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATAP_A_OUT);
					end
        end else begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: PIPEA unknown at time %d ns, no data was read. Instance: %m", $time);
                DOUTAP0 = 1'bx;
                DOUTAP1 = 1'bx;
                DOUTAP2 = 1'bx;
                DOUTAP3 = 1'bx;
                DOUTAP4 = 1'bx;
                DOUTAP5 = 1'bx;
                DOUTAP6 = 1'bx;
                DOUTAP7 = 1'bx;
                DOUTAP8 = 1'bx;
              end
      end else if ( (WENA_int == 1'b0) && (ADDRA_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Write Address on port A, Write Not Initiated. Instance: %m");
      end else if ( (WENA_int == 1'b1) && (ADDRA_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Read Address on port A, Read Not Initiated. Instance: %m");
      end else begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning: WENAis unknown at time %d ns. Instance: %m", $time);
      end
    end
 end
   
                          
  
// start the RAM BLKB write/read  behavior section

always @(posedge CLKB_int) begin

  if (PIPEB_int == 1'b1) begin
    case (`BLKB_WIDTH_CFG)
      2'b00 : begin 
               DOUTBP0 = DOUTBP0_stg1;
              end
      2'b01 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
              end
      2'b10 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
               DOUTBP2 = DOUTBP2_stg1;
               DOUTBP3 = DOUTBP3_stg1;
              end
      2'b11 : begin
               DOUTBP0 = DOUTBP0_stg1;
               DOUTBP1 = DOUTBP1_stg1;
               DOUTBP2 = DOUTBP2_stg1;
               DOUTBP3 = DOUTBP3_stg1;
               DOUTBP4 = DOUTBP4_stg1;
               DOUTBP5 = DOUTBP5_stg1;
               DOUTBP6 = DOUTBP6_stg1;
               DOUTBP7 = DOUTBP7_stg1;
               DOUTBP8 = DOUTBP8_stg1;
             end
      default:
              begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
              end
    endcase
  end
  else if (PIPEB_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: PIPEB unknown at time %d ns, no data was read. Instance: %m", $time); 
    DOUTBP0 = 1'bx;
    DOUTBP1 = 1'bx;
    DOUTBP2 = 1'bx;
    DOUTBP3 = 1'bx;
    DOUTBP4 = 1'bx;
    DOUTBP5 = 1'bx;
    DOUTBP6 = 1'bx;
    DOUTBP7 = 1'bx;
    DOUTBP8 = 1'bx;
  end
 

  if ((BLKB_int == 1'b0) && (RESET_int == 1'b1)) begin

    WENB_lat = WENB_int;

    ADDRB = get_address(`BLKB_ADDR, `BLKB_WIDTH_CFG);   // get the address (read or write )
    ADDRB_VALID = 1;

    if ( DYNAMIC == 1 ) begin
      ADDRB = ADDRB >> `BLKB_WIDTH_CFG;
    end

    if ((^ADDRB) === 1'bx) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKB_WIDTH_CFG == 2'b00) && (ADDRB > 4095)) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKB_WIDTH_CFG == 2'b01) && (ADDRB > 2047)) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKB_WIDTH_CFG == 2'b10) && (ADDRB > 1023)) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! Instance: %m", $realtime);
    end
    else if ((`BLKB_WIDTH_CFG == 2'b11) && (ADDRB > 511)) begin
      ADDRB_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port B at time %0.1f! Instance: %m", $realtime);
    end

    // Write mode

    if ( (WENB_int == 1'b0) && ADDRB_VALID ) begin

      CLKB_wr_re = $time;

      // Check if Write from Port A and Write from Port A are to the same address, write data is non-deterministic

      if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0} ) &&
                                                            ((CLKA_wr_re + TC2CWWH) > CLKB_wr_re) ) begin
        $display (" ** Warning: Port A Write and Port B Write to same address at same time. Write data conflict. Updating memory contents at conflicting address with X");
        // function call to determine conflicting write data bits based on address and width configuration
        $display (" Time: %0.1f Instance: %m ", $realtime );
        `DATA_B_REG = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_IN);
      end
      else begin
        // assign write data to data registers for writing into the memory array
        `DATA_B_REG = `DATA_B_IN;
      end
			// assign write data to bypass registers for driving onto RD if MODE=1
			`DATA_B_BYP = `DATA_B_IN;


      // Check for Read from Port A and Write from Port B to the same address, read data on Port A is driven to X
      if ( (WENA_lat == 1'b1) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                              ((CLKA_rd_re + TC2CRWH) > CLKB_wr_re) ) begin
        $display (" ** Warning: Port A Read and Port B Write to same address at same time. Port A read data is unpredictable, driving read data to X");
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPEA_int == 1'b1)
				begin
					case (`BLKA_WIDTH_CFG)
							2'b00 : begin 
											DOUTAP0_stg1 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
											end
							2'b01 : begin
											DOUTAP0_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
											DOUTAP1_stg1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
											end
							2'b10 : begin
											DOUTAP0_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
											DOUTAP1_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
											DOUTAP2_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
											DOUTAP3_stg1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
											end
							2'b11 : begin
											{DOUTAP8_stg1, DOUTAP7_stg1, DOUTAP6_stg1, DOUTAP5_stg1, DOUTAP4_stg1,
																		 DOUTAP3_stg1, DOUTAP2_stg1, DOUTAP1_stg1, DOUTAP0_stg1} = MEM_512_9[ ADDRA[8:0] ];
											end
							 default:
								 begin
									if ( WARNING_MSGS_ON == 1 )
										$display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
								 end
					endcase
					`DATAP_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATAP_A_OUT);
				end
        else if (PIPEA_int == 1'b0)
				begin
					case (`BLKA_WIDTH_CFG)
							2'b00 : begin 
											DOUTAP0 = MEM_512_9[ ADDRA[11:3] ] [ ADDRA[2:0] ];
											end
							2'b01 : begin
											DOUTAP0 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 ];
											DOUTAP1 = MEM_512_9[ ADDRA[10:2] ] [ ADDRA[1:0] * 2 + 1 ];
									end
							2'b10 : begin
											DOUTAP0 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 ];
											DOUTAP1 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 1 ];
											DOUTAP2 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 2 ];
											DOUTAP3 = MEM_512_9[ ADDRA[9:1] ] [ ADDRA[0] * 4 + 3 ];
									end
							2'b11 : begin
											{DOUTAP8, DOUTAP7, DOUTAP6, DOUTAP5, DOUTAP4, 
																DOUTAP3, DOUTAP2, DOUTAP1, DOUTAP0} = MEM_512_9[ ADDRA[8:0] ];
											end
							default:
								 begin
									if ( WARNING_MSGS_ON == 1 )
										$display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
								end
					endcase
          `DATA_A_OUT = drive_data_x (ADDRB, ADDRA, {WIDTHB1,WIDTHB0}, {WIDTHA1,WIDTHA0}, `DATA_A_OUT);
				end
      end
			

      case (`BLKB_WIDTH_CFG)
            2'b00 : begin

                 MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ] = DINB0_reg;

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                    DOUTBP0 = DINB0_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                    DOUTBP0_stg1 = DINB0_bypass;
                  end
                 end
                end
            2'b01 : begin

                 MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ] = DINB0_reg;
                 MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ] = DINB1_reg;

                 if (WMODEB_int == 1'b1) begin
                   if (PIPEB_int == 1'b0) begin
                     DOUTBP0 = DINB0_bypass;
                     DOUTBP1 = DINB1_bypass;
                   end else if (PIPEB_int == 1'b1) begin
                     DOUTBP0_stg1 = DINB0_bypass;
                     DOUTBP1_stg1 = DINB1_bypass;
                   end
                 end 
                end
            2'b10 : begin

                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ] = DINB0_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ] = DINB1_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ] = DINB2_reg;
                 MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ] = DINB3_reg;

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                   DOUTBP0 = DINB0_bypass;
                   DOUTBP1 = DINB1_bypass;
                   DOUTBP2 = DINB2_bypass;
                   DOUTBP3 = DINB3_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                   DOUTBP0_stg1 = DINB0_bypass;
                   DOUTBP1_stg1 = DINB1_bypass;
                   DOUTBP2_stg1 = DINB2_bypass;
                   DOUTBP3_stg1 = DINB3_bypass;
                  end
                 end
                end
            2'b11 : begin

                 MEM_512_9[ ADDRB[8:0] ] = {DINB8_reg,DINB7_reg,DINB6_reg,DINB5_reg,DINB4_reg,DINB3_reg,DINB2_reg,DINB1_reg,DINB0_reg};

                 if (WMODEB_int == 1'b1) begin
                  if (PIPEB_int == 1'b0) begin
                   DOUTBP0 = DINB0_bypass;
                   DOUTBP1 = DINB1_bypass;
                   DOUTBP2 = DINB2_bypass;
                   DOUTBP3 = DINB3_bypass;
                   DOUTBP4 = DINB4_bypass;
                   DOUTBP5 = DINB5_bypass;
                   DOUTBP6 = DINB6_bypass;
                   DOUTBP7 = DINB7_bypass;
                   DOUTBP8 = DINB8_bypass;
                  end else if (PIPEB_int == 1'b1) begin
                   DOUTBP0_stg1 = DINB0_bypass;
                   DOUTBP1_stg1 = DINB1_bypass;
                   DOUTBP2_stg1 = DINB2_bypass;
                   DOUTBP3_stg1 = DINB3_bypass;
                   DOUTBP4_stg1 = DINB4_bypass;
                   DOUTBP5_stg1 = DINB5_bypass;
                   DOUTBP6_stg1 = DINB6_bypass;
                   DOUTBP7_stg1 = DINB7_bypass;
                   DOUTBP8_stg1 = DINB8_bypass;
                  end
                 end
                 end
           default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
               end
         endcase
   end 
	 else if ( (WENB_int == 1'b1) && ADDRB_VALID ) begin
		// Read
		CLKB_rd_re = $time;

        if (PIPEB_int == 1'b0) begin 
					case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
                    end
            2'b01 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
                    DOUTBP1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTBP0 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
                    DOUTBP1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
                    DOUTBP2 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
                    DOUTBP3 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTBP8, DOUTBP7, DOUTBP6, DOUTBP5, DOUTBP4,
                              DOUTBP3, DOUTBP2, DOUTBP1, DOUTBP0} = MEM_512_9[ ADDRB[8:0] ];
                    end
            default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
               end
					endcase
					
					// Check for Write from Port A and Read from Port B to the same address, read data on Port B is driven to X
					if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                                 ((CLKA_wr_re + TC2CWRH) > CLKB_rd_re) ) begin
						$display (" ** Warning: Port A Write and Port B Read to same address at same time. Port B read data is unpredictable, driving read data to X.");
						$display (" Time: %0.1f Instance: %m ", $realtime );
						`DATA_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATA_B_OUT);
					end
				end 
				else if (PIPEB_int == 1'b1) begin
					case (`BLKB_WIDTH_CFG)
            2'b00 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[11:3] ] [ ADDRB[2:0] ];
                    end
            2'b01 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[10:2] ] [ ADDRB[1:0] * 2 + 1 ];
                    end
            2'b10 : begin
                    DOUTBP0_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 ];
                    DOUTBP1_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 1 ];
                    DOUTBP2_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 2 ];
                    DOUTBP3_stg1 = MEM_512_9[ ADDRB[9:1] ] [ ADDRB[0] * 4 + 3 ];
                    end
            2'b11 : begin
                    {DOUTBP8_stg1, DOUTBP7_stg1, DOUTBP6_stg1, DOUTBP5_stg1, DOUTBP4_stg1,
                                   DOUTBP3_stg1, DOUTBP2_stg1, DOUTBP1_stg1, DOUTBP0_stg1} = MEM_512_9[ ADDRB[8:0] ];
                    end
            default:
               begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
               end
					endcase
					// Check for Write from Port A and Read from Port B to the same address, read data on Port B is driven to X
					if ( (WENA_lat == 1'b0) && same_addr(ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}) &&
                                                                  ((CLKA_wr_re + TC2CWRH) > CLKB_rd_re) ) begin
						$display (" ** Warning: Port A Write and Port B Read to same address at same time. Port B read data is unpredictable, driving read data to X. Updating memory contents at conflicting address with X.");
						$display (" Time: %0.1f Instance: %m ", $realtime );
						`DATAP_B_OUT = drive_data_x (ADDRA, ADDRB, {WIDTHA1,WIDTHA0}, {WIDTHB1,WIDTHB0}, `DATAP_B_OUT);
					end

       end else begin
                   if ( WARNING_MSGS_ON == 1 )
                     $display ("Warning: PIPEB unknown at time %d ns, no data was read. Instance: %m", $time); 
                   DOUTBP0 = 1'bx;
                   DOUTBP1 = 1'bx;
                   DOUTBP2 = 1'bx;
                   DOUTBP3 = 1'bx;
                   DOUTBP4 = 1'bx;
                   DOUTBP5 = 1'bx;
                   DOUTBP6 = 1'bx;
                   DOUTBP7 = 1'bx;
                   DOUTBP8 = 1'bx;
                end
      end else if ( (WENB_int == 1'b0) && (ADDRB_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Write Address on port B, Write Not Initiated. Instance: %m");
      end else if ( (WENB_int == 1'b1) && (ADDRB_VALID == 0) ) begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Illegal Read Address on port B, Read Not Initiated. Instance: %m");
      end else begin
        if ( WARNING_MSGS_ON == 1 )
          $display("Warning: WENB is unknown at time %d ns. Instance: %m", $time);
      end
    end
 end


 // function to check if write and read operations are accessing the same memory location

 function same_addr;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   integer       wr_addr, rd_addr;
   begin
     same_addr = 1'b0;
     if ( ww > rw ) begin
       rd_addr = raddr >> (  ww - rw );
       wr_addr = waddr;
     end
     else if ( rw > ww )begin
       rd_addr = raddr;
       wr_addr = waddr >> (  rw - ww );
     end
     else begin
       rd_addr = raddr;
       wr_addr = waddr;
     end
     if ( wr_addr == rd_addr ) begin
       same_addr = 1'b1;
     end
   end
 endfunction


 // function to drive read data bus to "x" depending on width configuration

 function [8:0] drive_data_x;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   input [8:0]   rd_data;
   integer       index, i;
   begin
     drive_data_x = rd_data;
     case(rw)
       2'b00 : begin
                 drive_data_x [ 0 ] = 1'bx;
               end
       2'b01 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[0] ] = 1'bx;
                 else
                   drive_data_x [ 1:0 ] = 2'bx;
               end
       2'b10 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[1:0] ] = 1'bx;
                 else if ( ww == 2'b01 ) begin
                   index = waddr[0] * 2;
                   for ( i=index; i<index+2; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else
                   drive_data_x [ 3:0 ] = 4'bx;
               end
       2'b11 : begin
                 if ( ww == 2'b00 )
                   drive_data_x [ waddr[2:0] ] = 1'bx;
                 else if ( ww == 2'b01 ) begin
                   index = waddr[1:0] * 2;
                   for ( i=index; i<index+2; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else if ( ww == 2'b10 ) begin
                   index = waddr[0] * 4;
                   for ( i=index; i<index+4; i=i+1 )
                     drive_data_x [ i ] = 1'bx;
                 end else
                   drive_data_x [ 8:0 ] = 9'bx;
               end
       default: begin
                  $display ("Warning: invalid WIDTH configuration at time %d ns, Legal Width: 1,2,4,9. Instance: %m", $time);
                end
      endcase
   end

 endfunction

 // function to convert addr vector to integer
 
 function integer get_address;
   input [11:0] addr_signal;
   input [ 1:0] width;

   reg   [11:0] addrsignal;
   integer ADDR;

   begin
     // the address calculation is based on  width,  because we assume that
     // users (or actgen) will connect low unused address pin to GND (1'b0), otherwise it may cause problem !

     // for dynamic configuration, shift address bits right by width, aligns them to 2**11 address space
     //if ( DYNAMIC == 1 ) 
     //  addrsignal = addr_signal >> width;
     //else
     addrsignal = addr_signal;


     ADDR =  addrsignal[11]*2048 + addrsignal[10]*1024 + addrsignal[9]*512 + addrsignal[8]*256 +
             addrsignal[7]*128   + addrsignal[6]*64    + addrsignal[5]*32  + addrsignal[4]*16  +
             addrsignal[3]*8     + addrsignal[2]*4     + addrsignal[1]*2   + addrsignal[0]*1   ;

     get_address = ADDR;
   end
 endfunction


endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CORERAM4K9 ----

//---- MODULE CORERAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : CORERAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ps / 1 ps

module CORERAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                 WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                 RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                 RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                 WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 

parameter TC2CRWH = 503;
parameter TC2CWRH = 587;

input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

reg RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;
reg RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg;
reg RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

time WCLK_re;
time RCLK_re;

reg [8:0] MEM_512_9 [0:511];

reg NOTIFY_REG;

integer RADDR;           
integer WADDR;           
integer DEPTH;
integer MAXADD;

reg RADDR_VALID;
reg WADDR_VALID;

reg WEN_lat, REN_lat;

`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}
`define DATA_WIDTH_18 {RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0}
`define DATAP_WIDTH_18 {RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg,RDP8_stg,                            RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg}

buf b0(WCLK_int, WCLK);
buf b1(RCLK_int, RCLK);
buf b2(WEN_int,WEN);
buf b3(REN_int,REN);
buf b4(RESET_int, RESET);

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

parameter DYNAMIC = 1;
parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.
  initial
    begin
    
      if ( WARNING_MSGS_ON == 0 )
        $display ( "Note: RAM512X18 warnings disabled. Set WARNING_MSGS_ON = 1 to enable." );

      if ( MEMORYFILE != "")
        $readmemb ( MEMORYFILE, MEM_512_9 );
      else
        begin
          //if ( WARNING_MSGS_ON == 1 )
            //$display ( "Note: Module %m, memory initialization file parameter MEMORYFILE not defined" );
        end
    end

always @(WCLK_int === 1'bx )
begin
  if ($time > 0) begin
    if (WEN_int == 1'b0) begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning : WCLK went unknown at time %0.1f. Instance: %m\n",$realtime);
    end
  end
end

  always @(RCLK_int === 1'bx )
      begin
	  if ($time > 0) begin
	      if (REN_int == 1'b0) begin
		  if ( WARNING_MSGS_ON == 1 )
		      $display("Warning : RCLK went unknown at time %0.1f. Instance: %m\n",$realtime);
	      end
	  end
      end

  always @(RESET_int )
      begin
	  if(RESET_int === 1'b0 )
	      begin
		  
		  case({RW1,RW0})
		     2'b01 : begin
			 RDP0 = 1'b0;
			 RDP1 = 1'b0;
			 RDP2 = 1'b0;
			 RDP3 = 1'b0;
			 RDP4 = 1'b0;
			 RDP5 = 1'b0;
			 RDP6 = 1'b0;
			 RDP7 = 1'b0;
			 RDP8 = 1'b0;
			 if (PIPE_int == 1'b1) begin
			     RDP0_stg = 1'b0;
			     RDP1_stg = 1'b0;
			     RDP2_stg = 1'b0;
			     RDP3_stg = 1'b0;
			     RDP4_stg = 1'b0;
			     RDP5_stg = 1'b0;
			     RDP6_stg = 1'b0;
			     RDP7_stg = 1'b0;
			     RDP8_stg = 1'b0;
			 end
		     end
		     2'b10 : begin
			 RDP0 = 1'b0;
			 RDP1 = 1'b0;
			 RDP2 = 1'b0;
			 RDP3 = 1'b0;
			 RDP4 = 1'b0;
			 RDP5 = 1'b0;
			 RDP6 = 1'b0;
			 RDP7 = 1'b0;
			 RDP8 = 1'b0;
			 RDP9 = 1'b0;
			 RDP10 = 1'b0;
			 RDP11 = 1'b0;
			 RDP12 = 1'b0;
			 RDP13 = 1'b0;
			 RDP14 = 1'b0;
			 RDP15 = 1'b0;
			 RDP16 = 1'b0;
			 RDP17 = 1'b0;
			 if (PIPE_int == 1'b1) begin
			     RDP0_stg = 1'b0;
			     RDP1_stg = 1'b0;
			     RDP2_stg = 1'b0;
			     RDP3_stg = 1'b0;
			     RDP4_stg = 1'b0;
			     RDP5_stg = 1'b0;
			     RDP6_stg = 1'b0;
			     RDP7_stg = 1'b0;
			     RDP8_stg = 1'b0;
			     RDP9_stg = 1'b0;
			     RDP10_stg = 1'b0;
			     RDP11_stg = 1'b0;
			     RDP12_stg = 1'b0;
			     RDP13_stg = 1'b0;
			     RDP14_stg = 1'b0;
			     RDP15_stg = 1'b0;
			     RDP16_stg = 1'b0;
			     RDP17_stg = 1'b0;
			 end
		     end
		     default : begin
			 //if ( WARNING_MSGS_ON == 1 )
			 //  $display ("Warning: RW at time %d ns.", $time);
		     end
		  endcase
	      end
      end // Reset

always @(posedge WCLK_int) begin
  
  WEN_lat = WEN_int;

  if ((WEN_int == 1'b0) && (RESET_int == 1'b1))  begin

    WCLK_re     = $time;
    WADDR       = get_address( `WADDR_BUS, {WW1,WW0} ); // call address calculation function to get write address
    WADDR_VALID = 1;

    if ( DYNAMIC == 1 && {WW1,WW0} == 2'b10 ) begin
      WADDR = WADDR >> 1;
    end

    if ((^WADDR) === 1'bx) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on write port at time %0.1f! Instance: %m", $realtime);
    end
    else if (({WW1,WW0} == 2'b01) && (WADDR > 511)) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end
    else if (({WW1,WW0} == 2'b10) && (WADDR > 255)) begin
      WADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display(" Warning: Illegal address on port A at time %0.1f! Instance: %m", $realtime);
    end

    if (WADDR_VALID) begin

      // Check for Write and Read to the same address, write is not affected
      if ( (REN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0} ) &&
                              ((RCLK_re + TC2CRWH) > WCLK_re) ) begin
        $display (" ** Warning: Read and Write to same address at same time.  RD is unpredictable, driving RD to X ");
        $display (" Time: %0.1f Instance: %m ", $realtime );

        if (PIPE_int == 1'b1)
          `DATAP_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATAP_WIDTH_18);
        else if (PIPE_int == 1'b0)
          `DATA_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATA_WIDTH_18);
      end

      case ({WW1,WW0})
            2'b01 : begin
                    MEM_512_9 [ WADDR ] = {WD8_int, WD7_int, WD6_int, WD5_int, WD4_int, WD3_int, WD2_int, WD1_int, WD0_int};
                    end
            2'b10 : begin
                    MEM_512_9 [ WADDR[7:0] * 2 ] = {WD8_int,WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int};
                    MEM_512_9 [ WADDR[7:0] * 2  + 1 ] = {WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int};
                    end
          default : begin
                      if ( WARNING_MSGS_ON == 1 )
                        $display("Warning: WW value unknown at time %d. Instance: %m",$time);
                    end
      endcase
    end
    else begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal Write Address, Write Not Initiated. Instance: %m");
    end
  end else if (WEN_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: WEN went unknown at time %d ns. Instance: %m", $time);
  end 
end


always @(posedge RCLK_int) begin

    REN_lat = REN_int;

    if (PIPE_int == 1'b1) begin
     case({RW1,RW0})
       2'b01 : begin
                RDP0 = RDP0_stg;
                RDP1 = RDP1_stg;
                RDP2 = RDP2_stg;
                RDP3 = RDP3_stg;
                RDP4 = RDP4_stg;
                RDP5 = RDP5_stg;
                RDP6 = RDP6_stg;
                RDP7 = RDP7_stg;
                RDP8 = RDP8_stg;
               end
       2'b10 : begin
                RDP0 = RDP0_stg;
                RDP1 = RDP1_stg;
                RDP2 = RDP2_stg;
                RDP3 = RDP3_stg;
                RDP4 = RDP4_stg;
                RDP5 = RDP5_stg;
                RDP6 = RDP6_stg;
                RDP7 = RDP7_stg;
                RDP8 = RDP8_stg;
                RDP9 = RDP9_stg;
                RDP10 = RDP10_stg;
                RDP11 = RDP11_stg;
                RDP12 = RDP12_stg;
                RDP13 = RDP13_stg;
                RDP14 = RDP14_stg;
                RDP15 = RDP15_stg;
                RDP16 = RDP16_stg;
                RDP17 = RDP17_stg;
              end
       default : begin
                  if ( WARNING_MSGS_ON == 1 )
                    $display ("Warning: RW unknown at time %d ns. Instance: %m", $time);
                 end
     endcase
    end 
    else if (PIPE_int == 1'bx) begin
      if ( WARNING_MSGS_ON == 1 )
        $display ("Warning: PIPE unknown at time %d ns, no data was read. Instance: %m", $time);
      RDP0 = 1'bx;
      RDP1 = 1'bx;
      RDP2 = 1'bx;
      RDP3 = 1'bx;
      RDP4 = 1'bx;
      RDP5 = 1'bx;
      RDP6 = 1'bx;
      RDP7 = 1'bx;
      RDP8 = 1'bx;
      RDP9 = 1'bx;
      RDP10 = 1'bx;
      RDP11 = 1'bx;
      RDP12 = 1'bx;
      RDP13 = 1'bx;
      RDP14 = 1'bx;
      RDP15 = 1'bx;
      RDP16 = 1'bx;
      RDP17 = 1'bx;
    end


  if ((REN_int == 1'b0 ) && (RESET_int == 1'b1)) begin

    RCLK_re     = $time;
    RADDR       = get_address( `RADDR_BUS, {RW1,RW0} );
    RADDR_VALID = 1;

    if ( DYNAMIC == 1 && ({RW1,RW0} == 2'b10) ) begin
      RADDR = RADDR >> 1;
    end

    if ((^RADDR) === 1'bx) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f! Instance: %m", $realtime);
    end
    else if (({RW1,RW0} == 2'b01) && (RADDR > 511)) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f! Instance: %m", $realtime);
    end
    else if (({RW1,RW0} == 2'b10) && (RADDR > 255)) begin
      RADDR_VALID = 0;
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal address on read port at time %0.1f! Instance: %m", $realtime);
    end


    // shift the address bits left by 1 while accessing the memory array with width=10
    //if ( {RW1,RW0} == 2'b10 )
    //  RADDR = RADDR << 1;

    if (RADDR_VALID) begin

      if (PIPE_int == 1'b0) begin
        case({RW1,RW0})
          2'b01 : begin
                  {RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0} = MEM_512_9 [ RADDR ];
                end
          2'b10 : begin
                    {RDP8, RDP7, RDP6, RDP5, RDP4, RDP3, RDP2, RDP1, RDP0} = MEM_512_9 [ RADDR[7:0] * 2 ];
                    {RDP17, RDP16, RDP15, RDP14, RDP13, RDP12, RDP11, RDP10, RDP9} = MEM_512_9 [ RADDR[7:0] * 2 + 1 ];
                  end
        default : begin
                    if ( WARNING_MSGS_ON == 1 )
                      $display ("Warning: RW at time %d ns. Instance: %m", $time);
                  end
        endcase

        // Check for Write and Read to the same address
        if ( (WEN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0}) &&
                            ((WCLK_re + TC2CWRH) > RCLK_re)) begin
          $display (" ** Warning: Write and Read to same address at same time.  RD is unpredictable, driving RD to X");
          $display (" Time: %0.1f Instance: %m ", $realtime );
          `DATA_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATA_WIDTH_18);
        end

      end else if (PIPE_int == 1'b1) begin
        case({RW1,RW0})
          2'b01 : begin
                    {RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg} = MEM_512_9 [ RADDR ];
                  end
          2'b10 : begin
                    {RDP8_stg,RDP7_stg,RDP6_stg,RDP5_stg,RDP4_stg,RDP3_stg,RDP2_stg,RDP1_stg,RDP0_stg} = MEM_512_9 [ RADDR[7:0] * 2 ];
                    {RDP17_stg,RDP16_stg,RDP15_stg,RDP14_stg,RDP13_stg,RDP12_stg,RDP11_stg,RDP10_stg,RDP9_stg} = MEM_512_9 [ RADDR[7:0] * 2 + 1 ];
                  end
          default : begin
                      if ( WARNING_MSGS_ON == 1 )
                        $display ("Warning: RW unknown at time %d ns. Instance: %m", $time);
                    end
        endcase 

        // Check for Write and Read to the same address
        if ( (WEN_lat == 1'b0) && same_addr(WADDR, RADDR, {WW1,WW0}, {RW1,RW0}) &&
                            ((WCLK_re + TC2CWRH) > RCLK_re)) begin
          $display (" ** Warning: Write and Read to same address at same time.  RD is unpredictable, driving RD to X");
          $display (" Time: %0.1f Instance: %m ", $realtime );
          `DATAP_WIDTH_18 = drive_rd_x (WADDR, RADDR, {WW1,WW0}, {RW1,RW0}, `DATAP_WIDTH_18);
        end

      end else begin
                if ( WARNING_MSGS_ON == 1 )
                  $display ("Warning: PIPE unknown at time %d ns, no data was read. Instance: %m", $time);
                RDP0 = 1'bx;
                RDP1 = 1'bx;
                RDP2 = 1'bx;
                RDP3 = 1'bx;
                RDP4 = 1'bx;
                RDP5 = 1'bx;
                RDP6 = 1'bx;
                RDP7 = 1'bx;
                RDP8 = 1'bx;
                RDP9 = 1'bx;
                RDP10 = 1'bx;
                RDP11 = 1'bx;
                RDP12 = 1'bx;
                RDP13 = 1'bx;
                RDP14 = 1'bx;
                RDP15 = 1'bx;
                RDP16 = 1'bx;
                RDP17 = 1'bx;
              end
    end else begin
      if ( WARNING_MSGS_ON == 1 )
        $display("Warning: Illegal Read Address, Read Not Initiated. Instance: %m");
    end

  end else if (REN_int == 1'bx) begin
    if ( WARNING_MSGS_ON == 1 )
      $display ("Warning: REN went unknown at time %d ns. Instance: %m", $time);
  end 

 end


 // function to check if write and read operations are accessing the same memory location

 function same_addr;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   integer wr_addr, rd_addr;
   begin
     same_addr = 1'b0;
     if ( ww > rw ) begin
       rd_addr = raddr >> (  ww - rw );
       wr_addr = waddr;
     end
     else if ( rw > ww )begin
       rd_addr = raddr;
       wr_addr = waddr >> (  rw - ww );
     end
     else begin
       rd_addr = raddr;
       wr_addr = waddr;
     end
     if ( wr_addr == rd_addr ) begin
       same_addr = 1'b1;
     end
   end
 endfunction


 // function to drive read data bus to "x" depending on width configuration

 function [17:0] drive_rd_x;
   input integer waddr, raddr;
   input [1:0]   ww, rw;
   input [17:0]  rd_data;
   integer       index, i;
   begin
     drive_rd_x = rd_data;
     case(rw)
       2'b01 : begin
                 drive_rd_x [ 8:0 ] =  9'bx;
               end
       2'b10 : begin
                 if ( ww == 2'b01 ) begin
                   index = waddr[0] * 9;
                   for ( i=index; i<index+9; i=i+1 )
                     drive_rd_x [ i ] =  1'bx;
                 end else
                   drive_rd_x [ 17:0 ] =  18'bx;
               end
       default: begin
                  $display("Warning : Invalid READ WIDTH at time %d ns,Legal Width: 9,18. Instance: %m",$time);
                end
      endcase
   end

 endfunction


 function integer get_address;

   input [8:0] addr_signal;
   input [1:0] width;

   reg   [8:0] addrsignal;
   integer     ADDR;

   begin
     // the address calculation is based on  width,  because we assume that
     // users (or actgen) will connect upper unused address pin to GND (1'b0), otherwise it may cause problem !

     // if instantiated in FLEXRAM and if WW/RW[1:0] = 2'b10, right shift address bits by 1 for address checks

     //if ( DYNAMIC == 1 && width == 2'b10 )
     //  addrsignal = addr_signal >> 1;
     //else
     addrsignal = addr_signal;

     ADDR =  addrsignal[8]*256 + addrsignal[7]*128 + addrsignal[6]*64 + addrsignal[5]*32 +
             addrsignal[4]*16  + addrsignal[3]*8   + addrsignal[2]*4  + addrsignal[1]*2  + addrsignal[0]*1;

     get_address = ADDR;
   end

 endfunction


endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE CORERAM512X18 ----

//---- MODULE RAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : RAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps  / 10 ps

module RAM4K9 (
          ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, 
          ADDRA4,  ADDRA3,  ADDRA2, ADDRA1, ADDRA0, DINA8,  DINA7,  DINA6,
          DINA5,   DINA4,   DINA3,  DINA2,  DINA1,  DINA0,  DOUTA8, DOUTA7,
          DOUTA6,  DOUTA5,  DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
          WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA,
          ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
          ADDRB4,  ADDRB3,  ADDRB2, ADDRB1, ADDRB0, DINB8,  DINB7,  DINB6,
          DINB5,   DINB4,   DINB3,  DINB2,  DINB1,  DINB0,  DOUTB8, DOUTB7,
          DOUTB6,  DOUTB5,  DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
          WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET
       );


input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8,   DINA7,   DINA6,  DINA5,  DINA4,  DINA3,  DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA;

input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8,   DINB7,   DINB6,  DINB5,  DINB4,  DINB3,  DINB2,  DINB1,  DINB0;
input WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 

wire CLKA_int,    CLKB_int;
wire WENA_int,    WENB_int,    WMODEA_int,  WMODEB_int;
wire BLKA_int,    BLKB_int,    RESET_int,   PIPEA_int,   PIPEB_int;
wire WIDTHA1_int, WIDTHA0_int, WIDTHB1_int, WIDTHB0_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int;
wire ADDRA5_int,  ADDRA4_int,  ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int;
wire ADDRB5_int,  ADDRB4_int,  ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg NOTIFY_REG;

wire BLKA_EN;
wire BLKB_EN;

wire BLKA_WEN;
wire BLKB_WEN;

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign BLKA_EN  = ~BLKA_int & RESET_int;
assign BLKB_EN  = ~BLKB_int & RESET_int;
assign BLKA_WEN = ~BLKA_int & RESET_int  & ~WENA_int;
assign BLKB_WEN = ~BLKB_int & RESET_int  & ~WENB_int;

buf b0  ( CLKA_int,       CLKA );
buf b1  ( CLKB_int,       CLKB );
buf b2  ( WENA_int,       WENA );
buf b3  ( WENB_int,       WENB );
 
buf b4  ( DINA0_int,     DINA0 );
buf b5  ( DINA1_int,     DINA1 );
buf b6  ( DINA2_int,     DINA2 );
buf b7  ( DINA3_int,     DINA3 );
buf b8  ( DINA4_int,     DINA4 );
buf b9  ( DINA5_int,     DINA5 );
buf b10 ( DINA6_int,     DINA6 );
buf b11 ( DINA7_int,     DINA7 );
buf b12 ( DINA8_int,     DINA8 );
 

buf b13 ( DINB0_int,     DINB0 );
buf b14 ( DINB1_int,     DINB1 );
buf b15 ( DINB2_int,     DINB2 );
buf b16 ( DINB3_int,     DINB3 );
buf b17 ( DINB4_int,     DINB4 );
buf b18 ( DINB5_int,     DINB5 );
buf b19 ( DINB6_int,     DINB6 );
buf b20 ( DINB7_int,     DINB7 );
buf b21 ( DINB8_int,     DINB8 );

buf b22 ( ADDRA0_int,   ADDRA0 );
buf b23 ( ADDRA1_int,   ADDRA1 );
buf b24 ( ADDRA2_int,   ADDRA2 );
buf b25 ( ADDRA3_int,   ADDRA3 );
buf b26 ( ADDRA4_int,   ADDRA4 );
buf b27 ( ADDRA5_int,   ADDRA5 );
buf b28 ( ADDRA6_int,   ADDRA6 );
buf b29 ( ADDRA7_int,   ADDRA7 );
buf b30 ( ADDRA8_int,   ADDRA8 );
buf b31 ( ADDRA9_int,   ADDRA9 );
buf b32 ( ADDRA10_int, ADDRA10 );
buf b33 ( ADDRA11_int, ADDRA11 );
 
buf b34 ( ADDRB0_int,   ADDRB0 );
buf b35 ( ADDRB1_int,   ADDRB1 );
buf b36 ( ADDRB2_int,   ADDRB2 );
buf b37 ( ADDRB3_int,   ADDRB3 );
buf b38 ( ADDRB4_int,   ADDRB4 );
buf b39 ( ADDRB5_int,   ADDRB5 );
buf b40 ( ADDRB6_int,   ADDRB6 );
buf b41 ( ADDRB7_int,   ADDRB7 );
buf b42 ( ADDRB8_int,   ADDRB8 );
buf b43 ( ADDRB9_int,   ADDRB9 );
buf b44 ( ADDRB10_int, ADDRB10 );
buf b45 ( ADDRB11_int, ADDRB11 );

buf b46 ( RESET_int,     RESET );
buf b47 ( BLKA_int,       BLKA );
buf b48 ( BLKB_int,       BLKB );
buf b49 ( PIPEA_int,     PIPEA );
buf b50 ( PIPEB_int,     PIPEB );
buf b51 ( WMODEA_int,   WMODEA );
buf b52 ( WMODEB_int,   WMODEB );

buf b53 ( WIDTHA1_int, WIDTHA1 );
buf b54 ( WIDTHA0_int, WIDTHA0 );
buf b55 ( WIDTHB1_int, WIDTHB1 );
buf b56 ( WIDTHB0_int, WIDTHB0 );

  // Instantiation of core ram4k9 cell with pure functionality

  CORERAM4K9 STATCONFIG (

                .ADDRA11 ( ADDRA11_int ), .ADDRA10 ( ADDRA10_int ), .ADDRA9 ( ADDRA9_int ), 
                .ADDRA8  ( ADDRA8_int  ), .ADDRA7  ( ADDRA7_int  ), .ADDRA6 ( ADDRA6_int ),
                .ADDRA5  ( ADDRA5_int  ), .ADDRA4  ( ADDRA4_int  ), .ADDRA3 ( ADDRA3_int ),
                .ADDRA2  ( ADDRA2_int  ), .ADDRA1  ( ADDRA1_int  ), .ADDRA0 ( ADDRA0_int ), 
                .DINA8   ( DINA8_int   ), .DINA7   ( DINA7_int   ), .DINA6  ( DINA6_int  ),
                .DINA5   ( DINA5_int   ), .DINA4   ( DINA4_int   ), .DINA3  ( DINA3_int  ), 
                .DINA2   ( DINA2_int   ), .DINA1   ( DINA1_int   ), .DINA0  ( DINA0_int  ),
                .DOUTA8  ( DOUTA8      ), .DOUTA7  ( DOUTA7      ), .DOUTA6 ( DOUTA6     ),
                .DOUTA5  ( DOUTA5      ), .DOUTA4  ( DOUTA4      ), .DOUTA3 ( DOUTA3     ),
                .DOUTA2  ( DOUTA2      ), .DOUTA1  ( DOUTA1      ), .DOUTA0 ( DOUTA0     ),
                .WIDTHA1 ( WIDTHA1_int ), .WIDTHA0 ( WIDTHA0_int ), .PIPEA  ( PIPEA_int  ), 
                .WMODEA  ( WMODEA_int  ), .BLKA    ( BLKA_int    ), .WENA   ( WENA_int   ),
                .CLKA    ( CLKA_int    ),
                .ADDRB11 ( ADDRB11_int ), .ADDRB10 ( ADDRB10_int ), .ADDRB9 ( ADDRB9_int ), 
                .ADDRB8  ( ADDRB8_int  ), .ADDRB7  ( ADDRB7_int  ), .ADDRB6 ( ADDRB6_int ), 
                .ADDRB5  ( ADDRB5_int  ), .ADDRB4  ( ADDRB4_int  ), .ADDRB3 ( ADDRB3_int ),
                .ADDRB2  ( ADDRB2_int  ), .ADDRB1  ( ADDRB1_int  ), .ADDRB0 ( ADDRB0_int ),
                .DINB8   ( DINB8_int   ), .DINB7   ( DINB7_int   ), .DINB6  ( DINB6_int  ),
                .DINB5   ( DINB5_int   ), .DINB4   ( DINB4_int   ), .DINB3  ( DINB3_int  ),
                .DINB2   ( DINB2_int   ), .DINB1   ( DINB1_int   ), .DINB0  ( DINB0_int  ),
                .DOUTB8  ( DOUTB8      ), .DOUTB7  ( DOUTB7      ), .DOUTB6 ( DOUTB6     ),
                .DOUTB5  ( DOUTB5      ), .DOUTB4  ( DOUTB4      ), .DOUTB3 ( DOUTB3     ),
                .DOUTB2  ( DOUTB2      ), .DOUTB1  ( DOUTB1      ), .DOUTB0 ( DOUTB0     ),
                .WIDTHB1 ( WIDTHB1_int ), .WIDTHB0 ( WIDTHB0_int ), .PIPEB  ( PIPEB_int  ), 
                .WMODEB  ( WMODEB_int  ), .BLKB    ( BLKB_int    ), .WENB   ( WENB_int   ),
                .CLKB    ( CLKB_int    ), 
                .RESET   ( RESET_int   )
   
             );

  defparam STATCONFIG.DYNAMIC = 0;
  defparam STATCONFIG.MEMORYFILE = MEMORYFILE;
  defparam STATCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;


  // timing section
  specify

      specparam   LibName     = "smartfusion";
      (posedge CLKA => (DOUTA0+:DOUTA0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA1+:DOUTA1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA2+:DOUTA2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA3+:DOUTA3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA4+:DOUTA4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA5+:DOUTA5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA6+:DOUTA6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA7+:DOUTA7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA8+:DOUTA8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (posedge CLKB => (DOUTB0+:DOUTB0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB1+:DOUTB1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB2+:DOUTB2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB3+:DOUTB3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB4+:DOUTB4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB5+:DOUTB5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB6+:DOUTB6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB7+:DOUTB7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB8+:DOUTB8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      (negedge RESET => (DOUTA0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (DOUTB0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      $width(posedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(posedge CLKB, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKB, 0.0, 0, NOTIFY_REG);

     
      $setup(posedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA11, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA10, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA9, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA0, 0.0, NOTIFY_REG);

      $setup(posedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA8, 0.0, NOTIFY_REG);
      $setup(posedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA7, 0.0, NOTIFY_REG);
      $setup(posedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA6, 0.0, NOTIFY_REG);
      $setup(posedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA5, 0.0, NOTIFY_REG);
      $setup(posedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA4, 0.0, NOTIFY_REG);
      $setup(posedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA3, 0.0, NOTIFY_REG);
      $setup(posedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA2, 0.0, NOTIFY_REG);
      $setup(posedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA1, 0.0, NOTIFY_REG);
      $setup(posedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA0, 0.0, NOTIFY_REG);


      $setup(posedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge WENA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&&RESET, negedge WENA, 0.0, NOTIFY_REG);

      $setup(posedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge BLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, negedge BLKA, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge CLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA,posedge RESET, 0.0, NOTIFY_REG);
      
      $recovery(posedge RESET, posedge CLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);


      $setup(posedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB11, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB10, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB9, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB0, 0.0, NOTIFY_REG);

      $setup(posedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB8, 0.0, NOTIFY_REG);
      $setup(posedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB7, 0.0, NOTIFY_REG);
      $setup(posedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB6, 0.0, NOTIFY_REG);
      $setup(posedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB5, 0.0, NOTIFY_REG);
      $setup(posedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB4, 0.0, NOTIFY_REG);
      $setup(posedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB3, 0.0, NOTIFY_REG);
      $setup(posedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB2, 0.0, NOTIFY_REG);
      $setup(posedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB1, 0.0, NOTIFY_REG);
      $setup(posedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB0, 0.0, NOTIFY_REG);


      $setup(posedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge WENB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge WENB, 0.0, NOTIFY_REG);

      $setup(posedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge BLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge BLKB, 0.0, NOTIFY_REG);

   endspecify
 endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE RAM4K9 ----

//---- MODULE RAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : RAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

module RAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                     WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                     RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                     RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                     WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 


input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

wire RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

wire RENABLE;
wire WENABLE;

reg NOTIFY_REG;




`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign RENABLE = ~REN_int & RESET_int;
assign WENABLE = ~WEN_int & RESET_int;

buf b0 ( WCLK_int,   WCLK );
buf b1 ( RCLK_int,   RCLK );
buf b2 ( WEN_int,     WEN );
buf b3 ( REN_int,     REN );
buf b4 ( RESET_int, RESET );

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

buf b42 ( WW1_int, WW1 );
buf b43 ( WW0_int, WW0 );
buf b44 ( RW1_int, RW1 );
buf b45 ( RW0_int, RW0 );

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

  CORERAM512X18 STATCONFIG (
                .RADDR8  ( RADDR8_int  ), .RADDR7  ( RADDR7_int  ), .RADDR6 ( RADDR6_int ),
                .RADDR5  ( RADDR5_int  ), .RADDR4  ( RADDR4_int  ), .RADDR3 ( RADDR3_int ),
                .RADDR2  ( RADDR2_int  ), .RADDR1  ( RADDR1_int  ), .RADDR0 ( RADDR0_int ),
                .WADDR8  ( WADDR8_int  ), .WADDR7  ( WADDR7_int  ), .WADDR6 ( WADDR6_int ),
                .WADDR5  ( WADDR5_int  ), .WADDR4  ( WADDR4_int  ), .WADDR3 ( WADDR3_int ),
                .WADDR2  ( WADDR2_int  ), .WADDR1  ( WADDR1_int  ), .WADDR0 ( WADDR0_int ),
                .RD17    ( RDP17       ), .RD16    ( RDP16       ), .RD15   ( RDP15      ),
                .RD14    ( RDP14       ), .RD13    ( RDP13       ), .RD12   ( RDP12      ),
                .RD11    ( RDP11       ), .RD10    ( RDP10       ), .RD9    ( RDP9       ),
                .RD8     ( RDP8        ), .RD7     ( RDP7        ), .RD6    ( RDP6       ),
                .RD5     ( RDP5        ), .RD4     ( RDP4        ), .RD3    ( RDP3       ),
                .RD2     ( RDP2        ), .RD1     ( RDP1        ), .RD0    ( RDP0       ),
                .WD17    ( WD17_int    ), .WD16    ( WD16_int    ), .WD15   ( WD15_int   ),
                .WD14    ( WD14_int    ), .WD13    ( WD13_int    ), .WD12   ( WD12_int   ),
                .WD11    ( WD11_int    ), .WD10    ( WD10_int    ), .WD9    ( WD9_int    ),
                .WD8     ( WD8_int     ), .WD7     ( WD7_int     ), .WD6    ( WD6_int    ),
                .WD5     ( WD5_int     ), .WD4     ( WD4_int     ), .WD3    ( WD3_int    ),
                .WD2     ( WD2_int     ), .WD1     ( WD1_int     ), .WD0    ( WD0_int    ),
                .RW1     ( RW1_int     ), .RW0     ( RW0_int     ), .REN    ( REN_int    ),
                .RCLK    ( RCLK_int    ), .WCLK    ( WCLK_int    ), .PIPE   ( PIPE_int   ),
                .WW1     ( WW1_int     ), .WW0     ( WW0_int     ), .WEN    ( WEN_int    ),
                .RESET   ( RESET_int   )

               );

  defparam STATCONFIG.DYNAMIC = 0;
  defparam STATCONFIG.MEMORYFILE = MEMORYFILE;
  defparam STATCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  specify

      specparam   LibName     = "smartfusion";
      (posedge RCLK => (RD0+:RD0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD1+:RD1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD2+:RD2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD3+:RD3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD4+:RD4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD5+:RD5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD6+:RD6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD7+:RD7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD8+:RD8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD9+:RD9) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD10+:RD10) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD11+:RD11) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD12+:RD12) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD13+:RD13) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD14+:RD14) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD15+:RD15) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD16+:RD16) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD17+:RD17) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (RD0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD9+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD10+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD11+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD12+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD13+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD14+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD15+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD16+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD17+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

 
      $setup(posedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $setup(negedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, posedge RADDR8, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, negedge RADDR8, 0.0, NOTIFY_REG);
      $setup(posedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge REN, 0.0, NOTIFY_REG);
 

      $setup(posedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR8, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR0, 0.0, NOTIFY_REG); 

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG); 
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG); 
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG); 
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG); 
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG); 
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG); 
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG); 
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG); 
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG); 
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG); 
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG); 
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG); 
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG); 
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG); 
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG); 
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG); 
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $setup(negedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, posedge WEN, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, negedge WEN, 0.0, NOTIFY_REG); 
 
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK,posedge RESET, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE RAM512X18 ----

//---- MODULE FLEXRAM4K9 ----
/*-----------------------------------------------------------------
 CELL NAME : FLEXRAM4K9
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps  / 10 ps

module FLEXRAM4K9 (
          ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, 
          ADDRA4,  ADDRA3,  ADDRA2, ADDRA1, ADDRA0, DINA8,  DINA7,  DINA6,
          DINA5,   DINA4,   DINA3,  DINA2,  DINA1,  DINA0,  DOUTA8, DOUTA7,
          DOUTA6,  DOUTA5,  DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0,
          WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA,
          ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5,
          ADDRB4,  ADDRB3,  ADDRB2, ADDRB1, ADDRB0, DINB8,  DINB7,  DINB6,
          DINB5,   DINB4,   DINB3,  DINB2,  DINB1,  DINB0,  DOUTB8, DOUTB7,
          DOUTB6,  DOUTB5,  DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0,
          WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET
       );


input ADDRA11, ADDRA10, ADDRA9, ADDRA8, ADDRA7, ADDRA6, ADDRA5, ADDRA4, ADDRA3, ADDRA2, ADDRA1, ADDRA0;
input DINA8,   DINA7,   DINA6,  DINA5,  DINA4,  DINA3,  DINA2, DINA1, DINA0;
input WIDTHA1, WIDTHA0, PIPEA,  WMODEA, BLKA,   WENA,   CLKA;

input ADDRB11, ADDRB10, ADDRB9, ADDRB8, ADDRB7, ADDRB6, ADDRB5, ADDRB4, ADDRB3, ADDRB2, ADDRB1, ADDRB0;
input DINB8,   DINB7,   DINB6,  DINB5,  DINB4,  DINB3,  DINB2,  DINB1,  DINB0;
input WIDTHB1, WIDTHB0, PIPEB,  WMODEB, BLKB,   WENB,   CLKB,   RESET;

output DOUTA8, DOUTA7, DOUTA6, DOUTA5, DOUTA4, DOUTA3, DOUTA2, DOUTA1, DOUTA0;
output DOUTB8, DOUTB7, DOUTB6, DOUTB5, DOUTB4, DOUTB3, DOUTB2, DOUTB1, DOUTB0; 

wire CLKA_int,    CLKB_int;
wire WENA_int,    WENB_int,    WMODEA_int,  WMODEB_int;
wire BLKA_int,    BLKB_int,    RESET_int,   PIPEA_int,   PIPEB_int;
wire WIDTHA1_int, WIDTHA0_int, WIDTHB1_int, WIDTHB0_int;

wire ADDRA11_int, ADDRA10_int, ADDRA9_int, ADDRA8_int, ADDRA7_int, ADDRA6_int;
wire ADDRA5_int,  ADDRA4_int,  ADDRA3_int, ADDRA2_int, ADDRA1_int, ADDRA0_int;

wire ADDRB11_int, ADDRB10_int, ADDRB9_int, ADDRB8_int, ADDRB7_int, ADDRB6_int;
wire ADDRB5_int,  ADDRB4_int,  ADDRB3_int, ADDRB2_int, ADDRB1_int, ADDRB0_int;

wire DINA8_int, DINA7_int, DINA6_int, DINA5_int, DINA4_int, DINA3_int, DINA2_int, DINA1_int, DINA0_int;
wire DINB8_int, DINB7_int, DINB6_int, DINB5_int, DINB4_int, DINB3_int, DINB2_int, DINB1_int, DINB0_int;

reg NOTIFY_REG;

wire BLKA_EN;
wire BLKB_EN;

wire BLKA_WEN;
wire BLKB_WEN;

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign BLKA_EN  = ~BLKA_int & RESET_int;
assign BLKB_EN  = ~BLKB_int & RESET_int;
assign BLKA_WEN = ~BLKA_int & RESET_int  & ~WENA_int;
assign BLKB_WEN = ~BLKB_int & RESET_int  & ~WENB_int;

buf b0  ( CLKA_int,       CLKA );
buf b1  ( CLKB_int,       CLKB );
buf b2  ( WENA_int,       WENA );
buf b3  ( WENB_int,       WENB );
 
buf b4  ( DINA0_int,     DINA0 );
buf b5  ( DINA1_int,     DINA1 );
buf b6  ( DINA2_int,     DINA2 );
buf b7  ( DINA3_int,     DINA3 );
buf b8  ( DINA4_int,     DINA4 );
buf b9  ( DINA5_int,     DINA5 );
buf b10 ( DINA6_int,     DINA6 );
buf b11 ( DINA7_int,     DINA7 );
buf b12 ( DINA8_int,     DINA8 );
 

buf b13 ( DINB0_int,     DINB0 );
buf b14 ( DINB1_int,     DINB1 );
buf b15 ( DINB2_int,     DINB2 );
buf b16 ( DINB3_int,     DINB3 );
buf b17 ( DINB4_int,     DINB4 );
buf b18 ( DINB5_int,     DINB5 );
buf b19 ( DINB6_int,     DINB6 );
buf b20 ( DINB7_int,     DINB7 );
buf b21 ( DINB8_int,     DINB8 );

buf b22 ( ADDRA0_int,   ADDRA0 );
buf b23 ( ADDRA1_int,   ADDRA1 );
buf b24 ( ADDRA2_int,   ADDRA2 );
buf b25 ( ADDRA3_int,   ADDRA3 );
buf b26 ( ADDRA4_int,   ADDRA4 );
buf b27 ( ADDRA5_int,   ADDRA5 );
buf b28 ( ADDRA6_int,   ADDRA6 );
buf b29 ( ADDRA7_int,   ADDRA7 );
buf b30 ( ADDRA8_int,   ADDRA8 );
buf b31 ( ADDRA9_int,   ADDRA9 );
buf b32 ( ADDRA10_int, ADDRA10 );
buf b33 ( ADDRA11_int, ADDRA11 );
 
buf b34 ( ADDRB0_int,   ADDRB0 );
buf b35 ( ADDRB1_int,   ADDRB1 );
buf b36 ( ADDRB2_int,   ADDRB2 );
buf b37 ( ADDRB3_int,   ADDRB3 );
buf b38 ( ADDRB4_int,   ADDRB4 );
buf b39 ( ADDRB5_int,   ADDRB5 );
buf b40 ( ADDRB6_int,   ADDRB6 );
buf b41 ( ADDRB7_int,   ADDRB7 );
buf b42 ( ADDRB8_int,   ADDRB8 );
buf b43 ( ADDRB9_int,   ADDRB9 );
buf b44 ( ADDRB10_int, ADDRB10 );
buf b45 ( ADDRB11_int, ADDRB11 );

buf b46 ( RESET_int,     RESET );
buf b47 ( BLKA_int,       BLKA );
buf b48 ( BLKB_int,       BLKB );
buf b49 ( PIPEA_int,     PIPEA );
buf b50 ( PIPEB_int,     PIPEB );
buf b51 ( WMODEA_int,   WMODEA );
buf b52 ( WMODEB_int,   WMODEB );

buf b53 ( WIDTHA1_int, WIDTHA1 );
buf b54 ( WIDTHA0_int, WIDTHA0 );
buf b55 ( WIDTHB1_int, WIDTHB1 );
buf b56 ( WIDTHB0_int, WIDTHB0 );

  // Instantiation of core ram4k9 cell with pure functionality

  CORERAM4K9 DYNCONFIG (

                .ADDRA11 ( ADDRA11_int ), .ADDRA10 ( ADDRA10_int ), .ADDRA9 ( ADDRA9_int ), 
                .ADDRA8  ( ADDRA8_int  ), .ADDRA7  ( ADDRA7_int  ), .ADDRA6 ( ADDRA6_int ),
                .ADDRA5  ( ADDRA5_int  ), .ADDRA4  ( ADDRA4_int  ), .ADDRA3 ( ADDRA3_int ),
                .ADDRA2  ( ADDRA2_int  ), .ADDRA1  ( ADDRA1_int  ), .ADDRA0 ( ADDRA0_int ), 
                .DINA8   ( DINA8_int   ), .DINA7   ( DINA7_int   ), .DINA6  ( DINA6_int  ),
                .DINA5   ( DINA5_int   ), .DINA4   ( DINA4_int   ), .DINA3  ( DINA3_int  ), 
                .DINA2   ( DINA2_int   ), .DINA1   ( DINA1_int   ), .DINA0  ( DINA0_int  ),
                .DOUTA8  ( DOUTA8      ), .DOUTA7  ( DOUTA7      ), .DOUTA6 ( DOUTA6     ),
                .DOUTA5  ( DOUTA5      ), .DOUTA4  ( DOUTA4      ), .DOUTA3 ( DOUTA3     ),
                .DOUTA2  ( DOUTA2      ), .DOUTA1  ( DOUTA1      ), .DOUTA0 ( DOUTA0     ),
                .WIDTHA1 ( WIDTHA1_int ), .WIDTHA0 ( WIDTHA0_int ), .PIPEA  ( PIPEA_int  ), 
                .WMODEA  ( WMODEA_int  ), .BLKA    ( BLKA_int    ), .WENA   ( WENA_int   ),
                .CLKA    ( CLKA_int    ),
                .ADDRB11 ( ADDRB11_int ), .ADDRB10 ( ADDRB10_int ), .ADDRB9 ( ADDRB9_int ), 
                .ADDRB8  ( ADDRB8_int  ), .ADDRB7  ( ADDRB7_int  ), .ADDRB6 ( ADDRB6_int ), 
                .ADDRB5  ( ADDRB5_int  ), .ADDRB4  ( ADDRB4_int  ), .ADDRB3 ( ADDRB3_int ),
                .ADDRB2  ( ADDRB2_int  ), .ADDRB1  ( ADDRB1_int  ), .ADDRB0 ( ADDRB0_int ),
                .DINB8   ( DINB8_int   ), .DINB7   ( DINB7_int   ), .DINB6  ( DINB6_int  ),
                .DINB5   ( DINB5_int   ), .DINB4   ( DINB4_int   ), .DINB3  ( DINB3_int  ),
                .DINB2   ( DINB2_int   ), .DINB1   ( DINB1_int   ), .DINB0  ( DINB0_int  ),
                .DOUTB8  ( DOUTB8      ), .DOUTB7  ( DOUTB7      ), .DOUTB6 ( DOUTB6     ),
                .DOUTB5  ( DOUTB5      ), .DOUTB4  ( DOUTB4      ), .DOUTB3 ( DOUTB3     ),
                .DOUTB2  ( DOUTB2      ), .DOUTB1  ( DOUTB1      ), .DOUTB0 ( DOUTB0     ),
                .WIDTHB1 ( WIDTHB1_int ), .WIDTHB0 ( WIDTHB0_int ), .PIPEB  ( PIPEB_int  ), 
                .WMODEB  ( WMODEB_int  ), .BLKB    ( BLKB_int    ), .WENB   ( WENB_int   ),
                .CLKB    ( CLKB_int    ), 
                .RESET   ( RESET_int   )
   
             );

  defparam DYNCONFIG.DYNAMIC = 1;
  defparam DYNCONFIG.MEMORYFILE = MEMORYFILE;
  defparam DYNCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  
  // timing section
  specify

      specparam   LibName     = "smartfusion";
      (posedge CLKA => (DOUTA0+:DOUTA0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA1+:DOUTA1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA2+:DOUTA2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA3+:DOUTA3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA4+:DOUTA4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA5+:DOUTA5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA6+:DOUTA6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA7+:DOUTA7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKA => (DOUTA8+:DOUTA8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (posedge CLKB => (DOUTB0+:DOUTB0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB1+:DOUTB1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB2+:DOUTB2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB3+:DOUTB3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB4+:DOUTB4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB5+:DOUTB5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB6+:DOUTB6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB7+:DOUTB7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge CLKB => (DOUTB8+:DOUTB8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      (negedge RESET => (DOUTA0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTA8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (DOUTB0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (DOUTB8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);


      $width(posedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKA, 0.0, 0, NOTIFY_REG);
      $width(posedge CLKB, 0.0, 0, NOTIFY_REG);
      $width(negedge CLKB, 0.0, 0, NOTIFY_REG);

     
      $setup(posedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA11, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA11, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA10, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA10, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA9, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA9, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA8, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA7, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA6, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA5, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA4, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA3, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA2, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA1, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRA0, posedge CLKA &&& BLKA_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, posedge ADDRA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_EN, negedge ADDRA0, 0.0, NOTIFY_REG);

      $setup(posedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA8, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA8, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA8, 0.0, NOTIFY_REG);
      $setup(posedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA7, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA7, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA7, 0.0, NOTIFY_REG);
      $setup(posedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA6, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA6, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA6, 0.0, NOTIFY_REG);
      $setup(posedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA5, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA5, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA5, 0.0, NOTIFY_REG);
      $setup(posedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA4, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA4, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA4, 0.0, NOTIFY_REG);
      $setup(posedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA3, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA3, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA3, 0.0, NOTIFY_REG);
      $setup(posedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA2, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA2, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA2, 0.0, NOTIFY_REG);
      $setup(posedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA1, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA1, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA1, 0.0, NOTIFY_REG);
      $setup(posedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINA0, posedge CLKA &&& BLKA_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, posedge DINA0, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& BLKA_WEN, negedge DINA0, 0.0, NOTIFY_REG);


      $setup(posedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge WENA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&&RESET, negedge WENA, 0.0, NOTIFY_REG);

      $setup(posedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKA, posedge CLKA &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, posedge BLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA &&& RESET, negedge BLKA, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge CLKA, 0.0, NOTIFY_REG);
      $hold(posedge CLKA,posedge RESET, 0.0, NOTIFY_REG);
      
      $recovery(posedge RESET, posedge CLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);


      $setup(posedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB11, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB11, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB11, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB10, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB10, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB10, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB9, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB9, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB9, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB8, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB8, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB7, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB7, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB6, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB6, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB5, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB5, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB4, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB4, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB3, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB3, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB2, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB2, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB1, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB1, 0.0, NOTIFY_REG);
      $setup(posedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $setup(negedge ADDRB0, posedge CLKB &&& BLKB_EN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, posedge ADDRB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_EN, negedge ADDRB0, 0.0, NOTIFY_REG);

      $setup(posedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB8, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB8, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB8, 0.0, NOTIFY_REG);
      $setup(posedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB7, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB7, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB7, 0.0, NOTIFY_REG);
      $setup(posedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB6, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB6, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB6, 0.0, NOTIFY_REG);
      $setup(posedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB5, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB5, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB5, 0.0, NOTIFY_REG);
      $setup(posedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB4, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB4, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB4, 0.0, NOTIFY_REG);
      $setup(posedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB3, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB3, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB3, 0.0, NOTIFY_REG);
      $setup(posedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB2, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB2, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB2, 0.0, NOTIFY_REG);
      $setup(posedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB1, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB1, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB1, 0.0, NOTIFY_REG);
      $setup(posedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $setup(negedge DINB0, posedge CLKB &&& BLKB_WEN, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, posedge DINB0, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& BLKB_WEN, negedge DINB0, 0.0, NOTIFY_REG);


      $setup(posedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge WENB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge WENB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge WENB, 0.0, NOTIFY_REG);

      $setup(posedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $setup(negedge BLKB, posedge CLKB &&& RESET, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, posedge BLKB, 0.0, NOTIFY_REG);
      $hold(posedge CLKB &&& RESET, negedge BLKB, 0.0, NOTIFY_REG);

   endspecify
 endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FLEXRAM4K9 ----

//---- MODULE FLEXRAM512X18 ----
/*-----------------------------------------------------------------
 CELL NAME : FLEXRAM512X18
-----------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 100 ps / 10 ps

module FLEXRAM512X18(RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0,
                     WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0,
                     RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,
                     RD3,RD2,RD1,RD0,WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,
                     WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0,RW1,WW1,RW0,WW0,REN,RCLK,WEN,WCLK,RESET,PIPE); 


input RADDR8,RADDR7,RADDR6,RADDR5,RADDR4,RADDR3,RADDR2,RADDR1,RADDR0;
input WADDR8,WADDR7,WADDR6,WADDR5,WADDR4,WADDR3,WADDR2,WADDR1,WADDR0;
input WD17,WD16,WD15,WD14,WD13,WD12,WD11,WD10,WD9,WD8,WD7,WD6,WD5,WD4,WD3,WD2,WD1,WD0;
input RW1,WW1,RW0, WW0,REN,RCLK,WEN,WCLK,RESET,PIPE;

output RD17,RD16,RD15,RD14,RD13,RD12,RD11,RD10,RD9,RD8,RD7,RD6,RD5,RD4,RD3,RD2,RD1,RD0;

wire RDP17,RDP16,RDP15,RDP14,RDP13,RDP12,RDP11,RDP10,RDP9,RDP8,RDP7,RDP6,RDP5,RDP4,RDP3,RDP2,RDP1,RDP0;

wire RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int;
wire WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int;
wire WD17_int,WD16_int,WD15_int,WD14_int,WD13_int,WD12_int,WD11_int,WD10_int,WD9_int,WD8_int;
wire WD7_int,WD6_int,WD5_int,WD4_int,WD3_int,WD2_int,WD1_int,WD0_int;
wire REN_int,RCLK_int,WEN_int,WCLK_int,RESET_int,PIPE_int;

wire RENABLE;
wire WENABLE;


reg NOTIFY_REG;

`define WADDR_BUS {WADDR8_int,WADDR7_int,WADDR6_int,WADDR5_int,WADDR4_int,WADDR3_int,WADDR2_int,WADDR1_int,WADDR0_int}
`define RADDR_BUS {RADDR8_int,RADDR7_int,RADDR6_int,RADDR5_int,RADDR4_int,RADDR3_int,RADDR2_int,RADDR1_int,RADDR0_int}

parameter MEMORYFILE = "";
parameter WARNING_MSGS_ON = 1; // Used to turn off warnings about read &
                               // write to same address at same time.
                               // Default = on.  Set to 0 to turn them off.

assign RENABLE = ~REN_int & RESET_int;
assign WENABLE = ~WEN_int & RESET_int;

buf b0 ( WCLK_int,   WCLK );
buf b1 ( RCLK_int,   RCLK );
buf b2 ( WEN_int,     WEN );
buf b3 ( REN_int,     REN );
buf b4 ( RESET_int, RESET );

buf b5(RADDR8_int, RADDR8);
buf b6(RADDR7_int, RADDR7);
buf b7(RADDR6_int, RADDR6);
buf b8(RADDR5_int, RADDR5);
buf b9(RADDR4_int, RADDR4);
buf b10(RADDR3_int, RADDR3);
buf b11(RADDR2_int, RADDR2);
buf b12(RADDR1_int, RADDR1);
buf b13(RADDR0_int, RADDR0);

buf b14(WADDR8_int, WADDR8);
buf b15(WADDR7_int, WADDR7);
buf b16(WADDR6_int, WADDR6);
buf b17(WADDR5_int, WADDR5);
buf b18(WADDR4_int, WADDR4);
buf b19(WADDR3_int, WADDR3);
buf b20(WADDR2_int, WADDR2);
buf b21(WADDR1_int, WADDR1);
buf b22(WADDR0_int, WADDR0);

buf b23(WD17_int, WD17);
buf b24(WD16_int, WD16);
buf b25(WD15_int, WD15);
buf b26(WD14_int, WD14);
buf b27(WD13_int, WD13);
buf b28(WD12_int, WD12);
buf b29(WD11_int, WD11);
buf b30(WD10_int, WD10);
buf b31(WD9_int, WD9);
buf b32(WD8_int, WD8);
buf b33(WD7_int, WD7);
buf b34(WD6_int, WD6);
buf b35(WD5_int, WD5);
buf b36(WD4_int, WD4);
buf b37(WD3_int, WD3);
buf b38(WD2_int, WD2);
buf b39(WD1_int, WD1);
buf b40(WD0_int, WD0);
buf b41(PIPE_int,PIPE);

buf b42 ( WW1_int, WW1 );
buf b43 ( WW0_int, WW0 );
buf b44 ( RW1_int, RW1 );
buf b45 ( RW0_int, RW0 );

pmos inst0(RD17, RDP17, 0);
pmos inst1(RD16, RDP16, 0);
pmos inst2(RD15, RDP15, 0);
pmos inst3(RD14, RDP14, 0);
pmos inst4(RD13, RDP13, 0);
pmos inst5(RD12, RDP12, 0);
pmos inst6(RD11, RDP11, 0);
pmos inst7(RD10, RDP10, 0);
pmos inst8(RD9, RDP9, 0);
pmos inst9(RD8, RDP8, 0);
pmos inst10(RD7, RDP7, 0);
pmos inst11(RD6, RDP6, 0);
pmos inst12(RD5, RDP5, 0);
pmos inst13(RD4, RDP4, 0);
pmos inst14(RD3, RDP3, 0);
pmos inst15(RD2, RDP2, 0);
pmos inst16(RD1, RDP1, 0);
pmos inst17(RD0, RDP0, 0);

  CORERAM512X18 DYNCONFIG (
                .RADDR8  ( RADDR8_int  ), .RADDR7  ( RADDR7_int  ), .RADDR6 ( RADDR6_int ),
                .RADDR5  ( RADDR5_int  ), .RADDR4  ( RADDR4_int  ), .RADDR3 ( RADDR3_int ),
                .RADDR2  ( RADDR2_int  ), .RADDR1  ( RADDR1_int  ), .RADDR0 ( RADDR0_int ),
                .WADDR8  ( WADDR8_int  ), .WADDR7  ( WADDR7_int  ), .WADDR6 ( WADDR6_int ),
                .WADDR5  ( WADDR5_int  ), .WADDR4  ( WADDR4_int  ), .WADDR3 ( WADDR3_int ),
                .WADDR2  ( WADDR2_int  ), .WADDR1  ( WADDR1_int  ), .WADDR0 ( WADDR0_int ),
                .RD17    ( RDP17       ), .RD16    ( RDP16       ), .RD15   ( RDP15      ),
                .RD14    ( RDP14       ), .RD13    ( RDP13       ), .RD12   ( RDP12      ),
                .RD11    ( RDP11       ), .RD10    ( RDP10       ), .RD9    ( RDP9       ),
                .RD8     ( RDP8        ), .RD7     ( RDP7        ), .RD6    ( RDP6       ),
                .RD5     ( RDP5        ), .RD4     ( RDP4        ), .RD3    ( RDP3       ),
                .RD2     ( RDP2        ), .RD1     ( RDP1        ), .RD0    ( RDP0       ),
                .WD17    ( WD17_int    ), .WD16    ( WD16_int    ), .WD15   ( WD15_int   ),
                .WD14    ( WD14_int    ), .WD13    ( WD13_int    ), .WD12   ( WD12_int   ),
                .WD11    ( WD11_int    ), .WD10    ( WD10_int    ), .WD9    ( WD9_int    ),
                .WD8     ( WD8_int     ), .WD7     ( WD7_int     ), .WD6    ( WD6_int    ),
                .WD5     ( WD5_int     ), .WD4     ( WD4_int     ), .WD3    ( WD3_int    ),
                .WD2     ( WD2_int     ), .WD1     ( WD1_int     ), .WD0    ( WD0_int    ),
                .RW1     ( RW1_int     ), .RW0     ( RW0_int     ), .REN    ( REN_int    ),
                .RCLK    ( RCLK_int    ), .WCLK    ( WCLK_int    ), .PIPE   ( PIPE_int   ),
                .WW1     ( WW1_int     ), .WW0     ( WW0_int     ), .WEN    ( WEN_int    ),
                .RESET   ( RESET_int   )

               );

  defparam DYNCONFIG.DYNAMIC = 1;
  defparam DYNCONFIG.MEMORYFILE = MEMORYFILE;
  defparam DYNCONFIG.WARNING_MSGS_ON = WARNING_MSGS_ON;

  specify

      specparam   LibName     = "smartfusion";
      (posedge RCLK => (RD0+:RD0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD1+:RD1) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD2+:RD2) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD3+:RD3) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD4+:RD4) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD5+:RD5) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD6+:RD6) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD7+:RD7) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD8+:RD8) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD9+:RD9) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD10+:RD10) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD11+:RD11) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD12+:RD12) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD13+:RD13) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD14+:RD14) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD15+:RD15) ) = (1.0:1.0:1.0, 1.0:1.0:1.0); 
      (posedge RCLK => (RD16+:RD16) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (posedge RCLK => (RD17+:RD17) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

      (negedge RESET => (RD0+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD1+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD2+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD3+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD4+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD5+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD6+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD7+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD8+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD9+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD10+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD11+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD12+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD13+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD14+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD15+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD16+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);
      (negedge RESET => (RD17+:1'b0) ) = (1.0:1.0:1.0, 1.0:1.0:1.0);

 
      $setup(posedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $setup(negedge RADDR8, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, posedge RADDR8, 0.0, NOTIFY_REG);
      $hold(posedge RCLK &&& RENABLE, negedge RADDR8, 0.0, NOTIFY_REG);
      $setup(posedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR7, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR6, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR5, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR4, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR3, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR2, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR1, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge RADDR0, posedge RCLK &&& RENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, posedge RADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge RCLK &&& RENABLE, negedge RADDR0, 0.0, NOTIFY_REG);

      $setup(posedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $setup(negedge REN, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, posedge REN, 0.0, NOTIFY_REG);
      $hold(posedge RCLK, negedge REN, 0.0, NOTIFY_REG);
 

      $setup(posedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR8, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR7, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR6, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR5, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR4, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR3, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR2, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR1, 0.0, NOTIFY_REG); 
      $setup(posedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WADDR0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WADDR0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WADDR0, 0.0, NOTIFY_REG); 

      $setup(posedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD17, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD17, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD17, 0.0, NOTIFY_REG); 
      $setup(posedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD16, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD16, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD16, 0.0, NOTIFY_REG); 
      $setup(posedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD15, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD15, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD15, 0.0, NOTIFY_REG); 
      $setup(posedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD14, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD14, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD14, 0.0, NOTIFY_REG); 
      $setup(posedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD13, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD13, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD13, 0.0, NOTIFY_REG); 
      $setup(posedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD12, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD12, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD12, 0.0, NOTIFY_REG); 
      $setup(posedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD11, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD11, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD11, 0.0, NOTIFY_REG); 
      $setup(posedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD10, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD10, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD10, 0.0, NOTIFY_REG); 
      $setup(posedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD9, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD9, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD9, 0.0, NOTIFY_REG);

      $setup(posedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD8, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD8, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD8, 0.0, NOTIFY_REG); 
      $setup(posedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD7, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD7, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD7, 0.0, NOTIFY_REG); 
      $setup(posedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD6, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD6, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD6, 0.0, NOTIFY_REG); 
      $setup(posedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD5, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD5, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD5, 0.0, NOTIFY_REG); 
      $setup(posedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD4, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD4, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD4, 0.0, NOTIFY_REG); 
      $setup(posedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD3, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD3, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD3, 0.0, NOTIFY_REG); 
      $setup(posedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD2, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD2, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD2, 0.0, NOTIFY_REG); 
      $setup(posedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD1, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD1, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD1, 0.0, NOTIFY_REG); 
      $setup(posedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $setup(negedge WD0, posedge WCLK &&& WENABLE, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, posedge WD0, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK &&& WENABLE, negedge WD0, 0.0, NOTIFY_REG);

      $setup(posedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $setup(negedge WEN, posedge WCLK, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, posedge WEN, 0.0, NOTIFY_REG); 
      $hold(posedge WCLK, negedge WEN, 0.0, NOTIFY_REG); 
 
      $recovery(posedge RESET, posedge RCLK, 0.0, NOTIFY_REG);
      $hold(posedge RCLK,posedge RESET, 0.0, NOTIFY_REG);

      $recovery(posedge RESET, posedge WCLK, 0.0, NOTIFY_REG);
      $hold(posedge WCLK,posedge RESET, 0.0, NOTIFY_REG);

      $width(negedge RESET, 0.0, 0, NOTIFY_REG);
      $width(posedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge RCLK, 0.0, 0, NOTIFY_REG);
      $width(posedge WCLK, 0.0, 0, NOTIFY_REG);
      $width(negedge WCLK, 0.0, 0, NOTIFY_REG);
 endspecify

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE FLEXRAM512X18 ----

//---- MODULE SIMBUF ----
/*--------------------------------------------------------------------
 CELL NAME : SIMBUF
 CELL TYPE : comb
 CELL LOGIC : PAD=D
---------------------------------------------------------------------*/

`suppress_faults
`enable_portfaults
`celldefine
`delay_mode_path
`timescale 1 ns / 100 ps

module SIMBUF(PAD,D);
 input D;
 output PAD;
 reg NOTIFY_REG;

 buf	BUF_U_00(PAD,D);

endmodule

`endcelldefine
`disable_portfaults
`nosuppress_faults
//---- END MODULE SIMBUF ----
